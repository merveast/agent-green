id;reviewer_id;sample_id;smell;severity;review_timestamp;type;code_name;repository;commit_hash;path;start_line;end_line;link;is_from_industry_relevant_project;code_snippet
11964;3;4610445;blob;major;2019-08-05 22:31:21.323313;class;org.apache.flink.runtime.rest.messages.checkpoints.SubtaskCheckpointStatistics;git@github.com:apache/flink.git;8068c8775ad067d75828e6360e7e0994348da9b9;/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/checkpoints/SubtaskCheckpointStatistics.java;31;283;https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/checkpoints/SubtaskCheckpointStatistics.java/#L31-L283;1;"@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = ""@class"")
@JsonSubTypes({
	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.CompletedSubtaskCheckpointStatistics.class, name = ""completed""),
	@JsonSubTypes.Type(value = SubtaskCheckpointStatistics.PendingSubtaskCheckpointStatistics.class, name = ""pending"")})
public class SubtaskCheckpointStatistics {

	public static final String FIELD_NAME_INDEX = ""index"";

	public static final String FIELD_NAME_CHECKPOINT_STATUS = ""status"";

	@JsonProperty(FIELD_NAME_INDEX)
	private final int index;

	@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS)
	private final String checkpointStatus;

	@JsonCreator
	private SubtaskCheckpointStatistics(
			@JsonProperty(FIELD_NAME_INDEX) int index,
			@JsonProperty(FIELD_NAME_CHECKPOINT_STATUS) String checkpointStatus) {
		this.index = index;
		this.checkpointStatus = checkpointStatus;
	}

	public int getIndex() {
		return index;
	}

	public String getCheckpointStatus() {
		return checkpointStatus;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		SubtaskCheckpointStatistics that = (SubtaskCheckpointStatistics) o;
		return index == that.index &&
			Objects.equals(checkpointStatus, that.checkpointStatus);
	}

	@Override
	public int hashCode() {
		return Objects.hash(index, checkpointStatus);
	}

	// ---------------------------------------------------------------------------------
	// Static inner classes
	// ---------------------------------------------------------------------------------

	/**
	 * Checkpoint statistics for a completed subtask checkpoint.
	 */
	public static final class CompletedSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {

		public static final String FIELD_NAME_ACK_TIMESTAMP = ""ack_timestamp"";

		public static final String FIELD_NAME_DURATION = ""end_to_end_duration"";

		public static final String FIELD_NAME_STATE_SIZE = ""state_size"";

		public static final String FIELD_NAME_CHECKPOINT_DURATION = ""checkpoint"";

		public static final String FIELD_NAME_ALIGNMENT = ""alignment"";

		@JsonProperty(FIELD_NAME_ACK_TIMESTAMP)
		private final long ackTimestamp;

		@JsonProperty(FIELD_NAME_DURATION)
		private final long duration;

		@JsonProperty(FIELD_NAME_STATE_SIZE)
		private final long stateSize;

		@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION)
		private final CheckpointDuration checkpointDuration;

		@JsonProperty(FIELD_NAME_ALIGNMENT)
		private final CheckpointAlignment alignment;

		@JsonCreator
		public CompletedSubtaskCheckpointStatistics(
				@JsonProperty(FIELD_NAME_INDEX) int index,
				@JsonProperty(FIELD_NAME_ACK_TIMESTAMP) long ackTimestamp,
				@JsonProperty(FIELD_NAME_DURATION) long duration,
				@JsonProperty(FIELD_NAME_STATE_SIZE) long stateSize,
				@JsonProperty(FIELD_NAME_CHECKPOINT_DURATION) CheckpointDuration checkpointDuration,
				@JsonProperty(FIELD_NAME_ALIGNMENT) CheckpointAlignment alignment) {
			super(index, ""completed"");
			this.ackTimestamp = ackTimestamp;
			this.duration = duration;
			this.stateSize = stateSize;
			this.checkpointDuration = checkpointDuration;
			this.alignment = alignment;
		}

		public long getAckTimestamp() {
			return ackTimestamp;
		}

		public long getDuration() {
			return duration;
		}

		public long getStateSize() {
			return stateSize;
		}

		public CheckpointDuration getCheckpointDuration() {
			return checkpointDuration;
		}

		public CheckpointAlignment getAlignment() {
			return alignment;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (o == null || getClass() != o.getClass()) {
				return false;
			}
			CompletedSubtaskCheckpointStatistics that = (CompletedSubtaskCheckpointStatistics) o;
			return ackTimestamp == that.ackTimestamp &&
				duration == that.duration &&
				stateSize == that.stateSize &&
				Objects.equals(checkpointDuration, that.checkpointDuration) &&
				Objects.equals(alignment, that.alignment);
		}

		@Override
		public int hashCode() {
			return Objects.hash(ackTimestamp, duration, stateSize, checkpointDuration, alignment);
		}

		/**
		 * Duration of the checkpoint.
		 */
		public static final class CheckpointDuration {

			public static final String FIELD_NAME_SYNC_DURATION = ""sync"";

			public static final String FIELD_NAME_ASYNC_DURATION = ""async"";

			@JsonProperty(FIELD_NAME_SYNC_DURATION)
			private final long syncDuration;

			@JsonProperty(FIELD_NAME_ASYNC_DURATION)
			private final long asyncDuration;

			@JsonCreator
			public CheckpointDuration(
					@JsonProperty(FIELD_NAME_SYNC_DURATION) long syncDuration,
					@JsonProperty(FIELD_NAME_ASYNC_DURATION) long asyncDuration) {
				this.syncDuration = syncDuration;
				this.asyncDuration = asyncDuration;
			}

			public long getSyncDuration() {
				return syncDuration;
			}

			public long getAsyncDuration() {
				return asyncDuration;
			}

			@Override
			public boolean equals(Object o) {
				if (this == o) {
					return true;
				}
				if (o == null || getClass() != o.getClass()) {
					return false;
				}
				CheckpointDuration that = (CheckpointDuration) o;
				return syncDuration == that.syncDuration &&
					asyncDuration == that.asyncDuration;
			}

			@Override
			public int hashCode() {
				return Objects.hash(syncDuration, asyncDuration);
			}
		}

		/**
		 * Alignment statistics of the checkpoint.
		 */
		public static final class CheckpointAlignment {

			public static final String FIELD_NAME_ALIGNMENT_BUFFERED = ""buffered"";

			public static final String FIELD_NAME_ALIGNMENT_DURATION = ""duration"";

			@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED)
			private final long alignmentBuffered;

			@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION)
			private final long alignmentDuration;

			@JsonCreator
			public CheckpointAlignment(
					@JsonProperty(FIELD_NAME_ALIGNMENT_BUFFERED) long alignmentBuffered,
					@JsonProperty(FIELD_NAME_ALIGNMENT_DURATION) long alignmentDuration) {
				this.alignmentBuffered = alignmentBuffered;
				this.alignmentDuration = alignmentDuration;
			}

			public long getAlignmentBuffered() {
				return alignmentBuffered;
			}

			public long getAlignmentDuration() {
				return alignmentDuration;
			}

			@Override
			public boolean equals(Object o) {
				if (this == o) {
					return true;
				}
				if (o == null || getClass() != o.getClass()) {
					return false;
				}
				CheckpointAlignment that = (CheckpointAlignment) o;
				return alignmentBuffered == that.alignmentBuffered &&
					alignmentDuration == that.alignmentDuration;
			}

			@Override
			public int hashCode() {
				return Objects.hash(alignmentBuffered, alignmentDuration);
			}
		}
	}

	/**
	 * Checkpoint statistics for a pending subtask checkpoint.
	 */
	public static final class PendingSubtaskCheckpointStatistics extends SubtaskCheckpointStatistics {

		@JsonCreator
		public PendingSubtaskCheckpointStatistics(@JsonProperty(FIELD_NAME_INDEX) int index) {
			super(index, ""pending_or_failed"");
		}
	}
}"
879;11;6536605;feature envy;major;2019-03-29 13:18:14.226406;function;org.eclipse.smarthome.io.net.http.HttpUtil.executeUrl String|String|Properties|InputStream|String|int;git@github.com:eclipse/smarthome.git;b8455de15d65512e8fac4e94d42de6ab2fccf1c5;/bundles/io/org.eclipse.smarthome.io.net/src/main/java/org/eclipse/smarthome/io/net/http/HttpUtil.java;127;133;https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/io/org.eclipse.smarthome.io.net/src/main/java/org/eclipse/smarthome/io/net/http/HttpUtil.java/#L127-L133;1;"    public static String executeUrl(String httpMethod, String url, Properties httpHeaders, InputStream content,
            String contentType, int timeout) throws IOException {
        final ProxyParams proxyParams = prepareProxyParams();

        return executeUrl(httpMethod, url, httpHeaders, content, contentType, timeout, proxyParams.proxyHost,
                proxyParams.proxyPort, proxyParams.proxyUser, proxyParams.proxyPassword, proxyParams.nonProxyHosts);
    }"
3699;4;9376700;long method;major;2019-04-05 13:20:02.786818;function;sun.java2d.loops.OpaqueCopyArgbToAny#Blit SurfaceData|SurfaceData|Composite|Region|int|int|int|int|int|int;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.desktop/share/classes/sun/java2d/loops/CustomComponent.java;171;213;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.desktop/share/classes/sun/java2d/loops/CustomComponent.java/#L171-L213;1;"    public void Blit(SurfaceData src, SurfaceData dst,
                     Composite comp, Region clip,
                     int srcx, int srcy, int dstx, int dsty, int w, int h)
    {
        Raster srcRast = src.getRaster(srcx, srcy, w, h);
        IntegerComponentRaster icr = (IntegerComponentRaster) srcRast;
        int[] srcPix = icr.getDataStorage();

        WritableRaster dstRast =
            (WritableRaster) dst.getRaster(dstx, dsty, w, h);
        ColorModel dstCM = dst.getColorModel();

        Region roi = CustomComponent.getRegionOfInterest(src, dst, clip,
                                                         srcx, srcy,
                                                         dstx, dsty, w, h);
        SpanIterator si = roi.getSpanIterator();

        Object dstPix = null;

        int srcScan = icr.getScanlineStride();
        // assert(icr.getPixelStride() == 1);
        srcx -= dstx;
        srcy -= dsty;
        int[] span = new int[4];
        while (si.nextSpan(span)) {
            int rowoff = (icr.getDataOffset(0) +
                          (srcy + span[1]) * srcScan +
                          (srcx + span[0]));
            for (int y = span[1]; y < span[3]; y++) {
                int off = rowoff;
                for (int x = span[0]; x < span[2]; x++) {
                    dstPix = dstCM.getDataElements(srcPix[off++], dstPix);
                    dstRast.setDataElements(x, y, dstPix);
                }
                rowoff += srcScan;
            }
        }
        // REMIND: We need to do something to make sure that dstRast
        // is put back to the destination (as in the native Release
        // function)
        // src.releaseRaster(srcRast);  // NOP?
        // dst.releaseRaster(dstRast);
    }"
11086;13;6529636;feature envy;major;2019-08-02 11:10:59.412994;function;org.eclipse.smarthome.model.script.actions.BusEvent.postUpdate String|String;git@github.com:eclipse/smarthome.git;b8455de15d65512e8fac4e94d42de6ab2fccf1c5;/bundles/model/org.eclipse.smarthome.model.script/src/org/eclipse/smarthome/model/script/actions/BusEvent.java;153;172;https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/model/org.eclipse.smarthome.model.script/src/org/eclipse/smarthome/model/script/actions/BusEvent.java/#L153-L172;1;"    static public Object postUpdate(String itemName, String stateString) {
        ItemRegistry registry = ScriptServiceUtil.getItemRegistry();
        EventPublisher publisher = ScriptServiceUtil.getEventPublisher();
        if (publisher != null && registry != null) {
            try {
                Item item = registry.getItem(itemName);
                State state = TypeParser.parseState(item.getAcceptedDataTypes(), stateString);
                if (state != null) {
                    publisher.post(ItemEventFactory.createStateEvent(itemName, state));
                } else {
                    LoggerFactory.getLogger(BusEvent.class).warn(
                            ""Cannot convert '{}' to a state type which item '{}' accepts: {}."", stateString, itemName,
                            getAcceptedDataTypeNames(item));
                }
            } catch (ItemNotFoundException e) {
                LoggerFactory.getLogger(BusEvent.class).warn(""Item '{}' does not exist."", itemName);
            }
        }
        return null;
    }"
1327;12;6839966;feature envy;major;2019-03-29 13:44:18.976588;function;com.google.caja.lexer.ExternalReference#hashCode;git@github.com:google/caja.git;964609d5ec3272e4060cfb990bf263f6e5c56e22;/src/com/google/caja/lexer/ExternalReference.java;84;87;https://github.com/google/caja/blob/964609d5ec3272e4060cfb990bf263f6e5c56e22/src/com/google/caja/lexer/ExternalReference.java/#L84-L87;0,5;"  @Override
  public int hashCode() {
    return uri.hashCode();
  }"
11030;3;7944953;blob;major;2019-08-02 00:44:51.850594;class;org.eclipse.xtext.common.types.descriptions.JvmDeclaredTypeSignatureHashProvider.SignatureHashBuilder;git@github.com:eclipse/xtext-extras.git;5634c291880cd46fe2f8e9a47e48ef88b85e8bda;/org.eclipse.xtext.common.types/src/org/eclipse/xtext/common/types/descriptions/JvmDeclaredTypeSignatureHashProvider.java;77;261;https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.common.types/src/org/eclipse/xtext/common/types/descriptions/JvmDeclaredTypeSignatureHashProvider.java/#L77-L261;0;"	public static class SignatureHashBuilder {

		@Inject
		private JvmDeclaredTypeSignatureHashProvider hashProvider;

		@Inject
		private AnnotationSignatureRelevanceUtil annotationRelevance;
		
		private MessageDigest digest;

		private StringBuilder builder;
		
		public SignatureHashBuilder() {
			digest = createDigest();
			if(digest == null)
				builder = new StringBuilder();
		}
		
		protected MessageDigest createDigest() {
			try {
				return MessageDigest.getInstance(""MD5"");
			} catch (NoSuchAlgorithmException e) {
				LOG.error(""Error creating message digest"", e);
				return null;
			}
		}

		protected SignatureHashBuilder append(String s) {
			if(digest != null)
				try {
					digest.update(s.getBytes(""UTF8""));
				} catch (UnsupportedEncodingException e) {
					LOG.error(""Error encoding String"", e);
				}
			if(builder != null)
				builder.append(s);
			return this;
		}

		public SignatureHashBuilder appendSignature(JvmDeclaredType type) {
			if (type.getVisibility() != JvmVisibility.PRIVATE) {
				appendAnnotationReferences(type);
				appendVisibility(type.getVisibility()).append("" "");
				if (type.isAbstract())
					append(""abstract "");
				if (type.isStatic())
					append(""static "");
				if (type.isFinal())
					append(""final "");
				append(""class "").append(type.getIdentifier());
				if (type instanceof JvmTypeParameterDeclarator)
					appendTypeParameters((JvmTypeParameterDeclarator) type);
				append(""\n"").appendSuperTypeSignatures(type).appendMemberSignatures(type, false);
			}
			return this;
		}

		protected SignatureHashBuilder appendMemberSignatures(JvmDeclaredType type, boolean innerTypesOnly) {
			Iterable<? extends JvmMember> members = type.getMembers();
			if(innerTypesOnly)
				members = filter(members, JvmDeclaredType.class);
			for (JvmMember member : members) {
				if (member.getSimpleName() != null) {
					appendAnnotationReferences(member);
					if (member instanceof JvmOperation) 
						appendSignature((JvmOperation) member);
					else if (member instanceof JvmConstructor) 
						appendSignature((JvmConstructor) member);
					else if (member instanceof JvmField) 
						appendSignature((JvmField) member);
					else if (member instanceof JvmDeclaredType) {
						append(member.getQualifiedName());
						appendMemberSignatures((JvmDeclaredType) member, true);
					}
					append(""\n"");
				}
			}
			return this;
		}

		protected void appendAnnotationReferences(JvmAnnotationTarget target) {
			for(JvmAnnotationReference annotationReference: target.getAnnotations()) {
				if(annotationRelevance.isRelevant(annotationReference)) 
					append(hashProvider.getHash(annotationReference.getAnnotation()))
						.append("" "");
			}
		}

		protected SignatureHashBuilder appendSuperTypeSignatures(JvmDeclaredType type) {
			for(JvmTypeReference superType: type.getSuperTypes()) {
				append(""super "");
				append(superType.getIdentifier());
				append(""\n"");
			}
			return this;
		}

		protected SignatureHashBuilder appendSignature(JvmOperation operation) {
			appendVisibility(operation.getVisibility()).append("" "");
			if (operation.isAbstract())
				append(""abstract "");
			if (operation.isStatic())
				append(""static "");
			if (operation.isFinal())
				append(""final "");
			appendType(operation.getReturnType()).appendTypeParameters(operation).append("" "")
					.append(operation.getSimpleName()).append(""("");
			for (JvmFormalParameter p : operation.getParameters()) {
				appendType(p.getParameterType());
				append("" "");
			}
			append("") "");
			for (JvmTypeReference ex : operation.getExceptions()) {
				appendType(ex).append("" "");
			}
			return this;
		}

		protected SignatureHashBuilder appendSignature(JvmField field) {
			appendVisibility(field.getVisibility()).append("" "");
			if (field.isStatic())
				append(""static "");
			if (field.isFinal())
				append(""final "");
			return appendType(field.getType()).append("" "").append(field.getSimpleName());
		}

		protected SignatureHashBuilder appendSignature(JvmConstructor operation) {
			appendVisibility(operation.getVisibility()).appendTypeParameters(operation).append(""("");
			for (JvmFormalParameter p : operation.getParameters()) {
				appendType(p.getParameterType()).append("" "");
			}
			append("") "");
			for (JvmTypeReference ex : operation.getExceptions()) {
				appendType(ex).append("" "");
			}
			return this;
		}

		protected SignatureHashBuilder appendTypeParameters(JvmTypeParameterDeclarator decl) {
			append(""<"");
			for (JvmTypeParameter tp : decl.getTypeParameters()) {
				appendTypeParameter(tp).append("","");
			}
			append("">"");
			return this;
		}

		protected SignatureHashBuilder appendType(JvmTypeReference ref) {
			if (ref != null && ref.getIdentifier() != null) {
				append(ref.getIdentifier());
			} else {
				append(""*unresolved*"");
			}
			return this;
		}

		protected SignatureHashBuilder appendVisibility(JvmVisibility v) {
			append(v.getLiteral());
			return this;
		}

		protected SignatureHashBuilder appendTypeParameter(JvmTypeParameter p) {
			if (p != null && p.getIdentifier() != null) {
				append(p.getIdentifier());
			} else {
				append(""*unresolved*"");
			}
			return this;
		}

		public String hash() {
			try {
				if(digest != null) {
					byte[] digestBytes = digest.digest();
					return new BigInteger(digestBytes).toString(16);
				} else {
					return builder.toString();
				}
			} catch (Exception e) {
				LOG.error(""Error hashing JvmDeclaredType signature"", e);
				return """";
			}
		}
	}"
12384;3;7148614;blob;none;2019-08-06 13:15:26.353517;class;com.microsoft.intellij.ApplicationSettings.State;git@github.com:Microsoft/azure-tools-for-java.git;d121e8ac9cc3ab400e5b49c8b372280ae332f3fb;/PluginsAndFeatures/azure-toolkit-for-intellij/src/com/microsoft/intellij/ApplicationSettings.java;58;61;https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/PluginsAndFeatures/azure-toolkit-for-intellij/src/com/microsoft/intellij/ApplicationSettings.java/#L58-L61;1;"    public static class State {
        public Map<String, String> properties = new HashMap<String, String>();
        public Map<String, String[]> array_properties = new HashMap<String, String[]>();
    }"
13382;1;5473710;data class;major;2019-08-29 14:09:33.196073;class;org.apache.qpid.server.security.access.plugins.AclRule;git@github.com:apache/qpid-broker-j.git;4c4400b98a5a8493cfb9e5dbb21c97175f433a62;/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java;31;39;https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java/#L31-L39;1;"@ManagedAttributeValueType
public interface AclRule extends ManagedAttributeValue
{
    String getIdentity();
    ObjectType getObjectType();
    LegacyOperation getOperation();
    Map<ObjectProperties.Property,String> getAttributes();
    RuleOutcome getOutcome();
}"
800;5;6432897;data class;none;2019-03-29 13:11:35.236666;class;org.eclipse.milo.opcua.sdk.server.model.types.objects.SystemOffNormalAlarmType;git@github.com:eclipse/milo.git;e752e540d31eb3c226e6e79dd197c54d7d254685;/opc-ua-sdk/sdk-server/src/main/java/org/eclipse/milo/opcua/sdk/server/model/types/objects/SystemOffNormalAlarmType.java;3;4;https://github.com/eclipse/milo/blob/e752e540d31eb3c226e6e79dd197c54d7d254685/opc-ua-sdk/sdk-server/src/main/java/org/eclipse/milo/opcua/sdk/server/model/types/objects/SystemOffNormalAlarmType.java/#L3-L4;1;"public interface SystemOffNormalAlarmType extends OffNormalAlarmType {
}"
13101;11;5456950;feature envy;major;2019-08-23 07:12:10.704386;function;org.apache.pulsar.broker.loadbalance.impl.SimpleLoadManagerImpl.isBelowLoadLevel SystemResourceUsage|float;git@github.com:apache/pulsar.git;044daf8d61328265640a5b3e5008fc04fac73efa;/pulsar-broker/src/main/java/org/apache/pulsar/broker/loadbalance/impl/SimpleLoadManagerImpl.java;1069;1074;https://github.com/apache/pulsar/blob/044daf8d61328265640a5b3e5008fc04fac73efa/pulsar-broker/src/main/java/org/apache/pulsar/broker/loadbalance/impl/SimpleLoadManagerImpl.java/#L1069-L1074;1;"    public static boolean isBelowLoadLevel(SystemResourceUsage usage, float thresholdPercentage) {
        return (usage.bandwidthOut.percentUsage() < thresholdPercentage
                && usage.bandwidthIn.percentUsage() < thresholdPercentage
                && usage.cpu.percentUsage() < thresholdPercentage
                && usage.directMemory.percentUsage() < thresholdPercentage);
    }"
10637;13;7129689;data class;major;2019-07-26 12:55:37.973875;class;com.linkedin.restli.server.UpdateEntityResponse;git@github.com:linkedin/rest.li.git;ad74aa98da8a55ad9c339d0769a3e8fb495765af;/restli-server/src/main/java/com/linkedin/restli/server/UpdateEntityResponse.java;31;50;https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/UpdateEntityResponse.java/#L31-L50;1;"public class UpdateEntityResponse<V extends RecordTemplate> extends UpdateResponse
{
  private final V _entity;

  public UpdateEntityResponse(final HttpStatus status, final V entity)
  {
    super(status);
    _entity = entity;
  }

  public boolean hasEntity()
  {
    return _entity != null;
  }

  public V getEntity()
  {
    return _entity;
  }
}"
1725;4;8026786;long method;none;2019-03-29 14:14:41.823721;function;org.eclipse.xtext.ui.tests.editor.contentassist.services.BacktrackingContentAssistTestLanguageGrammarAccess.LetVariableElements#getInitExpressionExpressionParserRuleCall_4_0;git@github.com:eclipse/xtext-eclipse.git;0c7546b6aaf3644a77fc68eef9f3da368cbbeabd;/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/BacktrackingContentAssistTestLanguageGrammarAccess.java;3100;3100;https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/BacktrackingContentAssistTestLanguageGrammarAccess.java/#L3100-L3100;1;"		public RuleCall getInitExpressionExpressionParserRuleCall_4_0() { return cInitExpressionExpressionParserRuleCall_4_0; }"
11414;3;7747098;blob;major;2019-08-04 22:48:06.488124;class;org.apache.brooklyn.util.text.StringFunctions;git@github.com:apache/incubator-brooklyn.git;337a5d22d5e9c98cc96ea1085383cbed1ee0b741;/brooklyn-server/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java;32;415;https://github.com/apache/incubator-brooklyn/blob/337a5d22d5e9c98cc96ea1085383cbed1ee0b741/brooklyn-server/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java/#L32-L415;1;"public class StringFunctions {

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,String> appendOld(final String suffix) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            @Nullable
            public String apply(@Nullable String input) {
                if (input==null) return null;
                return input + suffix;
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,String> prependOld(final String prefix) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            @Nullable
            public String apply(@Nullable String input) {
                if (input==null) return null;
                return prefix + input;
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Object, String> formatterOld(final String pattern) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Object, String>() {
            public String apply(@Nullable Object input) {
                return String.format(pattern, input);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Object[], String> formatterForArrayOld(final String pattern) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Object[], String>() {
            public String apply(@Nullable Object[] input) {
                return String.format(pattern, input);
            }
        };
    }
    
    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Iterable<?>, String> joinerOld(final String separator) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Iterable<?>, String>() {
            public String apply(@Nullable Iterable<?> input) {
                return Strings.join(input, separator);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Object[], String> joinerForArrayOld(final String separator) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Object[], String>() {
            public String apply(@Nullable Object[] input) {
                if (input == null) return Strings.EMPTY;
                return Strings.join(input, separator);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,Integer> lengthOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String,Integer>() {
            @Override
            public Integer apply(@Nullable String input) {
                if (input == null) return -1;
                return input.length();
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,String> surroundOld(final String prefix, final String suffix) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String,String>() {
            @Override
            public String apply(@Nullable String input) {
                if (input == null) return null;
                return prefix+input+suffix;
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> trimOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(@Nullable String input) {
                if (input == null) return null;
                if (Strings.isBlank(input)) return Strings.EMPTY;
                return CharMatcher.BREAKING_WHITESPACE.trimFrom(input);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> toLowerCaseOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(String input) {
                return input.toLowerCase();
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> toUpperCaseOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(String input) {
                return input.toUpperCase();
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> convertCaseOld(final CaseFormat src, final CaseFormat target) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(String input) {
                return src.to(target, input);
            }
        };
    }

    public static Function<String,String> append(final String suffix) {
        return new AppendFunction(checkNotNull(suffix, ""suffix""));
    }

    private static class AppendFunction implements Function<String, String> {
        private final String suffix;

        public AppendFunction(String suffix) {
            this.suffix = suffix;
        }
        @Override
        @Nullable
        public String apply(@Nullable String input) {
            if (input==null) return null;
            return input + suffix;
        }
    };

    public static Function<String,String> prepend(final String prefix) {
        return new PrependFunction(checkNotNull(prefix, ""prefix""));
    }
    
    protected static class PrependFunction implements Function<String, String> {
        private final String prefix;

        public PrependFunction(String prefix) {
            this.prefix = prefix;
        }

        @Override
        @Nullable
        public String apply(@Nullable String input) {
            if (input==null) return null;
            return prefix + input;
        }
    }

    /** given e.g. ""hello %s"" returns a function which will insert a string into that pattern */
    public static Function<Object, String> formatter(final String pattern) {
        return new FormatterFunction(pattern);
    }

    protected static class FormatterFunction implements Function<Object, String> {
        private final String pattern;
        
        FormatterFunction(String pattern) {
            this.pattern = pattern;
        }
        public String apply(@Nullable Object input) {
            return String.format(pattern, input);
        }
    };

    /** given e.g. ""hello %s %s"" returns a function which will insert an array of two strings into that pattern */
    public static Function<Object[], String> formatterForArray(final String pattern) {
        return new FormatterForArrayFunction(checkNotNull(pattern, ""pattern""));
    }
    
    protected static class FormatterForArrayFunction implements Function<Object[], String> {
        private final String pattern;
        
        public FormatterForArrayFunction(String pattern) {
            this.pattern = pattern;
        }
        public String apply(@Nullable Object[] input) {
            return String.format(pattern, input);
        }
    }
    
    /** 
     * Given e.g. ""hello %s %s"" returns a function which will insert an Iterable of two strings into that pattern
     * 
     * @since 0.9.0
     */
    public static Function<Iterable<?>, String> formatterForIterable(final String pattern) {
        return new FormatterForIterableFunction(pattern);
    }

    protected static class FormatterForIterableFunction implements Function<Iterable<?>, String> {
        final String pattern;

        public FormatterForIterableFunction(String pattern) {
            this.pattern = pattern;
        }

        public String apply(@Nullable Iterable<?> input) {
            Object[] arr = (input == null) ? null : Iterables.toArray(input, Object.class);
            return String.format(pattern, arr);
        }
    }

    /** joins the given objects in a collection as a toString with the given separator */
    public static Function<Iterable<?>, String> joiner(final String separator) {
        return new JoinerFunction(separator);
    }

    private static class JoinerFunction implements Function<Iterable<?>, String> {
        private final String separator;

        public JoinerFunction(String separator) {
            this.separator = separator;
        }
        public String apply(@Nullable Iterable<?> input) {
            return Strings.join(input, separator);
        }
    }
    
    /** joins the given objects as a toString with the given separator, but expecting an array of objects, not a collection */
    public static Function<Object[], String> joinerForArray(final String separator) {
        return new JoinerForArrayFunction(checkNotNull(separator, ""separator""));
    }

    private static class JoinerForArrayFunction implements Function<Object[], String> {
        private final String separator;

        protected JoinerForArrayFunction(String separator) {
            this.separator = separator;
        }
        public String apply(@Nullable Object[] input) {
            if (input == null) return Strings.EMPTY;
            return Strings.join(input, separator);
        }
    }

    /** provided here as a convenience; prefer {@link Functions#toStringFunction()} */
    public static Function<Object,String> toStringFunction() {
        return Functions.toStringFunction();
    }

    /** returns function which gives length of input, with -1 for nulls */
    public static Function<String,Integer> length() {
        return new LengthFunction();
    }

    protected static class LengthFunction implements Function<String,Integer> {
        @Override
        public Integer apply(@Nullable String input) {
            if (input == null) return -1;
            return input.length();
        }
    }

    /** Surrounds an input string with the given prefix and suffix */
    public static Function<String,String> surround(final String prefix, final String suffix) {
        Preconditions.checkNotNull(prefix);
        Preconditions.checkNotNull(suffix);
        return new SurroundFunction(prefix, suffix);
    }
    
    protected static class SurroundFunction implements Function<String,String> {
        private final String prefix;
        private final String suffix;
        public SurroundFunction(String prefix, String suffix) {
            this.prefix = prefix;
            this.suffix = suffix;
        }
        @Override
        public String apply(@Nullable String input) {
            if (input == null) return null;
            return prefix+input+suffix;
        }
    }

    public static Function<String, String> trim() {
        return new TrimFunction();
    }
    
    protected static class TrimFunction implements Function<String, String> {
        @Override
        public String apply(@Nullable String input) {
            if (input == null) return null;
            if (Strings.isBlank(input)) return Strings.EMPTY;
            return CharMatcher.BREAKING_WHITESPACE.trimFrom(input);
        }
    }

    public static Function<String, String> toLowerCase() {
        return new LowerCaseFunction();
    }
    
    protected static class LowerCaseFunction implements Function<String, String> {
        @Override
        public String apply(String input) {
            return input.toLowerCase();
        }
    }

    public static Function<String, String> toUpperCase() {
        return new UpperCaseFunction();
    }
    
    protected static class UpperCaseFunction implements Function<String, String> {
        @Override
        public String apply(String input) {
            return input.toUpperCase();
        }
    }

    public static Function<String, String> convertCase(final CaseFormat src, final CaseFormat target) {
        return new ConvertCaseFunction(checkNotNull(src, ""src""), checkNotNull(target, ""target""));
    }
    
    protected static class ConvertCaseFunction implements Function<String, String> {
       private final CaseFormat src;
       private final CaseFormat target;

       public ConvertCaseFunction(CaseFormat src, CaseFormat target) {
          this.src = src;
          this.target = target;
       }

       @Override
       public String apply(String input) {
          return src.to(target, input);
       }
    }

    public static class RegexReplacer implements Function<String, String> {
        private final String pattern;
        private final String replacement;

        public RegexReplacer(String pattern, String replacement) {
            this.pattern = pattern;
            this.replacement = replacement;
        }

        @Nullable
        @Override
        public String apply(@Nullable String s) {
            return Strings.replaceAllRegex(s, pattern, replacement);
        }
    }
}"
6154;10;4044091;feature envy;major;2019-04-19 13:24:58.080785;function;org.apache.asterix.dataflow.data.nontagged.serde.AGeometrySerializerDeserializer#serialize AGeometry|DataOutput;git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/asterixdb/asterix-om/src/main/java/org/apache/asterix/dataflow/data/nontagged/serde/AGeometrySerializerDeserializer.java;63;75;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-om/src/main/java/org/apache/asterix/dataflow/data/nontagged/serde/AGeometrySerializerDeserializer.java/#L63-L75;1;"    @Override
    public void serialize(AGeometry instance, DataOutput out) throws HyracksDataException {
        try {
            OGCGeometry geometry = instance.getGeometry();
            byte[] buffer = geometry.asBinary().array();
            // For efficiency, we store the size of the geometry in bytes in the first 32 bits
            // This allows AsterixDB to skip over this attribute if needed.
            out.writeInt(buffer.length);
            out.write(buffer);
        } catch (IOException e) {
            throw HyracksDataException.create(e);
        }
    }"
836;4;6491821;feature envy;none;2019-03-29 13:15:20.082850;function;org.eclipse.rdf4j.rio.helpers.BufferedGroupingRDFHandler.BufferedGroupingRDFHandler RDFHandler;git@github.com:eclipse/rdf4j.git;6f63df540e30b28e0c8880bea72f85cb88424b03;/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/BufferedGroupingRDFHandler.java;50;52;https://github.com/eclipse/rdf4j/blob/6f63df540e30b28e0c8880bea72f85cb88424b03/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/BufferedGroupingRDFHandler.java/#L50-L52;1;"	public BufferedGroupingRDFHandler(RDFHandler... handlers) {
		this(DEFAULT_BUFFER_SIZE, handlers);
	}"
14662;4;7725777;data class;major;2019-09-12 08:05:24.128604;class;com.vmware.admiral.request.notification.NotificationsService.NotificationsAggregatorState;git@github.com:vmware/admiral.git;e02d0e77f65d0ee3541a378110ecd4233bdb6664;/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java;52;55;https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55;1;"    public static class NotificationsAggregatorState {
        public long recentEventLogsCount;
        public long activeRequestsCount;
    }"
2189;3;8917316;blob;none;2019-04-01 13:23:40.608158;class;org.apache.hadoop.hive.metastore.api.WMMapping.WMMappingStandardSchemeFactory;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/WMMapping.java;729;733;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/WMMapping.java/#L729-L733;1;"  private static class WMMappingStandardSchemeFactory implements SchemeFactory {
    public WMMappingStandardScheme getScheme() {
      return new WMMappingStandardScheme();
    }
  }"
7035;3;5717998;long method;major;2019-05-20 10:21:34.512122;function;org.apache.sysml.utils.Explain.countCompiledInstructions ProgramBlock|ExplainCounts|boolean|boolean|boolean;git@github.com:apache/systemml.git;7fba4b29d653747a9ed038d282954a44fea3031c;/src/main/java/org/apache/sysml/utils/Explain.java;1103;1141;https://github.com/apache/systemml/blob/7fba4b29d653747a9ed038d282954a44fea3031c/src/main/java/org/apache/sysml/utils/Explain.java/#L1103-L1141;1;"	private static void countCompiledInstructions(ProgramBlock pb, ExplainCounts counts, boolean MR, boolean CP, boolean SP) 
	{
		if (pb instanceof WhileProgramBlock)
		{
			WhileProgramBlock tmp = (WhileProgramBlock)pb;
			countCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);
			for (ProgramBlock pb2 : tmp.getChildBlocks())
				countCompiledInstructions(pb2, counts, MR, CP, SP);
		}
		else if (pb instanceof IfProgramBlock)
		{
			IfProgramBlock tmp = (IfProgramBlock)pb;	
			countCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);
			for( ProgramBlock pb2 : tmp.getChildBlocksIfBody() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
			for( ProgramBlock pb2 : tmp.getChildBlocksElseBody() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
		}
		else if (pb instanceof ForProgramBlock) //includes ParFORProgramBlock
		{ 
			ForProgramBlock tmp = (ForProgramBlock)pb;	
			countCompiledInstructions(tmp.getFromInstructions(), counts, MR, CP, SP);
			countCompiledInstructions(tmp.getToInstructions(), counts, MR, CP, SP);
			countCompiledInstructions(tmp.getIncrementInstructions(), counts, MR, CP, SP);
			for( ProgramBlock pb2 : tmp.getChildBlocks() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
			//additional parfor jobs counted during runtime
		}		
		else if (  pb instanceof FunctionProgramBlock ) //includes ExternalFunctionProgramBlock and ExternalFunctionProgramBlockCP
		{
			FunctionProgramBlock fpb = (FunctionProgramBlock)pb;
			for( ProgramBlock pb2 : fpb.getChildBlocks() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
		}
		else 
		{
			countCompiledInstructions(pb.getInstructions(), counts, MR, CP, SP);
		}
	}"
1739;5;8049293;data class;none;2019-03-29 14:15:24.218762;class;org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.GroupToken;git@github.com:eclipse/xtext-core.git;e04964e4c2a3e0338c0079bd8333688835e77c31;/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/AbstractParseTreeConstructor.java;297;301;https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/AbstractParseTreeConstructor.java/#L297-L301;1;"	public abstract class GroupToken extends AbstractToken {
		public GroupToken(AbstractToken parent, AbstractToken next, int no, IEObjectConsumer current) {
			super(parent, next, no, current);
		}
	}"
13082;11;9012542;data class;major;2019-08-23 07:08:59.937044;class;org.apache.lucene.codecs.memory.FSTTermsWriter.FieldMetaData;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java;229;247;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247;1;"  private static class FieldMetaData {
    public final FieldInfo fieldInfo;
    public final long numTerms;
    public final long sumTotalTermFreq;
    public final long sumDocFreq;
    public final int docCount;
    public final int longsSize;
    public final FST<FSTTermOutputs.TermData> dict;

    public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST<FSTTermOutputs.TermData> fst) {
      this.fieldInfo = fieldInfo;
      this.numTerms = numTerms;
      this.sumTotalTermFreq = sumTotalTermFreq;
      this.sumDocFreq = sumDocFreq;
      this.docCount = docCount;
      this.longsSize = longsSize;
      this.dict = fst;
    }
  }"
3719;13;5739211;blob;none;2019-04-05 13:21:20.065059;class;org.apache.storm.messaging.netty.IServer;git@github.com:apache/storm.git;dc56e32f3dcdd9396a827a85029d60ed97474786;/storm-client/src/jvm/org/apache/storm/messaging/netty/IServer.java;17;21;https://github.com/apache/storm/blob/dc56e32f3dcdd9396a827a85029d60ed97474786/storm-client/src/jvm/org/apache/storm/messaging/netty/IServer.java/#L17-L21;1;"public interface IServer {
    void channelActive(Channel c);

    void received(Object message, String remote, Channel channel) throws InterruptedException;
}"
12448;3;8148121;long method;major;2019-08-06 16:33:57.031673;function;com.alibaba.cobar.server.parser.ServerParseSet.characterSet String|int|int;git@github.com:alibaba/cobar.git;bc36a14d4a3f8acc0db0b3b07a7db8d38afefda5;/server/src/main/server/com/alibaba/cobar/server/parser/ServerParseSet.java;192;226;https://github.com/alibaba/cobar/blob/bc36a14d4a3f8acc0db0b3b07a7db8d38afefda5/server/src/main/server/com/alibaba/cobar/server/parser/ServerParseSet.java/#L192-L226;0,5;"    private static int characterSet(String stmt, int offset, int depth) {
        if (stmt.length() > offset + 14) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            char c9 = stmt.charAt(++offset);
            char c10 = stmt.charAt(++offset);
            char c11 = stmt.charAt(++offset);
            char c12 = stmt.charAt(++offset);
            char c13 = stmt.charAt(++offset);
            char c14 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'A' || c2 == 'a') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'A' || c4 == 'a') && (c5 == 'C' || c5 == 'c') && (c6 == 'T' || c6 == 't')
                    && (c7 == 'E' || c7 == 'e') && (c8 == 'R' || c8 == 'r') && (c9 == '_')
                    && (c10 == 'S' || c10 == 's') && (c11 == 'E' || c11 == 'e') && (c12 == 'T' || c12 == 't')
                    && (c13 == '_')) {
                switch (c14) {
                case 'R':
                case 'r':
                    return characterSetResults(stmt, offset);
                case 'C':
                case 'c':
                    return characterSetC(stmt, offset);
                default:
                    return OTHER;
                }
            }
        }
        return OTHER;
    }"
7268;5;7343807;feature envy;major;2019-05-26 08:57:08.770462;function;com.microsoft.tfs.client.common.ui.controls.wit.FileAttachmentsControl#fillMenuBeforeShow IMenuManager;git@github.com:Microsoft/team-explorer-everywhere.git;89ab2a4847aec8ec2afdf36c3f6287dd03bd558d;/source/com.microsoft.tfs.client.common.ui/src/com/microsoft/tfs/client/common/ui/controls/wit/FileAttachmentsControl.java;469;486;https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.client.common.ui/src/com/microsoft/tfs/client/common/ui/controls/wit/FileAttachmentsControl.java/#L469-L486;1;"    @Override
    protected void fillMenuBeforeShow(final IMenuManager manager) {
        manager.add(openAction);
        manager.add(downloadToAction);
        manager.add(addAttachmentAction);
        manager.add(deleteAttachmentAction);

        manager.add(new Separator());

        final DownloadAttachmentOpenType preferredOpenType = DownloadAttachmentOpenType.getPreferredOpenType();
        if (DownloadAttachmentOpenType.BROWSER == preferredOpenType) {
            manager.add(openLocallyAction);
        } else {
            manager.add(openInBrowserAction);
        }

        manager.add(copyUrlToClipboardAction);
    }"
1857;5;8424426;blob;none;2019-03-29 14:27:35.259629;class;org.apache.camel.spi.CamelEvent.ExchangeCreatedEvent;git@github.com:apache/camel.git;8a85a70643c4d6eec2d3abddeea44ecb06c2f486;/core/camel-api/src/main/java/org/apache/camel/spi/CamelEvent.java;167;171;https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/core/camel-api/src/main/java/org/apache/camel/spi/CamelEvent.java/#L167-L171;1;"    interface ExchangeCreatedEvent extends ExchangeEvent {
        default Type getType() {
            return Type.ExchangeCreated;
        }
    }"
10181;13;3969522;blob;major;2019-07-25 16:43:09.013775;class;org.apache.aurora.benchmark.StateManagerBenchmarks.DeleteTasksBenchmark;git@github.com:apache/aurora.git;6ec953f27f7f80366d6bf4c8e7cba0e62a874753;/src/jmh/java/org/apache/aurora/benchmark/StateManagerBenchmarks.java;117;159;https://github.com/apache/aurora/blob/6ec953f27f7f80366d6bf4c8e7cba0e62a874753/src/jmh/java/org/apache/aurora/benchmark/StateManagerBenchmarks.java/#L117-L159;1;"  @BenchmarkMode(Mode.Throughput)
  @OutputTimeUnit(TimeUnit.SECONDS)
  @Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)
  @Measurement(iterations = 10, time = 30, timeUnit = TimeUnit.SECONDS)
  @Fork(1)
  @State(Scope.Thread)
  public static class DeleteTasksBenchmark {
    private StateManager manager;
    private Storage storage;
    private Set<String> taskIds;

    @Param({""1000"", ""10000"", ""50000""})
    private int numTasksToDelete;

    @Setup(Level.Trial)
    public void setUpStorage() {
      Injector injector = getInjector();
      manager = injector.getInstance(StateManager.class);
      storage = injector.getInstance(Storage.class);
      storage.prepare();
    }

    // JMH warns heavily against using `Invocation` but this test seems to meet the requirements
    // of using it. Each benchmark will take more than one ms and it avoids awkward logic to
    // setup storage before the benchmark.
    @Setup(Level.Invocation)
    public void setUp() {
      storage.write(new Storage.MutateWork.NoResult.Quiet() {
        @Override
        public void execute(Storage.MutableStoreProvider storeProvider) throws RuntimeException {
          taskIds = bulkInsertTasks(numTasksToDelete, storeProvider.getUnsafeTaskStore());
        }
      });
    }

    @Benchmark
    public Set<String> run() {
      return storage.write((Storage.MutateWork.Quiet<Set<String>>) storeProvider -> {
        manager.deleteTasks(storeProvider, taskIds);
        return taskIds;
      });
    }
  }"
14665;4;6257015;data class;major;2019-09-12 08:05:33.800734;class;org.eclipse.hawkbit.HawkbitServerProperties.Build;git@github.com:eclipse/hawkbit.git;51be28147f6f575b6c1ab4a5ef84ffd9174f1209;/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java;75;90;https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90;1;"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }"
860;4;6518475;feature envy;none;2019-03-29 13:16:45.278685;function;org.eclipse.vorto.codegen.testutils.ZipDiff.Result#getAdded;git@github.com:eclipse/vorto.git;93919469e598ec07fed134536b901efd25cf674f;/plugin-sdk/plugin-generator/generator-api/src/main/java/org/eclipse/vorto/codegen/testutils/ZipDiff.java;136;138;https://github.com/eclipse/vorto/blob/93919469e598ec07fed134536b901efd25cf674f/plugin-sdk/plugin-generator/generator-api/src/main/java/org/eclipse/vorto/codegen/testutils/ZipDiff.java/#L136-L138;1;"    public Collection<String> getAdded() {
      return added;
    }"
1413;11;7478608;blob;none;2019-03-29 13:50:01.833390;class;example.service.Customer53Service;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer53Service.java;7;11;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer53Service.java/#L7-L11;0;"@Service
public class Customer53Service {
	public Customer53Service(Customer53Repository repo) {
	}
}"
10900;1;4721410;long method;major;2019-07-29 12:19:17.360079;function;org.apache.batchee.container.impl.controller.chunk.ChunkStepController#positionWriterAtCheckpoint;git@github.com:apache/incubator-batchee.git;d4ad6b76d3013a7eb74fbe062aeac305215d6a36;/jbatch/src/main/java/org/apache/batchee/container/impl/controller/chunk/ChunkStepController.java;1015;1042;https://github.com/apache/incubator-batchee/blob/d4ad6b76d3013a7eb74fbe062aeac305215d6a36/jbatch/src/main/java/org/apache/batchee/container/impl/controller/chunk/ChunkStepController.java/#L1015-L1042;1;"    private void positionWriterAtCheckpoint() {
        writerChkptDK = new CheckpointDataKey(jobExecutionImpl.getJobInstance().getInstanceId(), step.getId(), CheckpointType.WRITER);

        CheckpointData writerData = persistenceManagerService.getCheckpointData(writerChkptDK);
        try {
            // check for data in backing store
            if (writerData != null) {
                byte[] writertoken = writerData.getRestartToken();
                TCCLObjectInputStream writerOIS;
                try {
                    writerProxy.open((Serializable) dataRepresentationService.toJavaRepresentation(writertoken));
                } catch (Exception ex) {
                    // is this what I should be throwing here?
                    throw new BatchContainerServiceException(""Cannot read the checkpoint data for ["" + step.getId() + ""]"", ex);
                }
            } else {
                // no chkpt data exists in the backing store
                writerData = null;
                try {
                    writerProxy.open(null);
                } catch (Exception ex) {
                    throw new BatchContainerServiceException(""Cannot open the step ["" + step.getId() + ""]"", ex);
                }
            }
        } catch (ClassCastException e) {
            throw new IllegalStateException(""Expected CheckpointData but found"" + writerData);
        }
    }"
12523;3;4110001;long method;major;2019-08-06 16:48:34.354766;function;org.apache.brooklyn.policy.ha.AbstractFailureDetector#checkHealth;git@github.com:apache/brooklyn-server.git;880eb1da00f6358d7fd76d065322e3685bfb1a04;/policy/src/main/java/org/apache/brooklyn/policy/ha/AbstractFailureDetector.java;223;265;https://github.com/apache/brooklyn-server/blob/880eb1da00f6358d7fd76d065322e3685bfb1a04/policy/src/main/java/org/apache/brooklyn/policy/ha/AbstractFailureDetector.java/#L223-L265;1;"    private synchronized void checkHealth() {
        CalculatedStatus status = calculateStatus();
        boolean healthy = status.isHealthy();
        long now = System.currentTimeMillis();

        if (healthy) {
            stateLastGood.set(now);
            if (lastPublished == LastPublished.FAILED) {
                if (currentRecoveryStartTime == null) {
                    LOG.info(""{} check for {}, now recovering: {}"", new Object[] {this, entity, getDescription(status)});
                    currentRecoveryStartTime = now;
                    schedulePublish();
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, continuing recovering: {}"", new Object[] {this, entity, getDescription(status)});
                }
            } else {
                if (currentFailureStartTime != null) {
                    LOG.info(""{} check for {}, now healthy: {}"", new Object[] {this, entity, getDescription(status)});
                    currentFailureStartTime = null;
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, still healthy: {}"", new Object[] {this, entity, getDescription(status)});
                }
            }
        } else {
            stateLastFail.set(now);
            if (lastPublished != LastPublished.FAILED) {
                if (currentFailureStartTime == null) {
                    LOG.info(""{} check for {}, now failing: {}"", new Object[] {this, entity, getDescription(status)});
                    currentFailureStartTime = now;
                    schedulePublish();
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, continuing failing: {}"", new Object[] {this, entity, getDescription(status)});
                }
            } else {
                if (currentRecoveryStartTime != null) {
                    LOG.info(""{} check for {}, now failing: {}"", new Object[] {this, entity, getDescription(status)});
                    currentRecoveryStartTime = null;
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, still failed: {}"", new Object[] {this, entity, getDescription(status)});
                }
            }
        }
    }"
13490;1;7291517;long method;major;2019-08-29 15:33:44.417761;function;org.grails.ide.eclipse.editor.actions.UrlMappingHyperlinkDetector#findLinkComponentsInClosure ClosureExpression|int;git@github.com:spring-projects/grails-ide.git;cb5162c5a7fc60a2847c39d2750003ada7e80ff7;/org.grails.ide.eclipse.editor.groovy/src/org/grails/ide/eclipse/editor/actions/UrlMappingHyperlinkDetector.java;319;360;https://github.com/spring-projects/grails-ide/blob/cb5162c5a7fc60a2847c39d2750003ada7e80ff7/org.grails.ide.eclipse.editor.groovy/src/org/grails/ide/eclipse/editor/actions/UrlMappingHyperlinkDetector.java/#L319-L360;0,5;"    private NameRegion[] findLinkComponentsInClosure(ClosureExpression firstArg,
            int offset) {
        if (! (firstArg.getCode() instanceof BlockStatement)) {
            return null;
        }
        
        BlockStatement code = (BlockStatement) firstArg.getCode();
        if (code.getStatements() == null) {
            return null;
        }
        NameRegion controllerName = null;
        NameRegion actionName = null;
        NameRegion viewName = null;

        for (Statement state : code.getStatements()) {
            if (state instanceof ExpressionStatement) {
                if (((ExpressionStatement) state).getExpression() instanceof BinaryExpression) {
                    BinaryExpression bexpr = (BinaryExpression) ((ExpressionStatement) state).getExpression();
                    Expression left = bexpr.getLeftExpression();
                    if (bexpr.getOperation().getText().equals(""="") && left instanceof VariableExpression) {
                        Expression right = bexpr.getRightExpression();
                        Region region;
                        if (right.getStart() <= offset && right.getEnd() >= offset) {
                            region = new Region(right.getStart(), right.getLength());
                        } else {
                            region = null;
                        }

                        String name = left.getText();
                        if (name.equals(""controller"")) {
                            controllerName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""action"")) {
                            actionName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""view"")) {
                            viewName = new NameRegion(right.getText(), region);
                        }
                    }
                }
            }
        }
        return new NameRegion[] { controllerName, actionName, viewName };
    }"
984;10;6893083;feature envy;none;2019-03-29 13:24:59.359805;function;com.sun.tools.doclets.internal.toolkit.taglets.BaseTaglet#getTagletOutput Doc|TagletWriter;git@github.com:google/error-prone-javac.git;a53d069bbdb2c60232ed3811c19b65e41c3e60e0;/src/jdk.javadoc/share/classes/com/sun/tools/doclets/internal/toolkit/taglets/BaseTaglet.java;143;145;https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.javadoc/share/classes/com/sun/tools/doclets/internal/toolkit/taglets/BaseTaglet.java/#L143-L145;0;"    public Content getTagletOutput(Doc holder, TagletWriter writer) {
        throw new IllegalArgumentException(""Method not supported in taglet "" + getName() + ""."");
    }"
12462;3;9290971;long method;major;2019-08-06 16:35:06.379790;function;com.sun.org.apache.xml.internal.dtm.ref.DTMNodeProxy#getDocumentElement;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.xml/share/classes/com/sun/org/apache/xml/internal/dtm/ref/DTMNodeProxy.java;619;656;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.xml/share/classes/com/sun/org/apache/xml/internal/dtm/ref/DTMNodeProxy.java/#L619-L656;1;"  @Override
  public final Element getDocumentElement()
  {
                int dochandle=dtm.getDocument();
                int elementhandle=DTM.NULL;
                for(int kidhandle=dtm.getFirstChild(dochandle);
                                kidhandle!=DTM.NULL;
                                kidhandle=dtm.getNextSibling(kidhandle))
                {
                        switch(dtm.getNodeType(kidhandle))
                        {
                        case Node.ELEMENT_NODE:
                                if(elementhandle!=DTM.NULL)
                                {
                                        elementhandle=DTM.NULL; // More than one; ill-formed.
                                        kidhandle=dtm.getLastChild(dochandle); // End loop
                                }
                                else
                                        elementhandle=kidhandle;
                                break;

                        // These are harmless; document is still wellformed
                        case Node.COMMENT_NODE:
                        case Node.PROCESSING_INSTRUCTION_NODE:
                        case Node.DOCUMENT_TYPE_NODE:
                                break;

                        default:
                                elementhandle=DTM.NULL; // ill-formed
                                kidhandle=dtm.getLastChild(dochandle); // End loop
                                break;
                        }
                }
                if(elementhandle==DTM.NULL)
                        throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
                else
                        return (Element)(dtm.getNode(elementhandle));
  }"
1999;3;3924383;feature envy;none;2019-04-01 10:49:03.640864;function;org.apache.accumulo.proxy.thrift.ScanOptions.ScanOptions;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/proxy/src/main/java/org/apache/accumulo/proxy/thrift/ScanOptions.java;141;142;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/proxy/src/main/java/org/apache/accumulo/proxy/thrift/ScanOptions.java/#L141-L142;1;"  public ScanOptions() {
  }"
2307;3;9104666;blob;major;2019-04-01 14:07:03.621699;class;com.oracle.truffle.r.nodes.control.WhileNode;git@github.com:oracle/fastr.git;a1ee49060317621c0c9eceea8ec60040aca59b2d;/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/control/WhileNode.java;42;114;https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/control/WhileNode.java/#L42-L114;1;"public final class WhileNode extends AbstractLoopNode implements RSyntaxNode, RSyntaxCall {

    @Child private LoopNode loop;
    @Child private SetVisibilityNode visibility = SetVisibilityNode.create();

    public WhileNode(SourceSection src, RSyntaxLookup operator, RSyntaxNode condition, RSyntaxNode body) {
        super(src, operator);
        this.loop = Truffle.getRuntime().createLoopNode(new WhileRepeatingNode(this, ConvertBooleanNode.create(condition), body.asRNode()));
    }

    @Override
    public Object execute(VirtualFrame frame) {
        loop.executeLoop(frame);
        visibility.execute(frame, false);
        return RNull.instance;
    }

    private static final class WhileRepeatingNode extends AbstractRepeatingNode {

        @Child private ConvertBooleanNode condition;

        private final ConditionProfile conditionProfile = ConditionProfile.createCountingProfile();
        private final BranchProfile normalBlock = BranchProfile.create();
        private final BranchProfile breakBlock = BranchProfile.create();
        private final BranchProfile nextBlock = BranchProfile.create();

        // only used for toString
        private final WhileNode whileNode;

        WhileRepeatingNode(WhileNode whileNode, ConvertBooleanNode condition, RNode body) {
            super(body);
            this.whileNode = whileNode;
            this.condition = condition;
            // pre-initialize the profile so that loop exits to not deoptimize
            conditionProfile.profile(false);
        }

        @Override
        public boolean executeRepeating(VirtualFrame frame) {
            try {
                if (conditionProfile.profile(condition.executeByte(frame) == RRuntime.LOGICAL_TRUE)) {
                    body.voidExecute(frame);
                    normalBlock.enter();
                    return true;
                } else {
                    return false;
                }
            } catch (BreakException e) {
                breakBlock.enter();
                return false;
            } catch (NextException e) {
                nextBlock.enter();
                return true;
            }
        }

        @Override
        public String toString() {
            return whileNode.toString();
        }
    }

    @Override
    public RSyntaxElement[] getSyntaxArguments() {
        WhileRepeatingNode repeatingNode = (WhileRepeatingNode) loop.getRepeatingNode();
        return new RSyntaxElement[]{repeatingNode.condition.asRSyntaxNode(), repeatingNode.body.asRSyntaxNode()};
    }

    @Override
    public ArgumentsSignature getSyntaxSignature() {
        return ArgumentsSignature.empty(2);
    }
}"
8680;1;6066851;data class;major;2019-07-19 14:26:50.097643;class;org.eclipse.ceylon.common.config.ImprovedConfigReaderListenerAdapter.Whitespace;git@github.com:eclipse/ceylon.git;d3994d6cd120c4df85952cd9432123b413cfd65a;/common/src/org/eclipse/ceylon/common/config/ConfigWriter.java;395;404;https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/common/src/org/eclipse/ceylon/common/config/ConfigWriter.java/#L395-L404;1;"    class Whitespace implements Text {
        private String text;
        public Whitespace(String text) {
            this.text = text;
        }
        @Override
        public String getText() {
            return text;
        }
    }"
4146;23;7393053;blob;none;2019-04-07 09:20:47.038000;class;com.oracle.svm.reflect.target.Target_jdk_internal_reflect_MethodAccessor;git@github.com:oracle/graal.git;4deb681aaaa79c248115037fc8e399c9876619fd;/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/target/Target_jdk_internal_reflect_MethodAccessor.java;30;32;https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/target/Target_jdk_internal_reflect_MethodAccessor.java/#L30-L32;1;"@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = ""MethodAccessor"")
final class Target_jdk_internal_reflect_MethodAccessor {
}"
3071;14;9483594;data class;major;2019-04-05 12:32:33.598261;class;org.apache.hadoop.mapreduce.task.ReduceContextImpl.ValueIterable;git@github.com:apache/hadoop.git;128dd91e10080bdcbcd7d555fa3c4105e55a6b51;/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java;350;356;https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java/#L350-L356;1;"  protected class ValueIterable implements Iterable<VALUEIN> {
    private ValueIterator iterator = new ValueIterator();
    @Override
    public Iterator<VALUEIN> iterator() {
      return iterator;
    } 
  }"
4327;16;8151239;feature envy;major;2019-04-12 12:05:22.385952;function;com.alibaba.cobar.net.NIOReactor.W#write NIOConnection;git@github.com:alibaba/cobar.git;bc36a14d4a3f8acc0db0b3b07a7db8d38afefda5;/server/src/main/net/com/alibaba/cobar/net/NIOReactor.java;166;172;https://github.com/alibaba/cobar/blob/bc36a14d4a3f8acc0db0b3b07a7db8d38afefda5/server/src/main/net/com/alibaba/cobar/net/NIOReactor.java/#L166-L172;0,5;"        private void write(NIOConnection c) {
            try {
                c.writeByQueue();
            } catch (Throwable e) {
                c.error(ErrorCode.ERR_WRITE_BY_QUEUE, e);
            }
        }"
6238;20;7129689;data class;major;2019-04-19 15:29:55.203666;class;com.linkedin.restli.server.UpdateEntityResponse;git@github.com:linkedin/rest.li.git;ad74aa98da8a55ad9c339d0769a3e8fb495765af;/restli-server/src/main/java/com/linkedin/restli/server/UpdateEntityResponse.java;31;50;https://github.com/linkedin/rest.li/blob/ad74aa98da8a55ad9c339d0769a3e8fb495765af/restli-server/src/main/java/com/linkedin/restli/server/UpdateEntityResponse.java/#L31-L50;1;"public class UpdateEntityResponse<V extends RecordTemplate> extends UpdateResponse
{
  private final V _entity;

  public UpdateEntityResponse(final HttpStatus status, final V entity)
  {
    super(status);
    _entity = entity;
  }

  public boolean hasEntity()
  {
    return _entity != null;
  }

  public V getEntity()
  {
    return _entity;
  }
}"
2837;20;5479893;blob;none;2019-04-05 12:14:43.975303;class;org.apache.qpid.server.protocol.v1_0.type.ErrorCarryingFrameBody;git@github.com:apache/qpid-broker-j.git;4c4400b98a5a8493cfb9e5dbb21c97175f433a62;/broker-plugins/amqp-1-0-protocol/src/main/java/org/apache/qpid/server/protocol/v1_0/type/ErrorCarryingFrameBody.java;25;28;https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/amqp-1-0-protocol/src/main/java/org/apache/qpid/server/protocol/v1_0/type/ErrorCarryingFrameBody.java/#L25-L28;1;"public interface ErrorCarryingFrameBody extends FrameBody
{
    Error getError();
}"
744;5;6312967;long method;none;2019-03-29 13:04:04.409959;function;org.eclipse.kura.example.eddystone.scanner.EddystoneScanner#setBluetoothLeService BluetoothLeService;git@github.com:eclipse/kura.git;5e9f3e3d03c8a9cc7857b3fb9080b256821bb32a;/kura/examples/org.eclipse.kura.example.eddystone.scanner/src/main/java/org/eclipse/kura/example/eddystone/scanner/EddystoneScanner.java;51;53;https://github.com/eclipse/kura/blob/5e9f3e3d03c8a9cc7857b3fb9080b256821bb32a/kura/examples/org.eclipse.kura.example.eddystone.scanner/src/main/java/org/eclipse/kura/example/eddystone/scanner/EddystoneScanner.java/#L51-L53;1;"    public void setBluetoothLeService(BluetoothLeService bluetoothLeService) {
        this.bluetoothLeService = bluetoothLeService;
    }"
1038;4;7002598;blob;none;2019-03-29 13:27:49.312732;class;google.registry.flows.domain.DomainCreateFlow.MustHaveSignedMarksInCurrentPhaseException;git@github.com:google/nomulus.git;2481704d00f10f6b5675dd26f9effaad434ddbea;/java/google/registry/flows/domain/DomainCreateFlow.java;608;612;https://github.com/google/nomulus/blob/2481704d00f10f6b5675dd26f9effaad434ddbea/java/google/registry/flows/domain/DomainCreateFlow.java/#L608-L612;1;"  static class MustHaveSignedMarksInCurrentPhaseException extends CommandUseErrorException {
    public MustHaveSignedMarksInCurrentPhaseException() {
      super(""The current registry phase requires a signed mark for registrations"");
    }
  }"
1100;15;7119679;long method;none;2019-03-29 13:30:49.613563;function;com.microsoftopentechnologies.azchat.web.data.beans.BaseBean#setMsg String;git@github.com:Microsoft/azure-chat-for-java.git;4456bea8830c5edf8c211db1d7816b849372d6ed;/azchat-web/src/main/java/com/microsoftopentechnologies/azchat/web/data/beans/BaseBean.java;105;107;https://github.com/Microsoft/azure-chat-for-java/blob/4456bea8830c5edf8c211db1d7816b849372d6ed/azchat-web/src/main/java/com/microsoftopentechnologies/azchat/web/data/beans/BaseBean.java/#L105-L107;0;"	public void setMsg(String msg) {
		this.msg = msg;
	}"
1795;4;8201469;feature envy;none;2019-03-29 14:20:51.749102;function;org.eclipse.xtend.ide.common.contentassist.antlr.internal.InternalXtendLexer.InternalXtendLexer;git@github.com:eclipse/xtext-xtend.git;20500a324127e3ee73cb793a13430ee140246fa7;/org.eclipse.xtend.ide.common/src-gen/org/eclipse/xtend/ide/common/contentassist/antlr/internal/InternalXtendLexer.java;140;140;https://github.com/eclipse/xtext-xtend/blob/20500a324127e3ee73cb793a13430ee140246fa7/org.eclipse.xtend.ide.common/src-gen/org/eclipse/xtend/ide/common/contentassist/antlr/internal/InternalXtendLexer.java/#L140-L140;1;"    public InternalXtendLexer() {;} "
6664;3;8779111;blob;major;2019-05-20 09:03:18.592106;class;org.apache.hadoop.metrics2.impl.MetricsSystemImpl;git@github.com:apache/hadoop-common.git;42a61a4fbc88303913c4681f0d40ffcc737e70b5;/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/impl/MetricsSystemImpl.java;69;601;https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/impl/MetricsSystemImpl.java/#L69-L601;0;"@InterfaceAudience.Private
@Metrics(context=""metricssystem"")
public class MetricsSystemImpl extends MetricsSystem implements MetricsSource {

  static final Log LOG = LogFactory.getLog(MetricsSystemImpl.class);
  static final String MS_NAME = ""MetricsSystem"";
  static final String MS_STATS_NAME = MS_NAME +"",sub=Stats"";
  static final String MS_STATS_DESC = ""Metrics system metrics"";
  static final String MS_CONTROL_NAME = MS_NAME +"",sub=Control"";
  static final String MS_INIT_MODE_KEY = ""hadoop.metrics.init.mode"";

  enum InitMode { NORMAL, STANDBY }

  private final Map<String, MetricsSourceAdapter> sources;
  private final Map<String, MetricsSource> allSources;
  private final Map<String, MetricsSinkAdapter> sinks;
  private final Map<String, MetricsSink> allSinks;
  private final List<Callback> callbacks;
  private final MetricsCollectorImpl collector;
  private final MetricsRegistry registry = new MetricsRegistry(MS_NAME);
  @Metric({""Snapshot"", ""Snapshot stats""}) MutableStat snapshotStat;
  @Metric({""Publish"", ""Publishing stats""}) MutableStat publishStat;
  @Metric(""Dropped updates by all sinks"") MutableCounterLong droppedPubAll;

  private final List<MetricsTag> injectedTags;

  // Things that are changed by init()/start()/stop()
  private String prefix;
  private MetricsFilter sourceFilter;
  private MetricsConfig config;
  private Map<String, MetricsConfig> sourceConfigs, sinkConfigs;
  private boolean monitoring = false;
  private Timer timer;
  private int period; // seconds
  private long logicalTime; // number of timer invocations * period
  private ObjectName mbeanName;
  private boolean publishSelfMetrics = true;
  private MetricsSourceAdapter sysSource;
  private int refCount = 0; // for mini cluster mode

  /**
   * Construct the metrics system
   * @param prefix  for the system
   */
  public MetricsSystemImpl(String prefix) {
    this.prefix = prefix;
    allSources = Maps.newHashMap();
    sources = Maps.newLinkedHashMap();
    allSinks = Maps.newHashMap();
    sinks = Maps.newLinkedHashMap();
    sourceConfigs = Maps.newHashMap();
    sinkConfigs = Maps.newHashMap();
    callbacks = Lists.newArrayList();
    injectedTags = Lists.newArrayList();
    collector = new MetricsCollectorImpl();
    if (prefix != null) {
      // prefix could be null for default ctor, which requires init later
      initSystemMBean();
    }
  }

  /**
   * Construct the system but not initializing (read config etc.) it.
   */
  public MetricsSystemImpl() {
    this(null);
  }

  /**
   * Initialized the metrics system with a prefix.
   * @param prefix  the system will look for configs with the prefix
   * @return the metrics system object itself
   */
  @Override
  public synchronized MetricsSystem init(String prefix) {
    if (monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
      LOG.warn(this.prefix +"" metrics system already initialized!"");
      return this;
    }
    this.prefix = checkNotNull(prefix, ""prefix"");
    ++refCount;
    if (monitoring) {
      // in mini cluster mode
      LOG.info(this.prefix +"" metrics system started (again)"");
      return this;
    }
    switch (initMode()) {
      case NORMAL:
        try { start(); }
        catch (MetricsConfigException e) {
          // Configuration errors (e.g., typos) should not be fatal.
          // We can always start the metrics system later via JMX.
          LOG.warn(""Metrics system not started: ""+ e.getMessage());
          LOG.debug(""Stacktrace: "", e);
        }
        break;
      case STANDBY:
        LOG.info(prefix +"" metrics system started in standby mode"");
    }
    initSystemMBean();
    return this;
  }

  @Override
  public synchronized void start() {
    checkNotNull(prefix, ""prefix"");
    if (monitoring) {
      LOG.warn(prefix +"" metrics system already started!"",
               new MetricsException(""Illegal start""));
      return;
    }
    for (Callback cb : callbacks) cb.preStart();
    configure(prefix);
    startTimer();
    monitoring = true;
    LOG.info(prefix +"" metrics system started"");
    for (Callback cb : callbacks) cb.postStart();
  }

  @Override
  public synchronized void stop() {
    if (!monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
      LOG.warn(prefix +"" metrics system not yet started!"",
               new MetricsException(""Illegal stop""));
      return;
    }
    if (!monitoring) {
      // in mini cluster mode
      LOG.info(prefix +"" metrics system stopped (again)"");
      return;
    }
    for (Callback cb : callbacks) cb.preStop();
    LOG.info(""Stopping ""+ prefix +"" metrics system..."");
    stopTimer();
    stopSources();
    stopSinks();
    clearConfigs();
    monitoring = false;
    LOG.info(prefix +"" metrics system stopped."");
    for (Callback cb : callbacks) cb.postStop();
  }

  @Override public synchronized <T>
  T register(String name, String desc, T source) {
    MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s = sb.build();
    MetricsInfo si = sb.info();
    String name2 = name == null ? si.name() : name;
    final String finalDesc = desc == null ? si.description() : desc;
    final String finalName = // be friendly to non-metrics tests
        DefaultMetricsSystem.sourceName(name2, !monitoring);
    allSources.put(finalName, s);
    LOG.debug(finalName +"", ""+ finalDesc);
    if (monitoring) {
      registerSource(finalName, finalDesc, s);
    }
    // We want to re-register the source to pick up new config when the
    // metrics system restarts.
    register(new AbstractCallback() {
      @Override public void postStart() {
        registerSource(finalName, finalDesc, s);
      }
    });
    return source;
  }

  @Override public synchronized
  void unregisterSource(String name) {
    if (sources.containsKey(name)) {
      sources.get(name).stop();
      sources.remove(name);
    }
    if (allSources.containsKey(name)) {
      allSources.remove(name);
    }
  }

  synchronized
  void registerSource(String name, String desc, MetricsSource source) {
    checkNotNull(config, ""config"");
    MetricsConfig conf = sourceConfigs.get(name);
    MetricsSourceAdapter sa = new MetricsSourceAdapter(prefix, name, desc,
        source, injectedTags, period, conf != null ? conf
            : config.subset(SOURCE_KEY));
    sources.put(name, sa);
    sa.start();
    LOG.debug(""Registered source ""+ name);
  }

  @Override public synchronized <T extends MetricsSink>
  T register(final String name, final String description, final T sink) {
    LOG.debug(name +"", ""+ description);
    if (allSinks.containsKey(name)) {
      LOG.warn(""Sink ""+ name +"" already exists!"");
      return sink;
    }
    allSinks.put(name, sink);
    if (config != null) {
      registerSink(name, description, sink);
    }
    // We want to re-register the sink to pick up new config
    // when the metrics system restarts.
    register(new AbstractCallback() {
      @Override public void postStart() {
        register(name, description, sink);
      }
    });
    return sink;
  }

  synchronized void registerSink(String name, String desc, MetricsSink sink) {
    checkNotNull(config, ""config"");
    MetricsConfig conf = sinkConfigs.get(name);
    MetricsSinkAdapter sa = conf != null
        ? newSink(name, desc, sink, conf)
        : newSink(name, desc, sink, config.subset(SINK_KEY));
    sinks.put(name, sa);
    sa.start();
    LOG.info(""Registered sink ""+ name);
  }

  @Override
  public synchronized void register(final Callback callback) {
    callbacks.add((Callback) Proxy.newProxyInstance(
        callback.getClass().getClassLoader(), new Class<?>[] { Callback.class },
        new InvocationHandler() {
          @Override
          public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable {
            try {
              return method.invoke(callback, args);
            } catch (Exception e) {
              // These are not considered fatal.
              LOG.warn(""Caught exception in callback ""+ method.getName(), e);
            }
            return null;
          }
        }));
  }

  @Override
  public synchronized void startMetricsMBeans() {
    for (MetricsSourceAdapter sa : sources.values()) {
      sa.startMBeans();
    }
  }

  @Override
  public synchronized void stopMetricsMBeans() {
    for (MetricsSourceAdapter sa : sources.values()) {
      sa.stopMBeans();
    }
  }

  @Override
  public synchronized String currentConfig() {
    PropertiesConfiguration saver = new PropertiesConfiguration();
    StringWriter writer = new StringWriter();
    saver.copy(config);
    try { saver.save(writer); }
    catch (Exception e) {
      throw new MetricsConfigException(""Error stringify config"", e);
    }
    return writer.toString();
  }

  private synchronized void startTimer() {
    if (timer != null) {
      LOG.warn(prefix +"" metrics system timer already started!"");
      return;
    }
    logicalTime = 0;
    long millis = period * 1000;
    timer = new Timer(""Timer for '""+ prefix +""' metrics system"", true);
    timer.scheduleAtFixedRate(new TimerTask() {
          @Override
          public void run() {
            try {
              onTimerEvent();
            } catch (Exception e) {
              LOG.warn(e);
            }
          }
        }, millis, millis);
    LOG.info(""Scheduled snapshot period at ""+ period +"" second(s)."");
  }

  synchronized void onTimerEvent() {
    logicalTime += period;
    if (sinks.size() > 0) {
      publishMetrics(sampleMetrics(), false);
    }
  }
  
  /**
   * Requests an immediate publish of all metrics from sources to sinks.
   */
  @Override
  public void publishMetricsNow() {
    if (sinks.size() > 0) {
      publishMetrics(sampleMetrics(), true);
    }    
  }

  /**
   * Sample all the sources for a snapshot of metrics/tags
   * @return  the metrics buffer containing the snapshot
   */
  synchronized MetricsBuffer sampleMetrics() {
    collector.clear();
    MetricsBufferBuilder bufferBuilder = new MetricsBufferBuilder();

    for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
      if (sourceFilter == null || sourceFilter.accepts(entry.getKey())) {
        snapshotMetrics(entry.getValue(), bufferBuilder);
      }
    }
    if (publishSelfMetrics) {
      snapshotMetrics(sysSource, bufferBuilder);
    }
    MetricsBuffer buffer = bufferBuilder.get();
    return buffer;
  }

  private void snapshotMetrics(MetricsSourceAdapter sa,
                               MetricsBufferBuilder bufferBuilder) {
    long startTime = Time.now();
    bufferBuilder.add(sa.name(), sa.getMetrics(collector, true));
    collector.clear();
    snapshotStat.add(Time.now() - startTime);
    LOG.debug(""Snapshotted source ""+ sa.name());
  }

  /**
   * Publish a metrics snapshot to all the sinks
   * @param buffer  the metrics snapshot to publish
   * @param immediate  indicates that we should publish metrics immediately
   *                   instead of using a separate thread.
   */
  synchronized void publishMetrics(MetricsBuffer buffer, boolean immediate) {
    int dropped = 0;
    for (MetricsSinkAdapter sa : sinks.values()) {
      long startTime = Time.now();
      boolean result;
      if (immediate) {
        result = sa.putMetricsImmediate(buffer); 
      } else {
        result = sa.putMetrics(buffer, logicalTime);
      }
      dropped += result ? 0 : 1;
      publishStat.add(Time.now() - startTime);
    }
    droppedPubAll.incr(dropped);
  }

  private synchronized void stopTimer() {
    if (timer == null) {
      LOG.warn(prefix +"" metrics system timer already stopped!"");
      return;
    }
    timer.cancel();
    timer = null;
  }

  private synchronized void stopSources() {
    for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
      MetricsSourceAdapter sa = entry.getValue();
      LOG.debug(""Stopping metrics source ""+ entry.getKey() +
          "": class="" + sa.source().getClass());
      sa.stop();
    }
    sysSource.stop();
    sources.clear();
  }

  private synchronized void stopSinks() {
    for (Entry<String, MetricsSinkAdapter> entry : sinks.entrySet()) {
      MetricsSinkAdapter sa = entry.getValue();
      LOG.debug(""Stopping metrics sink ""+ entry.getKey() +
          "": class="" + sa.sink().getClass());
      sa.stop();
    }
    sinks.clear();
  }

  private synchronized void configure(String prefix) {
    config = MetricsConfig.create(prefix);
    configureSinks();
    configureSources();
    configureSystem();
  }

  private synchronized void configureSystem() {
    injectedTags.add(Interns.tag(MsInfo.Hostname, getHostname()));
  }

  private synchronized void configureSinks() {
    sinkConfigs = config.getInstanceConfigs(SINK_KEY);
    int confPeriod = 0;
    for (Entry<String, MetricsConfig> entry : sinkConfigs.entrySet()) {
      MetricsConfig conf = entry.getValue();
      int sinkPeriod = conf.getInt(PERIOD_KEY, PERIOD_DEFAULT);
      confPeriod = confPeriod == 0 ? sinkPeriod
                                   : ArithmeticUtils.gcd(confPeriod, sinkPeriod);
      String clsName = conf.getClassName("""");
      if (clsName == null) continue;  // sink can be registered later on
      String sinkName = entry.getKey();
      try {
        MetricsSinkAdapter sa = newSink(sinkName,
            conf.getString(DESC_KEY, sinkName), conf);
        sa.start();
        sinks.put(sinkName, sa);
      } catch (Exception e) {
        LOG.warn(""Error creating sink '""+ sinkName +""'"", e);
      }
    }
    period = confPeriod > 0 ? confPeriod
                            : config.getInt(PERIOD_KEY, PERIOD_DEFAULT);
  }

  static MetricsSinkAdapter newSink(String name, String desc, MetricsSink sink,
                                    MetricsConfig conf) {
    return new MetricsSinkAdapter(name, desc, sink, conf.getString(CONTEXT_KEY),
        conf.getFilter(SOURCE_FILTER_KEY),
        conf.getFilter(RECORD_FILTER_KEY),
        conf.getFilter(METRIC_FILTER_KEY),
        conf.getInt(PERIOD_KEY, PERIOD_DEFAULT),
        conf.getInt(QUEUE_CAPACITY_KEY, QUEUE_CAPACITY_DEFAULT),
        conf.getInt(RETRY_DELAY_KEY, RETRY_DELAY_DEFAULT),
        conf.getFloat(RETRY_BACKOFF_KEY, RETRY_BACKOFF_DEFAULT),
        conf.getInt(RETRY_COUNT_KEY, RETRY_COUNT_DEFAULT));
  }

  static MetricsSinkAdapter newSink(String name, String desc,
                                    MetricsConfig conf) {
    return newSink(name, desc, (MetricsSink) conf.getPlugin(""""), conf);
  }

  private void configureSources() {
    sourceFilter = config.getFilter(PREFIX_DEFAULT + SOURCE_FILTER_KEY);
    sourceConfigs = config.getInstanceConfigs(SOURCE_KEY);
    registerSystemSource();
  }

  private void clearConfigs() {
    sinkConfigs.clear();
    sourceConfigs.clear();
    injectedTags.clear();
    config = null;
  }

  static String getHostname() {
    try {
      return InetAddress.getLocalHost().getHostName();
    } catch (Exception e) {
      LOG.error(""Error getting localhost name. Using 'localhost'..."", e);
    }
    return ""localhost"";
  }

  private void registerSystemSource() {
    MetricsConfig sysConf = sourceConfigs.get(MS_NAME);
    sysSource = new MetricsSourceAdapter(prefix, MS_STATS_NAME, MS_STATS_DESC,
        MetricsAnnotations.makeSource(this), injectedTags, period,
        sysConf == null ? config.subset(SOURCE_KEY) : sysConf);
    sysSource.start();
  }

  @Override
  public synchronized void getMetrics(MetricsCollector builder, boolean all) {
    MetricsRecordBuilder rb = builder.addRecord(MS_NAME)
        .addGauge(MsInfo.NumActiveSources, sources.size())
        .addGauge(MsInfo.NumAllSources, allSources.size())
        .addGauge(MsInfo.NumActiveSinks, sinks.size())
        .addGauge(MsInfo.NumAllSinks, allSinks.size());

    for (MetricsSinkAdapter sa : sinks.values()) {
      sa.snapshot(rb, all);
    }
    registry.snapshot(rb, all);
  }

  private void initSystemMBean() {
    checkNotNull(prefix, ""prefix should not be null here!"");
    if (mbeanName == null) {
      mbeanName = MBeans.register(prefix, MS_CONTROL_NAME, this);
    }
  }

  @Override
  public synchronized boolean shutdown() {
    LOG.debug(""refCount=""+ refCount);
    if (refCount <= 0) {
      LOG.debug(""Redundant shutdown"", new Throwable());
      return true; // already shutdown
    }
    if (--refCount > 0) return false;
    if (monitoring) {
      try { stop(); }
      catch (Exception e) {
        LOG.warn(""Error stopping the metrics system"", e);
      }
    }
    allSources.clear();
    allSinks.clear();
    callbacks.clear();
    if (mbeanName != null) {
      MBeans.unregister(mbeanName);
      mbeanName = null;
    }
    LOG.info(prefix +"" metrics system shutdown complete."");
    return true;
  }

  @Override
  public MetricsSource getSource(String name) {
    return allSources.get(name);
  }

  @VisibleForTesting
  MetricsSourceAdapter getSourceAdapter(String name) {
    return sources.get(name);
  }

  private InitMode initMode() {
    LOG.debug(""from system property: ""+ System.getProperty(MS_INIT_MODE_KEY));
    LOG.debug(""from environment variable: ""+ System.getenv(MS_INIT_MODE_KEY));
    String m = System.getProperty(MS_INIT_MODE_KEY);
    String m2 = m == null ? System.getenv(MS_INIT_MODE_KEY) : m;
    return InitMode.valueOf((m2 == null ? InitMode.NORMAL.name() : m2)
                            .toUpperCase(Locale.US));
  }
}"
634;6;6009975;blob;none;2019-03-27 10:57:29.046193;class;org.cloudfoundry.dependency.resource.pivotalnetwork.PivotalNetworkInParams;git@github.com:cloudfoundry/java-buildpack-dependency-builder.git;d15085bcf74312af19ad40bee847e43c3b4e32ee;/resources/pivotal-network-resource/src/main/java/org/cloudfoundry/dependency/resource/pivotalnetwork/PivotalNetworkInParams.java;19;21;https://github.com/cloudfoundry/java-buildpack-dependency-builder/blob/d15085bcf74312af19ad40bee847e43c3b4e32ee/resources/pivotal-network-resource/src/main/java/org/cloudfoundry/dependency/resource/pivotalnetwork/PivotalNetworkInParams.java/#L19-L21;0;"final class PivotalNetworkInParams {

}"
8258;3;7378490;feature envy;major;2019-07-18 15:37:02.478999;function;org.springframework.boot.web.embedded.jetty.JettyReactiveWebServerFactory#createJettyServer JettyHttpHandlerAdapter;git@github.com:spring-projects/spring-boot.git;2225b362991f225e3a93f00e160526d2b8abdfb2;/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/embedded/jetty/JettyReactiveWebServerFactory.java;171;194;https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/embedded/jetty/JettyReactiveWebServerFactory.java/#L171-L194;1;"	protected Server createJettyServer(JettyHttpHandlerAdapter servlet) {
		int port = (getPort() >= 0) ? getPort() : 0;
		InetSocketAddress address = new InetSocketAddress(getAddress(), port);
		Server server = new Server(getThreadPool());
		server.addConnector(createConnector(address, server));
		ServletHolder servletHolder = new ServletHolder(servlet);
		servletHolder.setAsyncSupported(true);
		ServletContextHandler contextHandler = new ServletContextHandler(server, """",
				false, false);
		contextHandler.addServlet(servletHolder, ""/"");
		server.setHandler(addHandlerWrappers(contextHandler));
		JettyReactiveWebServerFactory.logger
				.info(""Server initialized with port: "" + port);
		if (getSsl() != null && getSsl().isEnabled()) {
			customizeSsl(server, address);
		}
		for (JettyServerCustomizer customizer : getServerCustomizers()) {
			customizer.customize(server);
		}
		if (this.useForwardHeaders) {
			new ForwardHeadersCustomizer().customize(server);
		}
		return server;
	}"
12006;3;5882175;blob;major;2019-08-05 23:24:27.851944;class;org.apache.usergrid.rest.management.organizations.applications.ApplicationResource;git@github.com:apache/usergrid.git;ac1e6e4035f9307b871478ed47246cf92cfd5f7f;/stack/rest/src/main/java/org/apache/usergrid/rest/management/organizations/applications/ApplicationResource.java;63;563;https://github.com/apache/usergrid/blob/ac1e6e4035f9307b871478ed47246cf92cfd5f7f/stack/rest/src/main/java/org/apache/usergrid/rest/management/organizations/applications/ApplicationResource.java/#L63-L563;1;"@Component(""org.apache.usergrid.rest.management.organizations.applications.ApplicationResource"")
@Scope(""prototype"")
@Produces({
    MediaType.APPLICATION_JSON,
    ""application/javascript"",
    ""application/x-javascript"",
    ""text/ecmascript"",
    ""application/ecmascript"",
    ""text/jscript""
})
public class ApplicationResource extends AbstractContextResource {

    private static final Logger logger = LoggerFactory.getLogger(ApplicationResource.class);

    public static final String CONFIRM_APPLICATION_IDENTIFIER = ""confirm_application_identifier"";
    public static final String RESTORE_PASSWORD = ""restore_password"";

    //@Autowired
    //protected ExportService exportService;

    OrganizationInfo organization;
    UUID applicationId;
    ApplicationInfo application;

    @Autowired
    private SignInProviderFactory signInProviderFactory;


    public ApplicationResource() {
    }


    public ApplicationResource init( OrganizationInfo organization, UUID applicationId ) {
        this.organization = organization;
        this.applicationId = applicationId;
        return this;
    }


    public ApplicationResource init( OrganizationInfo organization, ApplicationInfo application ) {
        this.organization = organization;
        applicationId = application.getId();
        this.application = application;
        return this;
    }



    @RequireOrganizationAccess
    @GET
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse getApplication(
            @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        ServiceManager sm = smf.getServiceManager( applicationId );
        response.setAction( ""get"" );
        response.setApplication( sm.getApplication() );
        response.setParams( ui.getQueryParameters() );
        response.setResults( management.getApplicationMetadata( applicationId ) );
        return response;
    }


    @RequireOrganizationAccess
    @GET
    @Path(""credentials"")
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse getCredentials(
            @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction(""get application client credentials"");

        ClientCredentialsInfo credentials =
                new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ),
                        management.getClientSecretForApplication( applicationId ) );

        response.setCredentials( credentials );
        return response;
    }


    @RequireOrganizationAccess
    @POST
    @Path(""credentials"")
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse generateCredentials( @Context UriInfo ui,
            @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""generate application client credentials"" );

        ClientCredentialsInfo credentials =
                new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ),
                        management.newClientSecretForApplication(applicationId) );

        response.setCredentials( credentials );
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""_size"")
    public ApiResponse getApplicationSize(
        @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""get application size for all entities"" );
        long size = management.getApplicationSize(this.applicationId);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> innerMap = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        innerMap.put(""application"",size);
        sumMap.put(""size"",innerMap);
        map.put(""aggregation"", sumMap);
        response.setMetadata(map);
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""{collection_name}/_size"")
    public ApiResponse getCollectionSize(
        @Context UriInfo ui,
        @PathParam( ""collection_name"" ) String collection_name,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {
        ApiResponse response = createApiResponse();
        response.setAction(""get collection size for all entities"");
        long size = management.getCollectionSize(this.applicationId, collection_name);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        Map<String,Object> innerMap = new HashMap<>();
        innerMap.put(collection_name,size);
        sumMap.put(""size"",innerMap);
        map.put(""aggregation"",sumMap);
        response.setMetadata(map);
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""collections/_size"")
    public ApiResponse getEachCollectionSize(
        @Context UriInfo ui,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {
        ApiResponse response = createApiResponse();
        response.setAction(""get collection size for all entities"");
        Map<String,Long> sizes = management.getEachCollectionSize(this.applicationId);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        sumMap.put(""size"",sizes);
        map.put(""aggregation"",sumMap);
        response.setMetadata(map);
        return response;
    }

    @POST
    @Path(""sia-provider"")
    @Consumes(APPLICATION_JSON)
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse configureProvider(
            @Context UriInfo ui,
            @QueryParam(""provider_key"") String siaProvider,
            Map<String, Object> json,
            @QueryParam(""callback"")
            @DefaultValue("""") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""post signin provider configuration"" );

        Preconditions.checkArgument( siaProvider != null, ""Sign in provider required"" );

        SignInAsProvider signInAsProvider = null;
        if ( StringUtils.equalsIgnoreCase( siaProvider, ""facebook"" ) ) {
            signInAsProvider = signInProviderFactory.facebook(
                    smf.getServiceManager( applicationId ).getApplication() );
        }
        else if ( StringUtils.equalsIgnoreCase( siaProvider, ""pingident"" ) ) {
            signInAsProvider = signInProviderFactory.pingident(
                    smf.getServiceManager( applicationId ).getApplication() );
        }
        else if ( StringUtils.equalsIgnoreCase( siaProvider, ""foursquare"" ) ) {
            signInAsProvider = signInProviderFactory.foursquare(
                    smf.getServiceManager( applicationId ).getApplication() );
        }

        Preconditions.checkArgument( signInAsProvider != null,
                ""No signin provider found by that name: "" + siaProvider );

        signInAsProvider.saveToConfiguration( json );

        return response;
    }

//    @POST
//    @Path(""export"")
//    @Consumes(APPLICATION_JSON)
//    @RequireOrganizationAccess
//    public Response exportPostJson( @Context UriInfo ui,Map<String, Object> json,
//                                    @QueryParam(""callback"") @DefaultValue("""") String callback )
//            throws OAuthSystemException {
//
//        UsergridAwsCredentials uac = new UsergridAwsCredentials();
//
//        UUID jobUUID = null;
//        Map<String, String> uuidRet = new HashMap<String, String>();
//
//        Map<String,Object> properties;
//        Map<String, Object> storage_info;
//
//        try {
//            if((properties = ( Map<String, Object> )  json.get( ""properties"" )) == null){
//                throw new NullArgumentException(""Could not find 'properties'"");
//            }
//            storage_info = ( Map<String, Object> ) properties.get( ""storage_info"" );
//            String storage_provider = ( String ) properties.get( ""storage_provider"" );
//            if(storage_provider == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_provider'"" );
//            }
//            if(storage_info == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_info'"" );
//            }
//
//
//            String bucketName = ( String ) storage_info.get( ""bucket_location"" );
//            String accessId = ( String ) storage_info.get( ""s3_access_id"" );
//            String secretKey = ( String ) storage_info.get( ""s3_key"" );
//
//            if ( bucketName == null ) {
//                throw new NullArgumentException( ""Could not find field 'bucketName'"" );
//            }
//            if ( accessId == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_access_id'"" );
//            }
//            if ( secretKey == null ) {
//
//                throw new NullArgumentException( ""Could not find field 's3_key'"" );
//            }
//
//            json.put(""organizationId"", organization.getUuid());
//            json.put( ""applicationId"",applicationId);
//
//            jobUUID = exportService.schedule( json );
//            uuidRet.put( ""Export Entity"", jobUUID.toString() );
//        }
//        catch ( NullArgumentException e ) {
//            return Response.status( SC_BAD_REQUEST )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) ).build();
//        }
//        catch ( Exception e ) {
//            // TODO: throw descriptive error message and or include on in the response
//            // TODO: fix below, it doesn't work if there is an exception.
//            // Make it look like the OauthResponse.
//            return Response.status( SC_INTERNAL_SERVER_ERROR )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) ).build();
//        }
//
//        return Response.status( SC_ACCEPTED ).entity( uuidRet ).build();
//    }
//
//    @POST
//    @Path(""collection/{collection_name}/export"")
//    @Consumes(APPLICATION_JSON)
//    @RequireOrganizationAccess
//    public Response exportPostJson( @Context UriInfo ui,
//            @PathParam( ""collection_name"" ) String collection_name ,Map<String, Object> json,
//            @QueryParam(""callback"") @DefaultValue("""") String callback )
//            throws OAuthSystemException {
//
//        UsergridAwsCredentials uac = new UsergridAwsCredentials();
//        UUID jobUUID = null;
//        String colExport = collection_name;
//        Map<String, String> uuidRet = new HashMap<String, String>();
//
//        Map<String,Object> properties;
//        Map<String, Object> storage_info;
//
//        try {
//            //checkJsonExportProperties(json);
//            if((properties = ( Map<String, Object> )  json.get( ""properties"" )) == null){
//                throw new NullArgumentException(""Could not find 'properties'"");
//            }
//            storage_info = ( Map<String, Object> ) properties.get( ""storage_info"" );
//            String storage_provider = ( String ) properties.get( ""storage_provider"" );
//            if(storage_provider == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_provider'"" );
//            }
//            if(storage_info == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_info'"" );
//            }
//
//            String bucketName = ( String ) storage_info.get( ""bucket_location"" );
//            String accessId = ( String ) storage_info.get( ""s3_access_id"" );
//            String secretKey = ( String ) storage_info.get( ""s3_key"" );
//
//            if ( accessId == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_access_id'"" );
//            }
//            if ( secretKey == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_key'"" );
//            }
//
//            if(bucketName == null) {
//                throw new NullArgumentException( ""Could not find field 'bucketName'"" );
//            }
//
//            json.put( ""organizationId"",organization.getUuid() );
//            json.put( ""applicationId"", applicationId);
//            json.put( ""collectionName"", colExport);
//
//            jobUUID = exportService.schedule( json );
//            uuidRet.put( ""Export Entity"", jobUUID.toString() );
//        }
//        catch ( NullArgumentException e ) {
//            return Response.status( SC_BAD_REQUEST )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) )
//                .build();
//        }
//        catch ( Exception e ) {
//
//            // TODO: throw descriptive error message and or include on in the response
//            // TODO: fix below, it doesn't work if there is an exception.
//            // Make it look like the OauthResponse.
//
//            OAuthResponse errorMsg = OAuthResponse.errorResponse( SC_INTERNAL_SERVER_ERROR )
//                .setErrorDescription( e.getMessage() )
//                .buildJSONMessage();
//
//            return Response.status( errorMsg.getResponseStatus() )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( errorMsg.getBody(), callback ) )
//                .build();
//        }
//
//        return Response.status( SC_ACCEPTED ).entity( uuidRet ).build();
//    }
//
//
//    @Path( ""imports"" )
//    public ImportsResource importGetJson( @Context UriInfo ui,
//                                          @QueryParam( ""callback"" ) @DefaultValue( """" ) String callback )
//        throws Exception {
//
//
//        return getSubResource( ImportsResource.class ).init( organization, application );
//    }

    @GET
    @Path(""/status"")
    public Response getStatus() {

        Map<String, Object> statusMap = new HashMap<String, Object>();

        EntityManager em = emf.getEntityManager( applicationId );
        if ( !emf.getIndexHealth().equals( Health.RED ) ) {
            statusMap.put(""message"", ""Index Health Status RED for application "" + applicationId );
            return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
        }

        try {
            if ( em.getApplication() == null ) {
                statusMap.put(""message"", ""Application "" + applicationId + "" not found"");
                return Response.status( SC_NOT_FOUND ).entity( statusMap ).build();
            }

        } catch (Exception ex) {
            statusMap.put(""message"", ""Error looking up application "" + applicationId );
            return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
        }

        return Response.status( SC_OK ).entity( null ).build();
    }



    /**
     * Put on application URL will restore application if it was deleted.
     */
    @PUT
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse executePut(  @Context UriInfo ui, String body,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback ) throws Exception {

        if ( applicationId == null ) {
            throw new IllegalArgumentException(""Application ID not specified in request"");
        }

        ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
        if (!SubjectUtils.isServiceAdmin()) {
            // require password if it exists
            String storedRestorePassword = restorePasswordService.getApplicationRestorePassword(applicationId);
            if (StringUtils.isNotEmpty(storedRestorePassword)) {
                // must have matching password as query parameter
                String suppliedRestorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
                if (!storedRestorePassword.equals(suppliedRestorePassword)) {
                    throw new IllegalArgumentException(""Application cannot be restored without application password"");
                }
            }
        }

        management.restoreApplication( applicationId );

        // not deleting password -- will be changed upon successful soft delete

        ApiResponse response = createApiResponse();
        response.setAction( ""restore"" );
        response.setApplication( emf.getEntityManager( applicationId ).getApplication() );
        response.setParams( ui.getQueryParameters() );

        return response;
    }


    /**
     * Caller MUST pass confirm_application_identifier that is either the UUID or the
     * name of the application to be deleted. Yes, this is redundant and intended to
     * be a protection measure to force caller to confirm that they want to do a delete.
     */
    @DELETE
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse executeDelete(  @Context UriInfo ui,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback,
        @QueryParam(CONFIRM_APPLICATION_IDENTIFIER) String confirmApplicationIdentifier) throws Exception {

        if ( application == null && applicationId == null ) {
            throw new IllegalArgumentException(""Application ID not specified in request"");
        }

        // If the path uses name then expect name, otherwise if they use uuid then expect uuid.
        if (application == null) {
            if (!applicationId.toString().equals( confirmApplicationIdentifier )) {
                throw new IllegalArgumentException(
                    ""Cannot delete application without supplying correct application id."");
            }

        } else if (!application.getName().split( ""/"" )[1].equals( confirmApplicationIdentifier ) ) {
            throw new IllegalArgumentException(
                ""Cannot delete application without supplying correct application name"");
        }

        String restorePassword = null;
        ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
        if (SubjectUtils.isServiceAdmin()) {
            restorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
            if (StringUtils.isNotEmpty(restorePassword)) {
                // save password, required for future undelete if not sysadmin
                restorePasswordService.setApplicationRestorePassword(applicationId, restorePassword);
            }
        }

        management.deleteApplication( applicationId );

        if (restorePassword == null) {
            // clear restore password
            restorePasswordService.removeApplicationRestorePassword(applicationId);
        }

        if (logger.isTraceEnabled()) {
            logger.trace(""ApplicationResource.delete() deleted appId = {}"", applicationId);
        }

        ApiResponse response = createApiResponse();
        response.setAction( ""delete"" );
        response.setApplication(emf.getEntityManager( applicationId ).getApplication());
        response.setParams(ui.getQueryParameters());

        if (logger.isTraceEnabled()) {
            logger.trace(""ApplicationResource.delete() sending response "");
        }

        return response;
    }

    private ApplicationRestorePasswordService getApplicationRestorePasswordService() {
        return injector.getInstance(ApplicationRestorePasswordService.class);
    }

}"
11712;3;8029682;long method;major;2019-08-05 15:52:03.775461;function;org.eclipse.xtext.xtext.ecoreInference.Xtext2EcoreTransformer#deriveTypeHierarchyFromOverridden ParserRule|Grammar;git@github.com:eclipse/xtext-core.git;e04964e4c2a3e0338c0079bd8333688835e77c31;/org.eclipse.xtext/src/org/eclipse/xtext/xtext/ecoreInference/Xtext2EcoreTransformer.java;720;764;https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext/src/org/eclipse/xtext/xtext/ecoreInference/Xtext2EcoreTransformer.java/#L720-L764;1;"	private boolean deriveTypeHierarchyFromOverridden(ParserRule rule, Grammar grammar) throws TransformationException {
		AbstractRule parentRule = GrammarUtil.findRuleForName(grammar, rule.getName());
		if (parentRule != null) {
			if (parentRule != rule && parentRule instanceof ParserRule) {
				ParserRule casted = (ParserRule) parentRule;
				if (casted.isFragment() != rule.isFragment()) {
					if (rule.isFragment()) {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""A fragment rule cannot override a production rule."", rule);
					} else {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""Only fragment rule can override other fragment rules."", rule);
					}
				}
				if (casted.isWildcard() != rule.isWildcard()) {
					if (rule.isWildcard()) {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""A wildcard fragment rule cannot override a typed fragment rule."", rule);
					} else {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""Only wildcard fragment rules can override other wildcard fragments."", rule);
					}
				}
				if (rule.isFragment() && !rule.isWildcard() && parentRule.getType() != null) {
					if (rule.getType().getClassifier() != parentRule.getType().getClassifier()) {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""Overriding fragment rules cannot redeclare their type."", rule.getType());
					}
				}
				checkParameterLists(rule, casted);
			}
			if (parentRule.getType() != null && parentRule != rule) {			
				if (parentRule.getType().getClassifier() instanceof EDataType)
					throw new TransformationException(TransformationErrorCode.InvalidSupertype,
							""Cannot inherit from datatype rule and return another type."", rule.getType());
				EClassifierInfo parentTypeInfo = eClassifierInfos.getInfoOrNull(parentRule.getType());
				if (parentTypeInfo == null)
					throw new TransformationException(TransformationErrorCode.InvalidSupertype,
							""Cannot determine return type of overridden rule."", rule.getType());
				addSuperType(rule, rule.getType(), parentTypeInfo);
				return true;
			}
		}
		return false;
	}"
6541;5;4923223;data class;major;2019-05-10 13:16:57.308954;class;org.apache.joshua.util.quantization.BooleanQuantizer;git@github.com:apache/joshua.git;e9cb9ebb495782f4ed238e08e64f5503085641fc;/src/main/java/org/apache/joshua/util/quantization/BooleanQuantizer.java;29;45;https://github.com/apache/joshua/blob/e9cb9ebb495782f4ed238e08e64f5503085641fc/src/main/java/org/apache/joshua/util/quantization/BooleanQuantizer.java/#L29-L45;0,5;"public class BooleanQuantizer extends StatelessQuantizer { 

  public final float read(ByteBuffer stream, int position) { 
    return 1.0f; 
  } 

  public final void write(ByteBuffer stream, float value) {} 

  @Override 
  public String getKey() { 
    return ""boolean""; 
  } 

  public final int size() { 
    return 0; 
  } 
}"
1989;3;3922769;blob;none;2019-04-01 10:45:30.219037;class;org.apache.accumulo.server.master.recovery.LogCloser;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/server/base/src/main/java/org/apache/accumulo/server/master/recovery/LogCloser.java;26;29;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/server/base/src/main/java/org/apache/accumulo/server/master/recovery/LogCloser.java/#L26-L29;1;"public interface LogCloser {
  long close(AccumuloConfiguration conf, Configuration hadoopConf, VolumeManager fs, Path path)
      throws IOException;
}"
1427;5;7482898;data class;none;2019-03-29 13:50:17.236802;class;example.service.Customer261Service;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer261Service.java;7;11;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer261Service.java/#L7-L11;0;"@Service
public class Customer261Service {
	public Customer261Service(Customer261Repository repo) {
	}
}"
10801;4;6999436;blob;major;2019-07-26 20:28:32.033200;class;org.physical_web.physicalweb.MainActivity;git@github.com:google/physical-web.git;12604319e99b6d6dff451fc5a58a13a271f1dc7a;/android/PhysicalWeb/app/src/main/java/org/physical_web/physicalweb/MainActivity.java;39;228;https://github.com/google/physical-web/blob/12604319e99b6d6dff451fc5a58a13a271f1dc7a/android/PhysicalWeb/app/src/main/java/org/physical_web/physicalweb/MainActivity.java/#L39-L228;0;"public class MainActivity extends Activity {
  private static final String TAG  = MainActivity.class.getSimpleName();
  private static final int REQUEST_ENABLE_BT = 0;
  private static final int REQUEST_LOCATION = 1;
  private static final String NEARBY_BEACONS_FRAGMENT_TAG = ""NearbyBeaconsFragmentTag"";
  private static final String SETTINGS_FRAGMENT_TAG = ""SettingsFragmentTag"";
  private static final String BLOCKED_URLS_FRAGMENT_TAG = ""BlockedUrlsFragmentTag"";
  private static final String ABOUT_FRAGMENT_TAG = ""AboutFragmentTag"";
  private static final String DEMOS_FRAGMENT_TAG = ""DemosFragmentTag"";

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Utils.setSharedPreferencesDefaultValues(this);
    PermissionCheck.getInstance().setCheckingPermissions(false);
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }

  /**
   * Called when a menu item is tapped.
   */
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
      // If the about menu item was selected
      case R.id.action_about:
        showAboutFragment();
        return true;
      // If the settings menu item was selected
      case R.id.action_settings:
        showSettingsFragment();
        return true;
      case R.id.block_settings:
        showBlockedFragment();
        return true;
      case R.id.action_demos:
        showDemosFragment();
        return true;
      // If the action bar up button was pressed
      case android.R.id.home:
        getFragmentManager().popBackStack();
        getActionBar().setDisplayHomeAsUpEnabled(false);
    }
    return super.onOptionsItemSelected(item);
  }

  /**
   * Ensures Bluetooth is available on the beacon and it is enabled. If not,
   * displays a dialog requesting user permission to enable Bluetooth.
   */
  private void checkPermissions(BluetoothAdapter bluetoothAdapter) {
    // Acquire lock
    PermissionCheck.getInstance().setCheckingPermissions(true);
    if (!bluetoothAdapter.isEnabled()) {
      Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
      startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
      return;
    }
    ensureLocationPermissionIsEnabled();
  }

  @Override
  protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    Log.d(TAG, ""onActivityResult"");
    if (requestCode == REQUEST_ENABLE_BT && resultCode == -1) {
      ensureLocationPermissionIsEnabled();
      return;
    }
    Toast.makeText(this, getString(R.string.bt_on), Toast.LENGTH_LONG).show();
    finish();
  }

  private void ensureLocationPermissionIsEnabled() {
    if (Build.VERSION.SDK_INT >= 23 && ContextCompat.checkSelfPermission(this,
        android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
      ActivityCompat.requestPermissions(this, new String[]{
          android.Manifest.permission.ACCESS_COARSE_LOCATION}, REQUEST_LOCATION);
      return;
    }
    PermissionCheck.getInstance().setCheckingPermissions(false);
    finishLoad();
  }

  @Override
  public void onRequestPermissionsResult(int requestCode,
      String permissions[], int[] grantResults) {
    switch (requestCode) {
      case REQUEST_LOCATION: {
        // If request is cancelled, the result arrays are empty.
        if (grantResults.length > 0
            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
          PermissionCheck.getInstance().setCheckingPermissions(false);
        } else {
          Toast.makeText(getApplicationContext(),
              getString(R.string.loc_permission), Toast.LENGTH_LONG).show();
          finish();
        }
        break;
      }
      default:
    }
  }

  @Override
  protected void onResume() {
    super.onResume();
    // Lock to prevent onResume from running until all permissions are granted
    if (!PermissionCheck.getInstance().isCheckingPermissions()) {
      Log.d(TAG, ""resumed MainActivity"");
      BluetoothManager btManager = (BluetoothManager) getSystemService(BLUETOOTH_SERVICE);
      BluetoothAdapter btAdapter = btManager != null ? btManager.getAdapter() : null;
      if (btAdapter == null) {
        Toast.makeText(getApplicationContext(),
            R.string.error_bluetooth_support, Toast.LENGTH_LONG).show();
        finish();
        return;
      }
      if (Utils.checkIfUserHasOptedIn(this)) {
        Log.d(TAG, ""checkingPermissions"");
        checkPermissions(btAdapter);
      } else {
        // Show the oob activity
        Intent intent = new Intent(this, OobActivity.class);
        startActivity(intent);
      }
    }
  }

  private void finishLoad() {
    Intent intent = new Intent(this, ScreenListenerService.class);
    startService(intent);
    NearbyBeaconsFragment nearbyBeaconsFragment =
        (NearbyBeaconsFragment) getFragmentManager().findFragmentByTag(NEARBY_BEACONS_FRAGMENT_TAG);
    if (nearbyBeaconsFragment != null) {
      nearbyBeaconsFragment.restartScan();
    } else {
      showFragment(new NearbyBeaconsFragment(), NEARBY_BEACONS_FRAGMENT_TAG, false);
    }
  }

  /**
   * Show the fragment to configure the app.
   */
  private void showSettingsFragment() {
    showFragment(new SettingsFragment(), SETTINGS_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying information about this application.
   */
  private void showAboutFragment() {
    showFragment(new AboutFragment(), ABOUT_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying the blocked URLs.
   */
  private void showBlockedFragment() {
    showFragment(new BlockedFragment(), BLOCKED_URLS_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying the demos.
   */
  private void showDemosFragment() {
    showFragment(new DemosFragment(), DEMOS_FRAGMENT_TAG, true);
  }

  @SuppressLint(""CommitTransaction"")
  private void showFragment(Fragment newFragment, String fragmentTag, boolean addToBackStack) {
    FragmentTransaction transaction = getFragmentManager().beginTransaction()
        .setCustomAnimations(
            R.animator.fade_in_and_slide_up_fragment,
            R.animator.fade_out_fragment,
            R.animator.fade_in_activity,
            R.animator.fade_out_fragment)
        .replace(R.id.main_activity_container, newFragment, fragmentTag);
    if (addToBackStack) {
      transaction.addToBackStack(null);
    }
    transaction.commit();
  }
}"
4364;13;6019048;data class;critical;2019-04-12 12:11:06.494304;class;org.cloudfoundry.identity.uaa.account.ChangeEmailController.ValidEmail;git@github.com:cloudfoundry/uaa.git;f3b66dd2a250c1309a86cade560ac9a9cfeafec7;/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java;147;158;https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158;1;"    public static class ValidEmail {
        @Email
        String newEmail;

        public String getNewEmail() {
            return newEmail;
        }

        public void setNewEmail(String email) {
            this.newEmail = email;
        }
    }"
888;4;6533723;long method;none;2019-03-29 13:19:01.865515;function;org.eclipse.smarthome.core.thing.internal.profiles.ProfileTypeRegistryImpl#removeProfileTypeProvider ProfileTypeProvider;git@github.com:eclipse/smarthome.git;b8455de15d65512e8fac4e94d42de6ab2fccf1c5;/bundles/core/org.eclipse.smarthome.core.thing/src/main/java/org/eclipse/smarthome/core/thing/internal/profiles/ProfileTypeRegistryImpl.java;59;61;https://github.com/eclipse/smarthome/blob/b8455de15d65512e8fac4e94d42de6ab2fccf1c5/bundles/core/org.eclipse.smarthome.core.thing/src/main/java/org/eclipse/smarthome/core/thing/internal/profiles/ProfileTypeRegistryImpl.java/#L59-L61;1;"    protected void removeProfileTypeProvider(ProfileTypeProvider profileTypeProvider) {
        profileTypeProviders.remove(profileTypeProvider);
    }"
14994;13;7725777;data class;critical;2019-09-12 10:09:15.256964;class;com.vmware.admiral.request.notification.NotificationsService.NotificationsAggregatorState;git@github.com:vmware/admiral.git;e02d0e77f65d0ee3541a378110ecd4233bdb6664;/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java;52;55;https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55;1;"    public static class NotificationsAggregatorState {
        public long recentEventLogsCount;
        public long activeRequestsCount;
    }"
1060;5;7032580;feature envy;none;2019-03-29 13:28:39.037968;function;com.ibm.cloud.objectstorage.services.s3.internal.S3ErrorResponseHandler#needsConnectionLeftOpen;git@github.com:IBM/ibm-cos-sdk-java.git;d6b03864c15c622ce439e39f20ab41a77dc1cc83;/ibm-cos-java-sdk-s3/src/main/java/com/ibm/cloud/objectstorage/services/s3/internal/S3ErrorResponseHandler.java;207;209;https://github.com/IBM/ibm-cos-sdk-java/blob/d6b03864c15c622ce439e39f20ab41a77dc1cc83/ibm-cos-java-sdk-s3/src/main/java/com/ibm/cloud/objectstorage/services/s3/internal/S3ErrorResponseHandler.java/#L207-L209;1;"    public boolean needsConnectionLeftOpen() {
        return false;
    }"
11254;3;3797964;data class;none;2019-08-04 19:59:24.848687;class;com.alipay.dw.jstorm.transcation.TransactionalGlobalCount.Value;git@github.com:alibaba/jstorm.git;5d6cde22dbca7df3d6e6830bf94f98a6639ab559;/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java;93;96;https://github.com/alibaba/jstorm/blob/5d6cde22dbca7df3d6e6830bf94f98a6639ab559/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java/#L93-L96;1;"    public static class Value {
        int        count = 0;
        BigInteger txid;
    }"
596;6;5894436;blob;none;2019-03-27 10:50:12.577049;class;org.apache.usergrid.security.shiro.credentials.AdminUserCredentials;git@github.com:apache/usergrid.git;ac1e6e4035f9307b871478ed47246cf92cfd5f7f;/stack/services/src/main/java/org/apache/usergrid/security/shiro/credentials/AdminUserCredentials.java;20;22;https://github.com/apache/usergrid/blob/ac1e6e4035f9307b871478ed47246cf92cfd5f7f/stack/services/src/main/java/org/apache/usergrid/security/shiro/credentials/AdminUserCredentials.java/#L20-L22;1;"public interface AdminUserCredentials extends PrincipalCredentials {

}"
2075;3;8576209;long method;none;2019-04-01 12:43:08.672473;function;org.apache.hadoop.hbase.thrift2.generated.THBaseService.getNamespaceDescriptor_args.getNamespaceDescriptor_args;git@github.com:apache/hbase.git;44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f;/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THBaseService.java;48842;48843;https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/THBaseService.java/#L48842-L48843;1;"    public getNamespaceDescriptor_args() {
    }"
13302;1;8666215;long method;major;2019-08-29 13:24:44.681864;function;org.apache.ignite.internal.processors.query.h2.H2ResultSetIterator#fetchNext;git@github.com:apache/ignite.git;7a7c407ea41477aae8508bfe871b4e9a67e1b277;/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java;101;137;https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java/#L101-L137;1;"    private boolean fetchNext() throws IgniteCheckedException {
        if (data == null)
            return false;

        try {
            if (!data.next()) {
                close();

                return false;
            }

            if (res != null) {
                Value[] values = res.currentRow();

                for (int c = 0; c < row.length; c++) {
                    Value val = values[c];

                    if (val instanceof GridH2ValueCacheObject) {
                        GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];

                        row[c] = valCacheObj.getObject(true);
                    }
                    else
                        row[c] = val.getObject();
                }
            }
            else {
                for (int c = 0; c < row.length; c++)
                    row[c] = data.getObject(c + 1);
            }

            return true;
        }
        catch (SQLException e) {
            throw new IgniteSQLException(e);
        }
    }"
15311;21;4081252;feature envy;critical;2019-09-13 06:40:45.141671;function;org.apache.hyracks.storage.am.lsm.rtree.dataflow.LSMRTreeWithAntiMatterLocalResource#createInstance INCServiceContext;git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/hyracks-fullstack/hyracks/hyracks-storage-am-lsm-rtree/src/main/java/org/apache/hyracks/storage/am/lsm/rtree/dataflow/LSMRTreeWithAntiMatterLocalResource.java;96;109;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/hyracks-fullstack/hyracks/hyracks-storage-am-lsm-rtree/src/main/java/org/apache/hyracks/storage/am/lsm/rtree/dataflow/LSMRTreeWithAntiMatterLocalResource.java/#L96-L109;1;"    @Override
    public ILSMIndex createInstance(INCServiceContext serviceCtx) throws HyracksDataException {
        IIOManager ioManager = serviceCtx.getIoManager();
        FileReference file = ioManager.resolve(path);
        List<IVirtualBufferCache> virtualBufferCaches = vbcProvider.getVirtualBufferCaches(serviceCtx, file);
        ioOpCallbackFactory.initialize(serviceCtx, this);
        return LSMRTreeUtils.createLSMTreeWithAntiMatterTuples(ioManager, virtualBufferCaches, file,
                storageManager.getBufferCache(serviceCtx), typeTraits, cmpFactories, btreeCmpFactories,
                valueProviderFactories, rtreePolicyType,
                mergePolicyFactory.createMergePolicy(mergePolicyProperties, serviceCtx),
                opTrackerProvider.getOperationTracker(serviceCtx, this), ioSchedulerProvider.getIoScheduler(serviceCtx),
                ioOpCallbackFactory, linearizeCmpFactory, rtreeFields, filterTypeTraits, filterCmpFactories,
                filterFields, durable, isPointMBR, metadataPageManagerFactory);
    }"
1322;11;6834699;feature envy;none;2019-03-29 13:43:46.305548;function;org.eclipse.n4js.services.N4JSGrammarAccess.ExportClauseElements#getGroup_1_1;git@github.com:eclipse/n4js.git;f715912fce0352ab574ff878086f77d17a78c908;/plugins/org.eclipse.n4js/src-gen/org/eclipse/n4js/services/N4JSGrammarAccess.java;625;625;https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js/src-gen/org/eclipse/n4js/services/N4JSGrammarAccess.java/#L625-L625;1;"		public Group getGroup_1_1() { return cGroup_1_1; }"
10800;4;6066851;data class;major;2019-07-26 20:27:14.343191;class;org.eclipse.ceylon.common.config.ImprovedConfigReaderListenerAdapter.Whitespace;git@github.com:eclipse/ceylon.git;d3994d6cd120c4df85952cd9432123b413cfd65a;/common/src/org/eclipse/ceylon/common/config/ConfigWriter.java;395;404;https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/common/src/org/eclipse/ceylon/common/config/ConfigWriter.java/#L395-L404;1;"    class Whitespace implements Text {
        private String text;
        public Whitespace(String text) {
            this.text = text;
        }
        @Override
        public String getText() {
            return text;
        }
    }"
13230;1;5503308;long method;major;2019-08-29 11:32:38.090888;function;org.apache.rocketmq.common.UtilAll.getIP;git@github.com:apache/rocketmq.git;971fa8ed8b209b39bdfe41c57cd64576d244e6bd;/common/src/main/java/org/apache/rocketmq/common/UtilAll.java;484;516;https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/common/src/main/java/org/apache/rocketmq/common/UtilAll.java/#L484-L516;1;"    public static byte[] getIP() {
        try {
            Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();
            InetAddress ip = null;
            byte[] internalIP = null;
            while (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration addresses = netInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    ip = (InetAddress) addresses.nextElement();
                    if (ip != null && ip instanceof Inet4Address) {
                        byte[] ipByte = ip.getAddress();
                        if (ipByte.length == 4) {
                            if (ipCheck(ipByte)) {
                                if (!isInternalIP(ipByte)) {
                                    return ipByte;
                                } else if (internalIP == null) {
                                    internalIP = ipByte;
                                }
                            }
                        }
                    }
                }
            }
            if (internalIP != null) {
                return internalIP;
            } else {
                throw new RuntimeException(""Can not get local ip"");
            }
        } catch (Exception e) {
            throw new RuntimeException(""Can not get local ip"", e);
        }
    }"
1086;4;7076341;feature envy;none;2019-03-29 13:30:09.027794;function;com.linkedin.parseq.MultiException.MultiException Collection<? extends Throwable>;git@github.com:linkedin/parseq.git;6151cc9064cf8af2ec5ab10ec80aa8c40db6b13c;/subprojects/parseq/src/main/java/com/linkedin/parseq/MultiException.java;48;50;https://github.com/linkedin/parseq/blob/6151cc9064cf8af2ec5ab10ec80aa8c40db6b13c/subprojects/parseq/src/main/java/com/linkedin/parseq/MultiException.java/#L48-L50;1;"  public MultiException(Collection<? extends Throwable> causes) {
    this(null, causes);
  }"
14669;4;6019048;data class;major;2019-09-12 08:07:48.089383;class;org.cloudfoundry.identity.uaa.account.ChangeEmailController.ValidEmail;git@github.com:cloudfoundry/uaa.git;f3b66dd2a250c1309a86cade560ac9a9cfeafec7;/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java;147;158;https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158;1;"    public static class ValidEmail {
        @Email
        String newEmail;

        public String getNewEmail() {
            return newEmail;
        }

        public void setNewEmail(String email) {
            this.newEmail = email;
        }
    }"
12651;3;9006040;long method;major;2019-08-06 20:11:42.986903;function;org.apache.solr.update.processor.DistributedZkUpdateProcessor#doDefensiveChecks DistribPhase;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor.java;953;1007;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor.java/#L953-L1007;1;"  private void doDefensiveChecks(DistribPhase phase) {
    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;
    if (isReplayOrPeersync) return;

    String from = req.getParams().get(DISTRIB_FROM);
    ClusterState clusterState = zkController.getClusterState();

    DocCollection docCollection = clusterState.getCollection(collection);
    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());
    boolean localIsLeader = cloudDesc.isLeader();
    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay
      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);
      if (fromShard != null) {
        if (mySlice.getState() == Slice.State.ACTIVE)  {
          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,
              ""Request says it is coming from parent shard leader but we are in active state"");
        }
        // shard splitting case -- check ranges to see if we are a sub-shard
        Slice fromSlice = docCollection.getSlice(fromShard);
        DocRouter.Range parentRange = fromSlice.getRange();
        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);
        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {
          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,
              ""Request says it is coming from parent shard leader but parent hash range is not superset of my range"");
        }
      } else {
        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?
        if (fromCollection == null)  {
          log.error(""Request says it is coming from leader, but we are the leader: "" + req.getParamString());
          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, ""Request says it is coming from leader, but we are the leader"");
          solrExc.setMetadata(""cause"", ""LeaderChanged"");
          throw solrExc;
        }
      }
    }

    int count = 0;
    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {
      count++;
      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value
      localIsLeader = cloudDesc.isLeader();
      try {
        Thread.sleep(500);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }

    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {
      log.error(""ClusterState says we are the leader, but locally we don't think so"");
      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,
          ""ClusterState says we are the leader ("" + zkController.getBaseUrl()
              + ""/"" + req.getCore().getName() + ""), but locally we don't think so. Request came from "" + from);
    }
  }"
6885;3;8920121;long method;major;2019-05-20 10:03:06.514137;function;org.apache.hadoop.hive.ql.exec.TopNHash#tryStoreVectorizedKey HiveKey|boolean|int;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/ql/src/java/org/apache/hadoop/hive/ql/exec/TopNHash.java;213;262;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/exec/TopNHash.java/#L213-L262;1;"  public void tryStoreVectorizedKey(HiveKey key, boolean partColsIsNull, int batchIndex)
      throws HiveException, IOException {
    // Assumption - batchIndex is increasing; startVectorizedBatch was called
    int size = indexes.size();
    int index = size < topN ? size : evicted;
    keys[index] = Arrays.copyOf(key.getBytes(), key.getLength());
    distKeyLengths[index] = key.getDistKeyLength();
    hashes[index] = key.hashCode();
    Integer collisionIndex = indexes.store(index);
    if (null != collisionIndex) {
      /*
       * since there is a collision index will be used for the next value 
       * so have the map point back to original index.
       */
      if ( indexes instanceof HashForGroup ) {
        indexes.store(collisionIndex);
      }
      // forward conditional on the survival of the corresponding key currently in indexes.
      ++batchNumForwards;
      batchIndexToResult[batchIndex] = MAY_FORWARD - collisionIndex;
      return;
    }
    indexToBatchIndex[index] = batchIndex;
    batchIndexToResult[batchIndex] = index;
    if (size != topN) return;
    evicted = indexes.removeBiggest();  // remove the biggest key
    if (index == evicted) {
      excluded++;
      batchIndexToResult[batchIndex] = EXCLUDE;
      indexToBatchIndex[index] = -1;
      return; // input key is bigger than any of keys in hash
    }
    removed(evicted);
    int evictedBatchIndex = indexToBatchIndex[evicted];
    if (evictedBatchIndex >= 0) {
      // reset the result for the evicted index
      batchIndexToResult[evictedBatchIndex] = EXCLUDE;
      indexToBatchIndex[evicted] = -1;
    }
    // Evict all results grouped with this index; it cannot be any key further in the batch.
    // If we evict a key from this batch, the keys grouped with it cannot be earlier that that key.
    // If we evict a key that is not from this batch, initial i = (-1) + 1 = 0, as intended.
    int evictedForward = (MAY_FORWARD - evicted);
    for (int i = evictedBatchIndex + 1; i < batchIndex && (batchNumForwards > 0); ++i) {
      if (batchIndexToResult[i] == evictedForward) {
        batchIndexToResult[i] = EXCLUDE;
        --batchNumForwards;
      }
    }
  }"
6350;7;5456950;feature envy;major;2019-04-23 16:36:59.921826;function;org.apache.pulsar.broker.loadbalance.impl.SimpleLoadManagerImpl.isBelowLoadLevel SystemResourceUsage|float;git@github.com:apache/pulsar.git;044daf8d61328265640a5b3e5008fc04fac73efa;/pulsar-broker/src/main/java/org/apache/pulsar/broker/loadbalance/impl/SimpleLoadManagerImpl.java;1069;1074;https://github.com/apache/pulsar/blob/044daf8d61328265640a5b3e5008fc04fac73efa/pulsar-broker/src/main/java/org/apache/pulsar/broker/loadbalance/impl/SimpleLoadManagerImpl.java/#L1069-L1074;1;"    public static boolean isBelowLoadLevel(SystemResourceUsage usage, float thresholdPercentage) {
        return (usage.bandwidthOut.percentUsage() < thresholdPercentage
                && usage.bandwidthIn.percentUsage() < thresholdPercentage
                && usage.cpu.percentUsage() < thresholdPercentage
                && usage.directMemory.percentUsage() < thresholdPercentage);
    }"
9358;13;5023689;long method;major;2019-07-23 16:06:33.948657;function;org.apache.lens.cube.metadata.FactPartition#compareTo FactPartition;git@github.com:apache/lens.git;f64a0f5984216a61f0a2c5ef90510a88390acde0;/lens-cube/src/main/java/org/apache/lens/cube/metadata/FactPartition.java;148;195;https://github.com/apache/lens/blob/f64a0f5984216a61f0a2c5ef90510a88390acde0/lens-cube/src/main/java/org/apache/lens/cube/metadata/FactPartition.java/#L148-L195;0,5;"  public int compareTo(FactPartition o) {
    int colComp = this.partCol.compareTo(o.partCol);
    if (colComp == 0) {
      int partComp = 0;
      if (this.partSpec != null) {
        if (o.partSpec == null) {
          partComp = 1;
        } else {
          partComp = this.partSpec.compareTo(o.partSpec);
        }
      } else {
        if (o.partSpec != null) {
          partComp = -1;
        } else {
          partComp = 0;
        }
      }
      if (partComp == 0) {
        int upComp = 0;
        if (this.period != null && o.period != null) {
          upComp = this.period.compareTo(o.period);
        } else if (this.period == null && o.period == null) {
          upComp = 0;
        } else if (this.period == null) {
          upComp = -1;
        } else {
          upComp = 1;
        }
        if (upComp == 0) {
          if (this.containingPart != null) {
            if (o.containingPart == null) {
              return 1;
            }
            return this.containingPart.compareTo(o.containingPart);
          } else {
            if (o.containingPart != null) {
              return -1;
            } else {
              return 0;
            }
          }
        }
        return upComp;
      }
      return partComp;
    }
    return colComp;
  }"
1542;12;7671918;feature envy;major;2019-03-29 13:57:38.834617;function;com.qmuiteam.qmui.widget.QMUITopBarLayout#addRightImageButton int|int;git@github.com:Tencent/QMUI_Android.git;6ff5493a05845918c126cce8a3e639f8d996481b;/qmui/src/main/java/com/qmuiteam/qmui/widget/QMUITopBarLayout.java;136;138;https://github.com/Tencent/QMUI_Android/blob/6ff5493a05845918c126cce8a3e639f8d996481b/qmui/src/main/java/com/qmuiteam/qmui/widget/QMUITopBarLayout.java/#L136-L138;0;"    public QMUIAlphaImageButton addRightImageButton(int drawableResId, int viewId) {
        return mTopBar.addRightImageButton(drawableResId, viewId);
    }"
1401;11;7473205;long method;none;2019-03-29 13:49:33.767693;function;example.model.Customer377.Customer377;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/model/Customer377.java;15;15;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer377.java/#L15-L15;0;	protected Customer377() {}
3503;17;5392679;data class;major;2019-04-05 13:06:13.356190;class;org.apache.openejb.jee.sun.JaxbSun.NamespaceFilter;git@github.com:apache/openejb.git;f10c077ade927d73bdbd9ed4cc28b79f58a1cd66;/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/sun/JaxbSun.java;96;106;https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-jee/src/main/java/org/apache/openejb/jee/sun/JaxbSun.java/#L96-L106;0;"    public static class NamespaceFilter extends XMLFilterImpl {
        private static final InputSource EMPTY_INPUT_SOURCE = new InputSource(new ByteArrayInputStream(new byte[0]));

        public NamespaceFilter(XMLReader xmlReader) {
            super(xmlReader);
        }

        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
            return EMPTY_INPUT_SOURCE;
        }
    }"
641;7;5939530;feature envy;critical;2019-03-27 10:58:26.605877;function;org.apache.zookeeper.server.auth.KerberosName.Rule.replaceSubstitution String|Pattern|String|boolean;git@github.com:apache/zookeeper.git;07c3aaf3d723fb3144c0aedc0c2b655325df70e9;/zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/KerberosName.java;287;295;https://github.com/apache/zookeeper/blob/07c3aaf3d723fb3144c0aedc0c2b655325df70e9/zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/KerberosName.java/#L287-L295;1;"    static String replaceSubstitution(String base, Pattern from, String to, 
                                      boolean repeat) {
      Matcher match = from.matcher(base);
      if (repeat) {
        return match.replaceAll(to);
      } else {
        return match.replaceFirst(to);
      }
    }"
11565;3;4784081;feature envy;major;2019-08-05 12:34:17.426356;function;org.apache.sentry.hdfs.service.thrift.SentryHDFSService.handle_hms_notification_result.handle_hms_notification_resultStandardScheme#write org.apache.thrift.protocol.TProtocol|handle_hms_notification_result;git@github.com:apache/incubator-sentry.git;4643f988a5e0ce2b9749e6365edea3a16482de86;/sentry-hdfs/sentry-hdfs-common/src/gen/thrift/gen-javabean/org/apache/sentry/hdfs/service/thrift/SentryHDFSService.java;1004;1010;https://github.com/apache/incubator-sentry/blob/4643f988a5e0ce2b9749e6365edea3a16482de86/sentry-hdfs/sentry-hdfs-common/src/gen/thrift/gen-javabean/org/apache/sentry/hdfs/service/thrift/SentryHDFSService.java/#L1004-L1010;0;"      public void write(org.apache.thrift.protocol.TProtocol oprot, handle_hms_notification_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }"
562;7;5841731;long method;none;2019-03-27 10:45:14.920243;function;org.apache.catalina.startup.VersionLoggerListener#setLogArgs boolean;git@github.com:apache/tomcat.git;a9c1a0661198d9ba37c1facd8385fe05d538c4ad;/java/org/apache/catalina/startup/VersionLoggerListener.java;55;57;https://github.com/apache/tomcat/blob/a9c1a0661198d9ba37c1facd8385fe05d538c4ad/java/org/apache/catalina/startup/VersionLoggerListener.java/#L55-L57;1;"    public void setLogArgs(boolean logArgs) {
        this.logArgs = logArgs;
    }"
3213;14;6209901;feature envy;critical;2019-04-05 12:45:14.335376;function;org.eclipse.che.ide.ui.tree.Tree#onNodeSelected TreeNodeElement<D>|SignalEvent;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/ide/commons-gwt/src/main/java/org/eclipse/che/ide/ui/tree/Tree.java;732;736;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/commons-gwt/src/main/java/org/eclipse/che/ide/ui/tree/Tree.java/#L732-L736;1;"        @Override
        public void onNodeSelected(TreeNodeElement<D> node, SignalEvent event) {
          getSelectionModel().setTreeActive(true);
          selectNode(node.getData(), event, true);
        }"
11272;3;8987975;blob;major;2019-08-04 21:33:28.224619;class;org.apache.lucene.index.DocumentsWriterDeleteQueue;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java;71;495;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java/#L71-L495;1;"final class DocumentsWriterDeleteQueue implements Accountable {

  // the current end (latest delete operation) in the delete queue:
  private volatile Node<?> tail;

  /** Used to record deletes against all prior (already written to disk) segments.  Whenever any segment flushes, we bundle up this set of
   *  deletes and insert into the buffered updates stream before the newly flushed segment(s). */
  private final DeleteSlice globalSlice;
  private final BufferedUpdates globalBufferedUpdates;
  
  // only acquired to update the global deletes, pkg-private for access by tests:
  final ReentrantLock globalBufferLock = new ReentrantLock();

  final long generation;

  /** Generates the sequence number that IW returns to callers changing the index, showing the effective serialization of all operations. */
  private final AtomicLong nextSeqNo;

  private final InfoStream infoStream;

  // for asserts
  long maxSeqNo = Long.MAX_VALUE;
  
  DocumentsWriterDeleteQueue(InfoStream infoStream) {
    // seqNo must start at 1 because some APIs negate this to also return a boolean
    this(infoStream, 0, 1);
  }
  
  DocumentsWriterDeleteQueue(InfoStream infoStream, long generation, long startSeqNo) {
    this(infoStream, new BufferedUpdates(""global""), generation, startSeqNo);
  }

  DocumentsWriterDeleteQueue(InfoStream infoStream, BufferedUpdates globalBufferedUpdates, long generation, long startSeqNo) {
    this.infoStream = infoStream;
    this.globalBufferedUpdates = globalBufferedUpdates;
    this.generation = generation;
    this.nextSeqNo = new AtomicLong(startSeqNo);
    /*
     * we use a sentinel instance as our initial tail. No slice will ever try to
     * apply this tail since the head is always omitted.
     */
    tail = new Node<>(null); // sentinel
    globalSlice = new DeleteSlice(tail);
  }

  long addDelete(Query... queries) {
    long seqNo = add(new QueryArrayNode(queries));
    tryApplyGlobalSlice();
    return seqNo;
  }

  long addDelete(Term... terms) {
    long seqNo = add(new TermArrayNode(terms));
    tryApplyGlobalSlice();
    return seqNo;
  }

  long addDocValuesUpdates(DocValuesUpdate... updates) {
    long seqNo = add(new DocValuesUpdatesNode(updates));
    tryApplyGlobalSlice();
    return seqNo;
  }

  static Node<Term> newNode(Term term) {
    return new TermNode(term);
  }

  static Node<DocValuesUpdate[]> newNode(DocValuesUpdate... updates) {
    return new DocValuesUpdatesNode(updates);
  }

  /**
   * invariant for document update
   */
  long add(Node<?> deleteNode, DeleteSlice slice) {
    long seqNo = add(deleteNode);
    /*
     * this is an update request where the term is the updated documents
     * delTerm. in that case we need to guarantee that this insert is atomic
     * with regards to the given delete slice. This means if two threads try to
     * update the same document with in turn the same delTerm one of them must
     * win. By taking the node we have created for our del term as the new tail
     * it is guaranteed that if another thread adds the same right after us we
     * will apply this delete next time we update our slice and one of the two
     * competing updates wins!
     */
    slice.sliceTail = deleteNode;
    assert slice.sliceHead != slice.sliceTail : ""slice head and tail must differ after add"";
    tryApplyGlobalSlice(); // TODO doing this each time is not necessary maybe
    // we can do it just every n times or so?

    return seqNo;
  }

  synchronized long add(Node<?> newNode) {
    tail.next = newNode;
    this.tail = newNode;
    return getNextSequenceNumber();
  }

  boolean anyChanges() {
    globalBufferLock.lock();
    try {
      /*
       * check if all items in the global slice were applied 
       * and if the global slice is up-to-date
       * and if globalBufferedUpdates has changes
       */
      return globalBufferedUpdates.any() || !globalSlice.isEmpty() || globalSlice.sliceTail != tail || tail.next != null;
    } finally {
      globalBufferLock.unlock();
    }
  }

  void tryApplyGlobalSlice() {
    if (globalBufferLock.tryLock()) {
      /*
       * The global buffer must be locked but we don't need to update them if
       * there is an update going on right now. It is sufficient to apply the
       * deletes that have been added after the current in-flight global slices
       * tail the next time we can get the lock!
       */
      try {
        if (updateSliceNoSeqNo(globalSlice)) {
          globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
        }
      } finally {
        globalBufferLock.unlock();
      }
    }
  }

  FrozenBufferedUpdates freezeGlobalBuffer(DeleteSlice callerSlice) throws IOException {
    globalBufferLock.lock();
    /*
     * Here we freeze the global buffer so we need to lock it, apply all
     * deletes in the queue and reset the global slice to let the GC prune the
     * queue.
     */
    final Node<?> currentTail = tail; // take the current tail make this local any
    // Changes after this call are applied later
    // and not relevant here
    if (callerSlice != null) {
      // Update the callers slices so we are on the same page
      callerSlice.sliceTail = currentTail;
    }
    try {
      if (globalSlice.sliceTail != currentTail) {
        globalSlice.sliceTail = currentTail;
        globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
      }

      if (globalBufferedUpdates.any()) {
        final FrozenBufferedUpdates packet = new FrozenBufferedUpdates(infoStream, globalBufferedUpdates, null);
        globalBufferedUpdates.clear();
        return packet;
      } else {
        return null;
      }
    } finally {
      globalBufferLock.unlock();
    }
  }

  DeleteSlice newSlice() {
    return new DeleteSlice(tail);
  }

  /** Negative result means there were new deletes since we last applied */
  synchronized long updateSlice(DeleteSlice slice) {
    long seqNo = getNextSequenceNumber();
    if (slice.sliceTail != tail) {
      // new deletes arrived since we last checked
      slice.sliceTail = tail;
      seqNo = -seqNo;
    }
    return seqNo;
  }

  /** Just like updateSlice, but does not assign a sequence number */
  boolean updateSliceNoSeqNo(DeleteSlice slice) {
    if (slice.sliceTail != tail) {
      // new deletes arrived since we last checked
      slice.sliceTail = tail;
      return true;
    }
    return false;
  }

  static class DeleteSlice {
    // No need to be volatile, slices are thread captive (only accessed by one thread)!
    Node<?> sliceHead; // we don't apply this one
    Node<?> sliceTail;

    DeleteSlice(Node<?> currentTail) {
      assert currentTail != null;
      /*
       * Initially this is a 0 length slice pointing to the 'current' tail of
       * the queue. Once we update the slice we only need to assign the tail and
       * have a new slice
       */
      sliceHead = sliceTail = currentTail;
    }

    void apply(BufferedUpdates del, int docIDUpto) {
      if (sliceHead == sliceTail) {
        // 0 length slice
        return;
      }
      /*
       * When we apply a slice we take the head and get its next as our first
       * item to apply and continue until we applied the tail. If the head and
       * tail in this slice are not equal then there will be at least one more
       * non-null node in the slice!
       */
      Node<?> current = sliceHead;
      do {
        current = current.next;
        assert current != null : ""slice property violated between the head on the tail must not be a null node"";
        current.apply(del, docIDUpto);
      } while (current != sliceTail);
      reset();
    }

    void reset() {
      // Reset to a 0 length slice
      sliceHead = sliceTail;
    }

    /**
     * Returns <code>true</code> iff the given node is identical to the the slices tail,
     * otherwise <code>false</code>.
     */
    boolean isTail(Node<?> node) {
      return sliceTail == node;
    }

    /**
     * Returns <code>true</code> iff the given item is identical to the item
     * hold by the slices tail, otherwise <code>false</code>.
     */
    boolean isTailItem(Object object) {
      return sliceTail.item == object;
    }

    boolean isEmpty() {
      return sliceHead == sliceTail;
    }
  }

  public int numGlobalTermDeletes() {
    return globalBufferedUpdates.numTermDeletes.get();
  }

  void clear() {
    globalBufferLock.lock();
    try {
      final Node<?> currentTail = tail;
      globalSlice.sliceHead = globalSlice.sliceTail = currentTail;
      globalBufferedUpdates.clear();
    } finally {
      globalBufferLock.unlock();
    }
  }

  static class Node<T> {
    volatile Node<?> next;
    final T item;

    Node(T item) {
      this.item = item;
    }

    void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {
      throw new IllegalStateException(""sentinel item must never be applied"");
    }

    boolean isDelete() {
      return true;
    }
  }

  private static final class TermNode extends Node<Term> {

    TermNode(Term term) {
      super(term);
    }

    @Override
    void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {
      bufferedDeletes.addTerm(item, docIDUpto);
    }

    @Override
    public String toString() {
      return ""del="" + item;
    }

  }

  private static final class QueryArrayNode extends Node<Query[]> {
    QueryArrayNode(Query[] query) {
      super(query);
    }

    @Override
    void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
      for (Query query : item) {
        bufferedUpdates.addQuery(query, docIDUpto);  
      }
    }
  }
  
  private static final class TermArrayNode extends Node<Term[]> {
    TermArrayNode(Term[] term) {
      super(term);
    }

    @Override
    void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
      for (Term term : item) {
        bufferedUpdates.addTerm(term, docIDUpto);  
      }
    }

    @Override
    public String toString() {
      return ""dels="" + Arrays.toString(item);
    }

  }

  private static final class DocValuesUpdatesNode extends Node<DocValuesUpdate[]> {

    DocValuesUpdatesNode(DocValuesUpdate... updates) {
      super(updates);
    }

    @Override
    void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
      for (DocValuesUpdate update : item) {
        switch (update.type) {
          case NUMERIC:
            bufferedUpdates.addNumericUpdate((NumericDocValuesUpdate) update, docIDUpto);
            break;
          case BINARY:
            bufferedUpdates.addBinaryUpdate((BinaryDocValuesUpdate) update, docIDUpto);
            break;
          default:
            throw new IllegalArgumentException(update.type + "" DocValues updates not supported yet!"");
        }
      }
    }


    @Override
    boolean isDelete() {
      return false;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder();
      sb.append(""docValuesUpdates: "");
      if (item.length > 0) {
        sb.append(""term="").append(item[0].term).append(""; updates: ["");
        for (DocValuesUpdate update : item) {
          sb.append(update.field).append(':').append(update.valueToString()).append(',');
        }
        sb.setCharAt(sb.length()-1, ']');
      }
      return sb.toString();
    }
  }
  
  private boolean forceApplyGlobalSlice() {
    globalBufferLock.lock();
    final Node<?> currentTail = tail;
    try {
      if (globalSlice.sliceTail != currentTail) {
        globalSlice.sliceTail = currentTail;
        globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
      }
      return globalBufferedUpdates.any();
    } finally {
      globalBufferLock.unlock();
    }
  }

  public int getBufferedUpdatesTermsSize() {
    globalBufferLock.lock();
    try {
      forceApplyGlobalSlice();
      return globalBufferedUpdates.deleteTerms.size();
    } finally {
      globalBufferLock.unlock();
    }
  }

  @Override
  public long ramBytesUsed() {
    return globalBufferedUpdates.ramBytesUsed();
  }

  @Override
  public String toString() {
    return ""DWDQ: [ generation: "" + generation + "" ]"";
  }

  public long getNextSequenceNumber() {
    long seqNo = nextSeqNo.getAndIncrement();
    assert seqNo < maxSeqNo: ""seqNo="" + seqNo + "" vs maxSeqNo="" + maxSeqNo;
    return seqNo;
  }  

  public long getLastSequenceNumber() {
    return nextSeqNo.get()-1;
  }  

  /** Inserts a gap in the sequence numbers.  This is used by IW during flush or commit to ensure any in-flight threads get sequence numbers
   *  inside the gap */
  public void skipSequenceNumbers(long jump) {
    nextSeqNo.addAndGet(jump);
  }  
}"
9013;15;8996125;feature envy;major;2019-07-21 13:02:26.823006;function;org.apache.solr.client.solrj.impl.Krb5HttpClientBuilder#setup Http2SolrClient;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/solr/solrj/src/java/org/apache/solr/client/solrj/impl/Krb5HttpClientBuilder.java;124;130;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/solrj/src/java/org/apache/solr/client/solrj/impl/Krb5HttpClientBuilder.java/#L124-L130;1;"  @Override
  public void setup(Http2SolrClient http2Client) {
    HttpAuthenticationStore authenticationStore = new HttpAuthenticationStore();
    authenticationStore.addAuthentication(createSPNEGOAuthentication());
    http2Client.getHttpClient().setAuthenticationStore(authenticationStore);
    http2Client.getProtocolHandlers().put(new WWWAuthenticationProtocolHandler(http2Client.getHttpClient()));
  }"
884;5;6546542;blob;none;2019-03-29 13:18:43.849369;class;org.eclipse.n4js.ui.editor.syntaxcoloring.InternalN4JSParser.ruleDoubleLiteral_return;git@github.com:eclipse/n4js.git;f715912fce0352ab574ff878086f77d17a78c908;/plugins/org.eclipse.n4js.ui/src-gen/org/eclipse/n4js/ui/editor/syntaxcoloring/InternalN4JSParser.java;36478;36479;https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ui/src-gen/org/eclipse/n4js/ui/editor/syntaxcoloring/InternalN4JSParser.java/#L36478-L36479;1;"    public static class ruleDoubleLiteral_return extends ParserRuleReturnScope {
    };"
11742;3;7468700;data class;none;2019-08-05 15:58:09.384601;class;example.repo.Customer583Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/repo/Customer583Repository.java;9;12;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer583Repository.java/#L9-L12;0;"public interface Customer583Repository extends CrudRepository<Customer583, Long> {

	List<Customer583> findByLastName(String lastName);
}"
704;7;6216254;blob;major;2019-03-27 11:14:30.601748;class;org.eclipse.elk.core.meta.metaData.impl.MetaDataFactoryImpl;git@github.com:eclipse/elk.git;9a87764f00d863463b1be6de1920d8aa3c3ade70;/plugins/org.eclipse.elk.core.meta/src-gen/org/eclipse/elk/core/meta/metaData/impl/MetaDataFactoryImpl.java;32;307;https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.core.meta/src-gen/org/eclipse/elk/core/meta/metaData/impl/MetaDataFactoryImpl.java/#L32-L307;1;"public class MetaDataFactoryImpl extends EFactoryImpl implements MetaDataFactory
{
  /**
   * Creates the default factory implementation.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public static MetaDataFactory init()
  {
    try
    {
      MetaDataFactory theMetaDataFactory = (MetaDataFactory)EPackage.Registry.INSTANCE.getEFactory(MetaDataPackage.eNS_URI);
      if (theMetaDataFactory != null)
      {
        return theMetaDataFactory;
      }
    }
    catch (Exception exception)
    {
      EcorePlugin.INSTANCE.log(exception);
    }
    return new MetaDataFactoryImpl();
  }

  /**
   * Creates an instance of the factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MetaDataFactoryImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EObject create(EClass eClass)
  {
    switch (eClass.getClassifierID())
    {
      case MetaDataPackage.MD_MODEL: return createMdModel();
      case MetaDataPackage.MD_BUNDLE: return createMdBundle();
      case MetaDataPackage.MD_BUNDLE_MEMBER: return createMdBundleMember();
      case MetaDataPackage.MD_GROUP_OR_OPTION: return createMdGroupOrOption();
      case MetaDataPackage.MD_GROUP: return createMdGroup();
      case MetaDataPackage.MD_OPTION: return createMdOption();
      case MetaDataPackage.MD_OPTION_DEPENDENCY: return createMdOptionDependency();
      case MetaDataPackage.MD_ALGORITHM: return createMdAlgorithm();
      case MetaDataPackage.MD_CATEGORY: return createMdCategory();
      case MetaDataPackage.MD_OPTION_SUPPORT: return createMdOptionSupport();
      default:
        throw new IllegalArgumentException(""The class '"" + eClass.getName() + ""' is not a valid classifier"");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object createFromString(EDataType eDataType, String initialValue)
  {
    switch (eDataType.getClassifierID())
    {
      case MetaDataPackage.MD_OPTION_TARGET_TYPE:
        return createMdOptionTargetTypeFromString(eDataType, initialValue);
      case MetaDataPackage.MD_GRAPH_FEATURE:
        return createMdGraphFeatureFromString(eDataType, initialValue);
      default:
        throw new IllegalArgumentException(""The datatype '"" + eDataType.getName() + ""' is not a valid classifier"");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public String convertToString(EDataType eDataType, Object instanceValue)
  {
    switch (eDataType.getClassifierID())
    {
      case MetaDataPackage.MD_OPTION_TARGET_TYPE:
        return convertMdOptionTargetTypeToString(eDataType, instanceValue);
      case MetaDataPackage.MD_GRAPH_FEATURE:
        return convertMdGraphFeatureToString(eDataType, instanceValue);
      default:
        throw new IllegalArgumentException(""The datatype '"" + eDataType.getName() + ""' is not a valid classifier"");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdModel createMdModel()
  {
    MdModelImpl mdModel = new MdModelImpl();
    return mdModel;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdBundle createMdBundle()
  {
    MdBundleImpl mdBundle = new MdBundleImpl();
    return mdBundle;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdBundleMember createMdBundleMember()
  {
    MdBundleMemberImpl mdBundleMember = new MdBundleMemberImpl();
    return mdBundleMember;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdGroupOrOption createMdGroupOrOption()
  {
    MdGroupOrOptionImpl mdGroupOrOption = new MdGroupOrOptionImpl();
    return mdGroupOrOption;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdGroup createMdGroup()
  {
    MdGroupImpl mdGroup = new MdGroupImpl();
    return mdGroup;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdOption createMdOption()
  {
    MdOptionImpl mdOption = new MdOptionImpl();
    return mdOption;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdOptionDependency createMdOptionDependency()
  {
    MdOptionDependencyImpl mdOptionDependency = new MdOptionDependencyImpl();
    return mdOptionDependency;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdAlgorithm createMdAlgorithm()
  {
    MdAlgorithmImpl mdAlgorithm = new MdAlgorithmImpl();
    return mdAlgorithm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdCategory createMdCategory()
  {
    MdCategoryImpl mdCategory = new MdCategoryImpl();
    return mdCategory;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdOptionSupport createMdOptionSupport()
  {
    MdOptionSupportImpl mdOptionSupport = new MdOptionSupportImpl();
    return mdOptionSupport;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdOptionTargetType createMdOptionTargetTypeFromString(EDataType eDataType, String initialValue)
  {
    MdOptionTargetType result = MdOptionTargetType.get(initialValue);
    if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public String convertMdOptionTargetTypeToString(EDataType eDataType, Object instanceValue)
  {
    return instanceValue == null ? null : instanceValue.toString();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MdGraphFeature createMdGraphFeatureFromString(EDataType eDataType, String initialValue)
  {
    MdGraphFeature result = MdGraphFeature.get(initialValue);
    if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public String convertMdGraphFeatureToString(EDataType eDataType, Object instanceValue)
  {
    return instanceValue == null ? null : instanceValue.toString();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MetaDataPackage getMetaDataPackage()
  {
    return (MetaDataPackage)getEPackage();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @deprecated
   * @generated
   */
  @Deprecated
  public static MetaDataPackage getPackage()
  {
    return MetaDataPackage.eINSTANCE;
  }

} //MetaDataFactoryImpl"
8494;12;5130121;feature envy;major;2019-07-19 12:25:19.787314;function;org.apache.maven.plugins.javadoc.AbstractJavadocMojo#getAggregatedProjects;git@github.com:apache/maven-javadoc-plugin.git;3ab15eb9ec04c82a4b99dc47d0879e77f989d74f;/src/main/java/org/apache/maven/plugins/javadoc/AbstractJavadocMojo.java;2358;2367;https://github.com/apache/maven-javadoc-plugin/blob/3ab15eb9ec04c82a4b99dc47d0879e77f989d74f/src/main/java/org/apache/maven/plugins/javadoc/AbstractJavadocMojo.java/#L2358-L2367;1;"    private Collection<MavenProject> getAggregatedProjects()
    {
        Map<Path, MavenProject> reactorProjectsMap = new HashMap<>();
        for ( MavenProject reactorProject : this.reactorProjects )
        {
            reactorProjectsMap.put( reactorProject.getBasedir().toPath(), reactorProject );
        }

        return modulesForAggregatedProject( project, reactorProjectsMap );
    }"
712;7;6234592;long method;critical;2019-03-27 11:17:47.591964;function;org.eclipse.elk.core.meta.ide.contentassist.antlr.internal.InternalMetaDataParser#rule__MdCategory__Group_4_0__1__Impl;git@github.com:eclipse/elk.git;9a87764f00d863463b1be6de1920d8aa3c3ade70;/plugins/org.eclipse.elk.core.meta.ui/src-gen/org/eclipse/elk/core/meta/ide/contentassist/antlr/internal/InternalMetaDataParser.java;22554;22599;https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.core.meta.ui/src-gen/org/eclipse/elk/core/meta/ide/contentassist/antlr/internal/InternalMetaDataParser.java/#L22554-L22599;1;"    public final void rule__MdCategory__Group_4_0__1__Impl() throws RecognitionException {

        		int stackSize = keepStackSize();
        	
        try {
            // InternalMetaData.g:6468:1: ( ( ( rule__MdCategory__LabelAssignment_4_0_1 ) ) )
            // InternalMetaData.g:6469:1: ( ( rule__MdCategory__LabelAssignment_4_0_1 ) )
            {
            // InternalMetaData.g:6469:1: ( ( rule__MdCategory__LabelAssignment_4_0_1 ) )
            // InternalMetaData.g:6470:2: ( rule__MdCategory__LabelAssignment_4_0_1 )
            {
            if ( state.backtracking==0 ) {
               before(grammarAccess.getMdCategoryAccess().getLabelAssignment_4_0_1()); 
            }
            // InternalMetaData.g:6471:2: ( rule__MdCategory__LabelAssignment_4_0_1 )
            // InternalMetaData.g:6471:3: rule__MdCategory__LabelAssignment_4_0_1
            {
            pushFollow(FOLLOW_2);
            rule__MdCategory__LabelAssignment_4_0_1();

            state._fsp--;
            if (state.failed) return ;

            }

            if ( state.backtracking==0 ) {
               after(grammarAccess.getMdCategoryAccess().getLabelAssignment_4_0_1()); 
            }

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {

            	restoreStackSize(stackSize);

        }
        return ;
    }"
13027;20;8548892;long method;major;2019-08-16 13:46:12.302021;function;org.apache.cloudstack.ha.HAManagerImpl#configureHA Long|HAResource.ResourceType|Boolean|String;git@github.com:apache/cloudstack.git;8d3feb100aab4a45b31a789f444038b892161eec;/server/src/main/java/org/apache/cloudstack/ha/HAManagerImpl.java;337;374;https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/org/apache/cloudstack/ha/HAManagerImpl.java/#L337-L374;1;"    private boolean configureHA(final Long resourceId, final HAResource.ResourceType resourceType, final Boolean enable, final String haProvider) {
        return Transaction.execute(new TransactionCallback<Boolean>() {
            @Override
            public Boolean doInTransaction(TransactionStatus status) {
                HAConfigVO haConfig = (HAConfigVO) haConfigDao.findHAResource(resourceId, resourceType);
                if (haConfig == null) {
                    haConfig = new HAConfigVO();
                    if (haProvider != null) {
                        haConfig.setHaProvider(haProvider);
                    }
                    if (enable != null) {
                        haConfig.setEnabled(enable);
                        haConfig.setManagementServerId(ManagementServerNode.getManagementServerId());
                    }
                    haConfig.setResourceId(resourceId);
                    haConfig.setResourceType(resourceType);
                    if (Strings.isNullOrEmpty(haConfig.getHaProvider())) {
                        throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""HAProvider is not provided for the resource, failing configuration."");
                    }
                    if (haConfigDao.persist(haConfig) != null) {
                        return true;
                    }
                } else {
                    if (enable != null) {
                        haConfig.setEnabled(enable);
                    }
                    if (haProvider != null) {
                        haConfig.setHaProvider(haProvider);
                    }
                    if (Strings.isNullOrEmpty(haConfig.getHaProvider())) {
                        throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""HAProvider is not provided for the resource, failing configuration."");
                    }
                    return haConfigDao.update(haConfig.getId(), haConfig);
                }
                return false;
            }
        });
    }"
10952;3;6904479;long method;major;2019-08-01 17:44:39.287489;function;com.sun.tools.javadoc.main.DocletInvoker#invoke String|Object|Class<?>[]|Object[];git@github.com:google/error-prone-javac.git;a53d069bbdb2c60232ed3811c19b65e41c3e60e0;/src/jdk.javadoc/share/classes/com/sun/tools/javadoc/main/DocletInvoker.java;303;357;https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.javadoc/share/classes/com/sun/tools/javadoc/main/DocletInvoker.java/#L303-L357;0;"    private Object invoke(String methodName, Object returnValueIfNonExistent,
                          Class<?>[] paramTypes, Object[] params)
        throws DocletInvokeException {
            Method meth;
            try {
                meth = docletClass.getMethod(methodName, paramTypes);
            } catch (NoSuchMethodException exc) {
                if (returnValueIfNonExistent == null) {
                    messager.error(Messager.NOPOS, ""main.doclet_method_not_found"",
                                   docletClassName, methodName);
                    throw new DocletInvokeException();
                } else {
                    return returnValueIfNonExistent;
                }
            } catch (SecurityException exc) {
                messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            if (!Modifier.isStatic(meth.getModifiers())) {
                messager.error(Messager.NOPOS, ""main.doclet_method_must_be_static"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            ClassLoader savedCCL =
                Thread.currentThread().getContextClassLoader();
            try {
                if (appClassLoader != null) // will be null if doclet class provided via API
                    Thread.currentThread().setContextClassLoader(appClassLoader);
                return meth.invoke(null , params);
            } catch (IllegalArgumentException | NullPointerException exc) {
                messager.error(Messager.NOPOS, ""main.internal_error_exception_thrown"",
                               docletClassName, methodName, exc.toString());
                throw new DocletInvokeException();
            } catch (IllegalAccessException exc) {
                messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            catch (InvocationTargetException exc) {
                Throwable err = exc.getTargetException();
                if (apiMode)
                    throw new ClientCodeException(err);
                if (err instanceof java.lang.OutOfMemoryError) {
                    messager.error(Messager.NOPOS, ""main.out.of.memory"");
                } else {
                    messager.error(Messager.NOPOS, ""main.exception_thrown"",
                               docletClassName, methodName, exc.toString());
                    exc.getTargetException().printStackTrace(System.err);
                }
                throw new DocletInvokeException();
            } finally {
                Thread.currentThread().setContextClassLoader(savedCCL);
            }
    }"
13760;1;8873169;long method;major;2019-08-30 12:23:57.183264;function;org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore.add_check_constraint_result.add_check_constraint_resultStandardScheme#read org.apache.thrift.protocol.TProtocol|add_check_constraint_result;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java;65076;65111;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java/#L65076-L65111;1;"      public void read(org.apache.thrift.protocol.TProtocol iprot, add_check_constraint_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // O1
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.o1 = new NoSuchObjectException();
                struct.o1.read(iprot);
                struct.setO1IsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // O2
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.o2 = new MetaException();
                struct.o2.read(iprot);
                struct.setO2IsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();
        struct.validate();
      }"
14479;4;8779111;blob;major;2019-09-11 13:23:57.018010;class;org.apache.hadoop.metrics2.impl.MetricsSystemImpl;git@github.com:apache/hadoop-common.git;42a61a4fbc88303913c4681f0d40ffcc737e70b5;/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/impl/MetricsSystemImpl.java;69;601;https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/metrics2/impl/MetricsSystemImpl.java/#L69-L601;0;"@InterfaceAudience.Private
@Metrics(context=""metricssystem"")
public class MetricsSystemImpl extends MetricsSystem implements MetricsSource {

  static final Log LOG = LogFactory.getLog(MetricsSystemImpl.class);
  static final String MS_NAME = ""MetricsSystem"";
  static final String MS_STATS_NAME = MS_NAME +"",sub=Stats"";
  static final String MS_STATS_DESC = ""Metrics system metrics"";
  static final String MS_CONTROL_NAME = MS_NAME +"",sub=Control"";
  static final String MS_INIT_MODE_KEY = ""hadoop.metrics.init.mode"";

  enum InitMode { NORMAL, STANDBY }

  private final Map<String, MetricsSourceAdapter> sources;
  private final Map<String, MetricsSource> allSources;
  private final Map<String, MetricsSinkAdapter> sinks;
  private final Map<String, MetricsSink> allSinks;
  private final List<Callback> callbacks;
  private final MetricsCollectorImpl collector;
  private final MetricsRegistry registry = new MetricsRegistry(MS_NAME);
  @Metric({""Snapshot"", ""Snapshot stats""}) MutableStat snapshotStat;
  @Metric({""Publish"", ""Publishing stats""}) MutableStat publishStat;
  @Metric(""Dropped updates by all sinks"") MutableCounterLong droppedPubAll;

  private final List<MetricsTag> injectedTags;

  // Things that are changed by init()/start()/stop()
  private String prefix;
  private MetricsFilter sourceFilter;
  private MetricsConfig config;
  private Map<String, MetricsConfig> sourceConfigs, sinkConfigs;
  private boolean monitoring = false;
  private Timer timer;
  private int period; // seconds
  private long logicalTime; // number of timer invocations * period
  private ObjectName mbeanName;
  private boolean publishSelfMetrics = true;
  private MetricsSourceAdapter sysSource;
  private int refCount = 0; // for mini cluster mode

  /**
   * Construct the metrics system
   * @param prefix  for the system
   */
  public MetricsSystemImpl(String prefix) {
    this.prefix = prefix;
    allSources = Maps.newHashMap();
    sources = Maps.newLinkedHashMap();
    allSinks = Maps.newHashMap();
    sinks = Maps.newLinkedHashMap();
    sourceConfigs = Maps.newHashMap();
    sinkConfigs = Maps.newHashMap();
    callbacks = Lists.newArrayList();
    injectedTags = Lists.newArrayList();
    collector = new MetricsCollectorImpl();
    if (prefix != null) {
      // prefix could be null for default ctor, which requires init later
      initSystemMBean();
    }
  }

  /**
   * Construct the system but not initializing (read config etc.) it.
   */
  public MetricsSystemImpl() {
    this(null);
  }

  /**
   * Initialized the metrics system with a prefix.
   * @param prefix  the system will look for configs with the prefix
   * @return the metrics system object itself
   */
  @Override
  public synchronized MetricsSystem init(String prefix) {
    if (monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
      LOG.warn(this.prefix +"" metrics system already initialized!"");
      return this;
    }
    this.prefix = checkNotNull(prefix, ""prefix"");
    ++refCount;
    if (monitoring) {
      // in mini cluster mode
      LOG.info(this.prefix +"" metrics system started (again)"");
      return this;
    }
    switch (initMode()) {
      case NORMAL:
        try { start(); }
        catch (MetricsConfigException e) {
          // Configuration errors (e.g., typos) should not be fatal.
          // We can always start the metrics system later via JMX.
          LOG.warn(""Metrics system not started: ""+ e.getMessage());
          LOG.debug(""Stacktrace: "", e);
        }
        break;
      case STANDBY:
        LOG.info(prefix +"" metrics system started in standby mode"");
    }
    initSystemMBean();
    return this;
  }

  @Override
  public synchronized void start() {
    checkNotNull(prefix, ""prefix"");
    if (monitoring) {
      LOG.warn(prefix +"" metrics system already started!"",
               new MetricsException(""Illegal start""));
      return;
    }
    for (Callback cb : callbacks) cb.preStart();
    configure(prefix);
    startTimer();
    monitoring = true;
    LOG.info(prefix +"" metrics system started"");
    for (Callback cb : callbacks) cb.postStart();
  }

  @Override
  public synchronized void stop() {
    if (!monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
      LOG.warn(prefix +"" metrics system not yet started!"",
               new MetricsException(""Illegal stop""));
      return;
    }
    if (!monitoring) {
      // in mini cluster mode
      LOG.info(prefix +"" metrics system stopped (again)"");
      return;
    }
    for (Callback cb : callbacks) cb.preStop();
    LOG.info(""Stopping ""+ prefix +"" metrics system..."");
    stopTimer();
    stopSources();
    stopSinks();
    clearConfigs();
    monitoring = false;
    LOG.info(prefix +"" metrics system stopped."");
    for (Callback cb : callbacks) cb.postStop();
  }

  @Override public synchronized <T>
  T register(String name, String desc, T source) {
    MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s = sb.build();
    MetricsInfo si = sb.info();
    String name2 = name == null ? si.name() : name;
    final String finalDesc = desc == null ? si.description() : desc;
    final String finalName = // be friendly to non-metrics tests
        DefaultMetricsSystem.sourceName(name2, !monitoring);
    allSources.put(finalName, s);
    LOG.debug(finalName +"", ""+ finalDesc);
    if (monitoring) {
      registerSource(finalName, finalDesc, s);
    }
    // We want to re-register the source to pick up new config when the
    // metrics system restarts.
    register(new AbstractCallback() {
      @Override public void postStart() {
        registerSource(finalName, finalDesc, s);
      }
    });
    return source;
  }

  @Override public synchronized
  void unregisterSource(String name) {
    if (sources.containsKey(name)) {
      sources.get(name).stop();
      sources.remove(name);
    }
    if (allSources.containsKey(name)) {
      allSources.remove(name);
    }
  }

  synchronized
  void registerSource(String name, String desc, MetricsSource source) {
    checkNotNull(config, ""config"");
    MetricsConfig conf = sourceConfigs.get(name);
    MetricsSourceAdapter sa = new MetricsSourceAdapter(prefix, name, desc,
        source, injectedTags, period, conf != null ? conf
            : config.subset(SOURCE_KEY));
    sources.put(name, sa);
    sa.start();
    LOG.debug(""Registered source ""+ name);
  }

  @Override public synchronized <T extends MetricsSink>
  T register(final String name, final String description, final T sink) {
    LOG.debug(name +"", ""+ description);
    if (allSinks.containsKey(name)) {
      LOG.warn(""Sink ""+ name +"" already exists!"");
      return sink;
    }
    allSinks.put(name, sink);
    if (config != null) {
      registerSink(name, description, sink);
    }
    // We want to re-register the sink to pick up new config
    // when the metrics system restarts.
    register(new AbstractCallback() {
      @Override public void postStart() {
        register(name, description, sink);
      }
    });
    return sink;
  }

  synchronized void registerSink(String name, String desc, MetricsSink sink) {
    checkNotNull(config, ""config"");
    MetricsConfig conf = sinkConfigs.get(name);
    MetricsSinkAdapter sa = conf != null
        ? newSink(name, desc, sink, conf)
        : newSink(name, desc, sink, config.subset(SINK_KEY));
    sinks.put(name, sa);
    sa.start();
    LOG.info(""Registered sink ""+ name);
  }

  @Override
  public synchronized void register(final Callback callback) {
    callbacks.add((Callback) Proxy.newProxyInstance(
        callback.getClass().getClassLoader(), new Class<?>[] { Callback.class },
        new InvocationHandler() {
          @Override
          public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable {
            try {
              return method.invoke(callback, args);
            } catch (Exception e) {
              // These are not considered fatal.
              LOG.warn(""Caught exception in callback ""+ method.getName(), e);
            }
            return null;
          }
        }));
  }

  @Override
  public synchronized void startMetricsMBeans() {
    for (MetricsSourceAdapter sa : sources.values()) {
      sa.startMBeans();
    }
  }

  @Override
  public synchronized void stopMetricsMBeans() {
    for (MetricsSourceAdapter sa : sources.values()) {
      sa.stopMBeans();
    }
  }

  @Override
  public synchronized String currentConfig() {
    PropertiesConfiguration saver = new PropertiesConfiguration();
    StringWriter writer = new StringWriter();
    saver.copy(config);
    try { saver.save(writer); }
    catch (Exception e) {
      throw new MetricsConfigException(""Error stringify config"", e);
    }
    return writer.toString();
  }

  private synchronized void startTimer() {
    if (timer != null) {
      LOG.warn(prefix +"" metrics system timer already started!"");
      return;
    }
    logicalTime = 0;
    long millis = period * 1000;
    timer = new Timer(""Timer for '""+ prefix +""' metrics system"", true);
    timer.scheduleAtFixedRate(new TimerTask() {
          @Override
          public void run() {
            try {
              onTimerEvent();
            } catch (Exception e) {
              LOG.warn(e);
            }
          }
        }, millis, millis);
    LOG.info(""Scheduled snapshot period at ""+ period +"" second(s)."");
  }

  synchronized void onTimerEvent() {
    logicalTime += period;
    if (sinks.size() > 0) {
      publishMetrics(sampleMetrics(), false);
    }
  }
  
  /**
   * Requests an immediate publish of all metrics from sources to sinks.
   */
  @Override
  public void publishMetricsNow() {
    if (sinks.size() > 0) {
      publishMetrics(sampleMetrics(), true);
    }    
  }

  /**
   * Sample all the sources for a snapshot of metrics/tags
   * @return  the metrics buffer containing the snapshot
   */
  synchronized MetricsBuffer sampleMetrics() {
    collector.clear();
    MetricsBufferBuilder bufferBuilder = new MetricsBufferBuilder();

    for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
      if (sourceFilter == null || sourceFilter.accepts(entry.getKey())) {
        snapshotMetrics(entry.getValue(), bufferBuilder);
      }
    }
    if (publishSelfMetrics) {
      snapshotMetrics(sysSource, bufferBuilder);
    }
    MetricsBuffer buffer = bufferBuilder.get();
    return buffer;
  }

  private void snapshotMetrics(MetricsSourceAdapter sa,
                               MetricsBufferBuilder bufferBuilder) {
    long startTime = Time.now();
    bufferBuilder.add(sa.name(), sa.getMetrics(collector, true));
    collector.clear();
    snapshotStat.add(Time.now() - startTime);
    LOG.debug(""Snapshotted source ""+ sa.name());
  }

  /**
   * Publish a metrics snapshot to all the sinks
   * @param buffer  the metrics snapshot to publish
   * @param immediate  indicates that we should publish metrics immediately
   *                   instead of using a separate thread.
   */
  synchronized void publishMetrics(MetricsBuffer buffer, boolean immediate) {
    int dropped = 0;
    for (MetricsSinkAdapter sa : sinks.values()) {
      long startTime = Time.now();
      boolean result;
      if (immediate) {
        result = sa.putMetricsImmediate(buffer); 
      } else {
        result = sa.putMetrics(buffer, logicalTime);
      }
      dropped += result ? 0 : 1;
      publishStat.add(Time.now() - startTime);
    }
    droppedPubAll.incr(dropped);
  }

  private synchronized void stopTimer() {
    if (timer == null) {
      LOG.warn(prefix +"" metrics system timer already stopped!"");
      return;
    }
    timer.cancel();
    timer = null;
  }

  private synchronized void stopSources() {
    for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
      MetricsSourceAdapter sa = entry.getValue();
      LOG.debug(""Stopping metrics source ""+ entry.getKey() +
          "": class="" + sa.source().getClass());
      sa.stop();
    }
    sysSource.stop();
    sources.clear();
  }

  private synchronized void stopSinks() {
    for (Entry<String, MetricsSinkAdapter> entry : sinks.entrySet()) {
      MetricsSinkAdapter sa = entry.getValue();
      LOG.debug(""Stopping metrics sink ""+ entry.getKey() +
          "": class="" + sa.sink().getClass());
      sa.stop();
    }
    sinks.clear();
  }

  private synchronized void configure(String prefix) {
    config = MetricsConfig.create(prefix);
    configureSinks();
    configureSources();
    configureSystem();
  }

  private synchronized void configureSystem() {
    injectedTags.add(Interns.tag(MsInfo.Hostname, getHostname()));
  }

  private synchronized void configureSinks() {
    sinkConfigs = config.getInstanceConfigs(SINK_KEY);
    int confPeriod = 0;
    for (Entry<String, MetricsConfig> entry : sinkConfigs.entrySet()) {
      MetricsConfig conf = entry.getValue();
      int sinkPeriod = conf.getInt(PERIOD_KEY, PERIOD_DEFAULT);
      confPeriod = confPeriod == 0 ? sinkPeriod
                                   : ArithmeticUtils.gcd(confPeriod, sinkPeriod);
      String clsName = conf.getClassName("""");
      if (clsName == null) continue;  // sink can be registered later on
      String sinkName = entry.getKey();
      try {
        MetricsSinkAdapter sa = newSink(sinkName,
            conf.getString(DESC_KEY, sinkName), conf);
        sa.start();
        sinks.put(sinkName, sa);
      } catch (Exception e) {
        LOG.warn(""Error creating sink '""+ sinkName +""'"", e);
      }
    }
    period = confPeriod > 0 ? confPeriod
                            : config.getInt(PERIOD_KEY, PERIOD_DEFAULT);
  }

  static MetricsSinkAdapter newSink(String name, String desc, MetricsSink sink,
                                    MetricsConfig conf) {
    return new MetricsSinkAdapter(name, desc, sink, conf.getString(CONTEXT_KEY),
        conf.getFilter(SOURCE_FILTER_KEY),
        conf.getFilter(RECORD_FILTER_KEY),
        conf.getFilter(METRIC_FILTER_KEY),
        conf.getInt(PERIOD_KEY, PERIOD_DEFAULT),
        conf.getInt(QUEUE_CAPACITY_KEY, QUEUE_CAPACITY_DEFAULT),
        conf.getInt(RETRY_DELAY_KEY, RETRY_DELAY_DEFAULT),
        conf.getFloat(RETRY_BACKOFF_KEY, RETRY_BACKOFF_DEFAULT),
        conf.getInt(RETRY_COUNT_KEY, RETRY_COUNT_DEFAULT));
  }

  static MetricsSinkAdapter newSink(String name, String desc,
                                    MetricsConfig conf) {
    return newSink(name, desc, (MetricsSink) conf.getPlugin(""""), conf);
  }

  private void configureSources() {
    sourceFilter = config.getFilter(PREFIX_DEFAULT + SOURCE_FILTER_KEY);
    sourceConfigs = config.getInstanceConfigs(SOURCE_KEY);
    registerSystemSource();
  }

  private void clearConfigs() {
    sinkConfigs.clear();
    sourceConfigs.clear();
    injectedTags.clear();
    config = null;
  }

  static String getHostname() {
    try {
      return InetAddress.getLocalHost().getHostName();
    } catch (Exception e) {
      LOG.error(""Error getting localhost name. Using 'localhost'..."", e);
    }
    return ""localhost"";
  }

  private void registerSystemSource() {
    MetricsConfig sysConf = sourceConfigs.get(MS_NAME);
    sysSource = new MetricsSourceAdapter(prefix, MS_STATS_NAME, MS_STATS_DESC,
        MetricsAnnotations.makeSource(this), injectedTags, period,
        sysConf == null ? config.subset(SOURCE_KEY) : sysConf);
    sysSource.start();
  }

  @Override
  public synchronized void getMetrics(MetricsCollector builder, boolean all) {
    MetricsRecordBuilder rb = builder.addRecord(MS_NAME)
        .addGauge(MsInfo.NumActiveSources, sources.size())
        .addGauge(MsInfo.NumAllSources, allSources.size())
        .addGauge(MsInfo.NumActiveSinks, sinks.size())
        .addGauge(MsInfo.NumAllSinks, allSinks.size());

    for (MetricsSinkAdapter sa : sinks.values()) {
      sa.snapshot(rb, all);
    }
    registry.snapshot(rb, all);
  }

  private void initSystemMBean() {
    checkNotNull(prefix, ""prefix should not be null here!"");
    if (mbeanName == null) {
      mbeanName = MBeans.register(prefix, MS_CONTROL_NAME, this);
    }
  }

  @Override
  public synchronized boolean shutdown() {
    LOG.debug(""refCount=""+ refCount);
    if (refCount <= 0) {
      LOG.debug(""Redundant shutdown"", new Throwable());
      return true; // already shutdown
    }
    if (--refCount > 0) return false;
    if (monitoring) {
      try { stop(); }
      catch (Exception e) {
        LOG.warn(""Error stopping the metrics system"", e);
      }
    }
    allSources.clear();
    allSinks.clear();
    callbacks.clear();
    if (mbeanName != null) {
      MBeans.unregister(mbeanName);
      mbeanName = null;
    }
    LOG.info(prefix +"" metrics system shutdown complete."");
    return true;
  }

  @Override
  public MetricsSource getSource(String name) {
    return allSources.get(name);
  }

  @VisibleForTesting
  MetricsSourceAdapter getSourceAdapter(String name) {
    return sources.get(name);
  }

  private InitMode initMode() {
    LOG.debug(""from system property: ""+ System.getProperty(MS_INIT_MODE_KEY));
    LOG.debug(""from environment variable: ""+ System.getenv(MS_INIT_MODE_KEY));
    String m = System.getProperty(MS_INIT_MODE_KEY);
    String m2 = m == null ? System.getenv(MS_INIT_MODE_KEY) : m;
    return InitMode.valueOf((m2 == null ? InitMode.NORMAL.name() : m2)
                            .toUpperCase(Locale.US));
  }
}"
6382;7;5445165;feature envy;major;2019-04-23 17:18:47.939686;function;org.apache.pulsar.client.impl.ConsumerImpl#getLastMessageIdAsync;git@github.com:apache/pulsar.git;044daf8d61328265640a5b3e5008fc04fac73efa;/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java;1442;1456;https://github.com/apache/pulsar/blob/044daf8d61328265640a5b3e5008fc04fac73efa/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java/#L1442-L1456;1;"    CompletableFuture<MessageId> getLastMessageIdAsync() {
        if (getState() == State.Closing || getState() == State.Closed) {
            return FutureUtil
                .failedFuture(new PulsarClientException.AlreadyClosedException(""Consumer was already closed""));
        }

        AtomicLong opTimeoutMs = new AtomicLong(client.getConfiguration().getOperationTimeoutMs());
        Backoff backoff = new Backoff(100, TimeUnit.MILLISECONDS,
            opTimeoutMs.get() * 2, TimeUnit.MILLISECONDS,
            0 , TimeUnit.MILLISECONDS);
        CompletableFuture<MessageId> getLastMessageIdFuture = new CompletableFuture<>();

        internalGetLastMessageIdAsync(backoff, opTimeoutMs, getLastMessageIdFuture);
        return getLastMessageIdFuture;
    }"
7667;3;5220265;blob;major;2019-07-12 23:48:10.827554;class;org.apache.ode.bpel.compiler.wsdl.WSDLReaderImpl;git@github.com:apache/ode.git;b2ddc6436891f84f716ffcbed8c1cd1e374bd805;/bpel-compiler/src/main/java/org/apache/ode/bpel/compiler/wsdl/WSDLReaderImpl.java;52;177;https://github.com/apache/ode/blob/b2ddc6436891f84f716ffcbed8c1cd1e374bd805/bpel-compiler/src/main/java/org/apache/ode/bpel/compiler/wsdl/WSDLReaderImpl.java/#L52-L177;1;"class WSDLReaderImpl extends com.ibm.wsdl.xml.WSDLReaderImpl {

    private WSDLFactory _localFactory;

    WSDLReaderImpl(WSDLFactory factory) {
        _localFactory = factory;
    }

    @Override
    protected WSDLFactory getWSDLFactory() throws WSDLException {
        return _localFactory;
    }

    @Override
    public Binding parseBinding(Element bindingEl, Definition def) throws WSDLException {
        Binding binding = super.parseBinding(bindingEl, def);
        binding.setDocumentationElement(null);
        return binding;
    }

    @Override
    public BindingFault parseBindingFault(Element bindingFaultEl, Definition def) throws WSDLException {
        BindingFault bindingFault = super.parseBindingFault(bindingFaultEl, def);
        bindingFault.setDocumentationElement(null);
        return bindingFault;
    }

    @Override
    public BindingInput parseBindingInput(Element bindingInputEl, Definition def) throws WSDLException {
        BindingInput bindingInput = super.parseBindingInput(bindingInputEl, def);
        bindingInput.setDocumentationElement(null);
        return bindingInput;
    }

    @Override
    public BindingOperation parseBindingOperation(Element bindingOperationEl, PortType portType, Definition def) throws WSDLException {
        BindingOperation bindingOperation = super.parseBindingOperation(bindingOperationEl, portType, def);
        bindingOperation.setDocumentationElement(null);
        return bindingOperation;
    }

    @Override
    public BindingOutput parseBindingOutput(Element bindingOutputEl, Definition def) throws WSDLException {
        BindingOutput BindingOutput = super.parseBindingOutput(bindingOutputEl, def);
        BindingOutput.setDocumentationElement(null);
        return BindingOutput;
    }

    @SuppressWarnings(""rawtypes"")
    @Override
    public Definition parseDefinitions(String documentBaseURI, Element defEl, Map importedDefs) throws WSDLException {
        Definition definition = super.parseDefinitions(documentBaseURI, defEl, importedDefs);
        definition.setDocumentationElement(null);
        return definition;
    }

    @Override
    public Fault parseFault(Element faultEl, Definition def) throws WSDLException {
        Fault fault = super.parseFault(faultEl, def);
        fault.setDocumentationElement(null);
        return fault;
    }

    @Override
    public Input parseInput(Element inputEl, Definition def) throws WSDLException {
        Input input = super.parseInput(inputEl, def);
        input.setDocumentationElement(null);
        return input;
    }

    @Override
    public Message parseMessage(Element msgEl, Definition def) throws WSDLException {
        Message message = super.parseMessage(msgEl, def);
        message.setDocumentationElement(null);
        return message;
    }

    @Override
    public Operation parseOperation(Element opEl, PortType portType, Definition def) throws WSDLException {
        Operation operation = super.parseOperation(opEl, portType, def);
        operation.setDocumentationElement(null);
        return operation;
    }

    @Override
    public Output parseOutput(Element outputEl, Definition def) throws WSDLException {
        Output output = super.parseOutput(outputEl, def);
        output.setDocumentationElement(null);
        return output;
    }

    @Override
    public Part parsePart(Element partEl, Definition def) throws WSDLException {
        Part part = super.parsePart(partEl, def);
        part.setDocumentationElement(null);
        return part;
    }

    @Override
    public Port parsePort(Element portEl, Definition def) throws WSDLException {
        Port Port = super.parsePort(portEl, def);
        Port.setDocumentationElement(null);
        return Port;
    }

    @Override
    public PortType parsePortType(Element portTypeEl, Definition def) throws WSDLException {
        PortType portType = super.parsePortType(portTypeEl, def);
        portType.setDocumentationElement(null);
        return portType;
    }

    @Override
    public Service parseService(Element serviceEl, Definition def) throws WSDLException {
        Service service = super.parseService(serviceEl, def);
        service.setDocumentationElement(null);
        return service;
    }

    @Override
    public Types parseTypes(Element typesEl, Definition def) throws WSDLException {
        Types types = super.parseTypes(typesEl, def);
        types.setDocumentationElement(null);
        return types;
    }
}"
3845;13;4212572;feature envy;critical;2019-04-05 13:27:51.914915;function;org.apache.commons.beanutils2.PropertyUtils.getPropertyEditorClass Object|String;git@github.com:apache/commons-beanutils.git;33a067788f2a414c0b019f8d8974cc455c1982a4;/src/main/java/org/apache/commons/beanutils2/PropertyUtils.java;458;464;https://github.com/apache/commons-beanutils/blob/33a067788f2a414c0b019f8d8974cc455c1982a4/src/main/java/org/apache/commons/beanutils2/PropertyUtils.java/#L458-L464;1;"    public static Class<?> getPropertyEditorClass(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

        return PropertyUtilsBean.getInstance().getPropertyEditorClass(bean, name);

    }"
3677;20;7633038;data class;major;2019-04-05 13:17:59.478323;class;org.springframework.ide.eclipse.beans.ui.model.properties.ChildBeanProperties.ConfigFilePropertySource;git@github.com:spring-projects/spring-ide.git;915fe9bffd50db45ee0b8fb993416e45dee68179;/plugins/org.springframework.ide.eclipse.beans.ui/src/org/springframework/ide/eclipse/beans/ui/model/properties/ChildBeanProperties.java;154;166;https://github.com/spring-projects/spring-ide/blob/915fe9bffd50db45ee0b8fb993416e45dee68179/plugins/org.springframework.ide.eclipse.beans.ui/src/org/springframework/ide/eclipse/beans/ui/model/properties/ChildBeanProperties.java/#L154-L166;1;"	private class ConfigFilePropertySource extends FilePropertySource {
		private IFile file;

		public ConfigFilePropertySource(IFile file) {
			super(file);
			this.file = file;
		}

		@Override
		public String toString() {
			return file.getFullPath().toString();
		}
	}"
12118;3;5503308;long method;major;2019-08-06 07:42:37.137136;function;org.apache.rocketmq.common.UtilAll.getIP;git@github.com:apache/rocketmq.git;971fa8ed8b209b39bdfe41c57cd64576d244e6bd;/common/src/main/java/org/apache/rocketmq/common/UtilAll.java;484;516;https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/common/src/main/java/org/apache/rocketmq/common/UtilAll.java/#L484-L516;1;"    public static byte[] getIP() {
        try {
            Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();
            InetAddress ip = null;
            byte[] internalIP = null;
            while (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration addresses = netInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    ip = (InetAddress) addresses.nextElement();
                    if (ip != null && ip instanceof Inet4Address) {
                        byte[] ipByte = ip.getAddress();
                        if (ipByte.length == 4) {
                            if (ipCheck(ipByte)) {
                                if (!isInternalIP(ipByte)) {
                                    return ipByte;
                                } else if (internalIP == null) {
                                    internalIP = ipByte;
                                }
                            }
                        }
                    }
                }
            }
            if (internalIP != null) {
                return internalIP;
            } else {
                throw new RuntimeException(""Can not get local ip"");
            }
        } catch (Exception e) {
            throw new RuntimeException(""Can not get local ip"", e);
        }
    }"
3463;5;5515872;long method;none;2019-04-05 13:04:17.532344;function;org.apache.rocketmq.logappender.log4j.RocketmqLog4jAppender.RocketmqLog4jAppender;git@github.com:apache/rocketmq.git;971fa8ed8b209b39bdfe41c57cd64576d244e6bd;/logappender/src/main/java/org/apache/rocketmq/logappender/log4j/RocketmqLog4jAppender.java;59;60;https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/logappender/src/main/java/org/apache/rocketmq/logappender/log4j/RocketmqLog4jAppender.java/#L59-L60;1;"    public RocketmqLog4jAppender() {
    }"
11781;3;7356984;long method;major;2019-08-05 19:53:59.593246;function;com.microsoft.tfs.core.util.TSWAHyperlinkBuilder#formatQueryString String|String[];git@github.com:Microsoft/team-explorer-everywhere.git;89ab2a4847aec8ec2afdf36c3f6287dd03bd558d;/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/util/TSWAHyperlinkBuilder.java;518;559;https://github.com/Microsoft/team-explorer-everywhere/blob/89ab2a4847aec8ec2afdf36c3f6287dd03bd558d/source/com.microsoft.tfs.core/src/com/microsoft/tfs/core/util/TSWAHyperlinkBuilder.java/#L518-L559;1;"    private String formatQueryString(final String projectUri, final String[] args) {
        final StringBuffer result = new StringBuffer();

        if (projectUri != null) {
            if (isCompatibleMode) {
                result.append(""puri=""); //$NON-NLS-1$
                result.append(URLEncode.encode(projectUri.toString()));
            } else {
                final ArtifactID artifactID = new ArtifactID(projectUri);
                result.append(""pguid=""); //$NON-NLS-1$
                result.append(URLEncode.encode(artifactID.getToolSpecificID()));
            }
        } else if (!isCompatibleMode) {
            result.append(""pcguid=""); //$NON-NLS-1$
            result.append(URLEncode.encode(collectionId.toString()));
        }

        for (int i = 0; i < args.length - 1; i += 2) {
            final String name = args[i];
            final String value = args[i + 1];

            if (name != null) {
                if (result.length() > 0) {
                    result.append('&');
                }

                result.append(URLEncode.encode(name));
            }

            if (value != null) {
                if (name != null) {
                    result.append('=');
                } else if (result.length() > 0) {
                    result.append('&');
                }

                result.append(URLEncode.encode(value));
            }
        }

        return result.toString();
    }"
12619;3;6026896;blob;major;2019-08-06 19:55:44.216093;class;org.eclipse.buildship.core.internal.CorePlugin;git@github.com:eclipse/buildship.git;3111a7a9fe3e22d6123366686874ecd42aa2a53a;/org.eclipse.buildship.core/src/main/java/org/eclipse/buildship/core/internal/CorePlugin.java;70;282;https://github.com/eclipse/buildship/blob/3111a7a9fe3e22d6123366686874ecd42aa2a53a/org.eclipse.buildship.core/src/main/java/org/eclipse/buildship/core/internal/CorePlugin.java/#L70-L282;1;"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public final class CorePlugin extends Plugin {

    public static final String PLUGIN_ID = ""org.eclipse.buildship.core""; //$NON-NLS-1$

    public static final String GRADLE_JOB_FAMILY = PLUGIN_ID + "".jobs"";

    private static CorePlugin plugin;

    // do not use generics-aware signature since this causes compilation troubles (JDK, Spock)
    // search the web for -target jsr14 to find out more about this obscurity
    private ServiceRegistration loggerService;
    private ServiceRegistration publishedGradleVersionsService;
    private ServiceRegistration workspaceOperationsService;
    private ServiceRegistration internalGradleWorkspaceService;
    private ServiceRegistration processStreamsProviderService;
    private ServiceRegistration gradleLaunchConfigurationService;
    private ServiceRegistration listenerRegistryService;

    // service tracker for each service to allow to register other service implementations of the
    // same type but with higher prioritization, useful for testing
    private ServiceTracker loggerServiceTracker;
    private ServiceTracker publishedGradleVersionsServiceTracker;
    private ServiceTracker workspaceOperationsServiceTracker;
    private ServiceTracker internalGradleWorkspaceServiceTracker;
    private ServiceTracker processStreamsProviderServiceTracker;
    private ServiceTracker gradleLaunchConfigurationServiceTracker;
    private ServiceTracker listenerRegistryServiceTracker;

    private DefaultModelPersistence modelPersistence;
    private ProjectChangeListener projectChangeListener;
    private SynchronizingBuildScriptUpdateListener buildScriptUpdateListener;
    private InvocationCustomizer invocationCustomizer;
    private ConfigurationManager configurationManager;
    private DefaultExternalLaunchConfigurationManager externalLaunchConfigurationManager;
    private ToolingApiOperationManager operationManager;
    private ExtensionManager extensionManager;

    @Override
    public void start(BundleContext bundleContext) throws Exception {
        super.start(bundleContext);
        plugin = this;
        ensureProxySettingsApplied();
        registerServices(bundleContext);
    }

    @Override
    public void stop(BundleContext context) throws Exception {
        unregisterServices();
        plugin = null;
        super.stop(context);
    }

    private void ensureProxySettingsApplied() throws Exception {
        // the proxy settings are set when the core.net plugin is started
        Platform.getBundle(""org.eclipse.core.net"").start(Bundle.START_TRANSIENT);
    }

    private void registerServices(BundleContext context) {
        // store services with low ranking such that they can be overridden
        // during testing or the like
        Dictionary<String, Object> preferences = new Hashtable<>();
        preferences.put(Constants.SERVICE_RANKING, 1);

        // initialize service trackers before the services are created
        this.loggerServiceTracker = createServiceTracker(context, Logger.class);
        this.publishedGradleVersionsServiceTracker = createServiceTracker(context, PublishedGradleVersionsWrapper.class);
        this.workspaceOperationsServiceTracker = createServiceTracker(context, WorkspaceOperations.class);
        this.internalGradleWorkspaceServiceTracker = createServiceTracker(context, InternalGradleWorkspace.class);
        this.processStreamsProviderServiceTracker = createServiceTracker(context, ProcessStreamsProvider.class);
        this.gradleLaunchConfigurationServiceTracker = createServiceTracker(context, GradleLaunchConfigurationManager.class);
        this.listenerRegistryServiceTracker = createServiceTracker(context, ListenerRegistry.class);

        // register all services
        this.loggerService = registerService(context, Logger.class, createLogger(), preferences);
        this.publishedGradleVersionsService = registerService(context, PublishedGradleVersionsWrapper.class, createPublishedGradleVersions(), preferences);
        this.workspaceOperationsService = registerService(context, WorkspaceOperations.class, createWorkspaceOperations(), preferences);
        this.internalGradleWorkspaceService = registerService(context, InternalGradleWorkspace.class, createGradleWorkspace(), preferences);
        this.processStreamsProviderService = registerService(context, ProcessStreamsProvider.class, createProcessStreamsProvider(), preferences);
        this.gradleLaunchConfigurationService = registerService(context, GradleLaunchConfigurationManager.class, createGradleLaunchConfigurationManager(), preferences);
        this.listenerRegistryService = registerService(context, ListenerRegistry.class, createListenerRegistry(), preferences);

        this.modelPersistence = DefaultModelPersistence.createAndRegister();
        this.projectChangeListener = ProjectChangeListener.createAndRegister();
        this.buildScriptUpdateListener = SynchronizingBuildScriptUpdateListener.createAndRegister();
        this.invocationCustomizer = new InvocationCustomizerCollector();
        this.configurationManager = new DefaultConfigurationManager();
        this.externalLaunchConfigurationManager = DefaultExternalLaunchConfigurationManager.createAndRegister();
        this.operationManager = new DefaultToolingApiOperationManager();
        this.extensionManager = new DefaultExtensionManager();
    }

    private ServiceTracker createServiceTracker(BundleContext context, Class<?> clazz) {
        ServiceTracker serviceTracker = new ServiceTracker(context, clazz.getName(), null);
        serviceTracker.open();
        return serviceTracker;
    }

    private <T> ServiceRegistration registerService(BundleContext context, Class<T> clazz, T service, Dictionary<String, Object> properties) {
        return context.registerService(clazz.getName(), service, properties);
    }

    private EclipseLogger createLogger() {
        Map<TraceScope, Boolean> tracingEnablement = Maps.newHashMap();
        for (TraceScope scope : CoreTraceScopes.values()) {
            String option = Platform.getDebugOption(""org.eclipse.buildship.core/trace/"" + scope.getScopeKey());
            tracingEnablement.put(scope, ""true"".equalsIgnoreCase(option));
        }
        return new EclipseLogger(getLog(), PLUGIN_ID, tracingEnablement);
    }

    private PublishedGradleVersionsWrapper createPublishedGradleVersions() {
        return new PublishedGradleVersionsWrapper();
    }

    private WorkspaceOperations createWorkspaceOperations() {
        return new DefaultWorkspaceOperations();
    }

    private InternalGradleWorkspace createGradleWorkspace() {
        return new DefaultGradleWorkspace();
    }

    private ProcessStreamsProvider createProcessStreamsProvider() {
        return new StdProcessStreamsProvider();
    }

    private GradleLaunchConfigurationManager createGradleLaunchConfigurationManager() {
        return new DefaultGradleLaunchConfigurationManager();
    }

    private ListenerRegistry createListenerRegistry() {
        return new DefaultListenerRegistry();
    }

    private void unregisterServices() {
        this.externalLaunchConfigurationManager.unregister();
        this.buildScriptUpdateListener.close();
        this.projectChangeListener.close();
        this.modelPersistence.close();
        this.listenerRegistryService.unregister();
        this.gradleLaunchConfigurationService.unregister();
        this.processStreamsProviderService.unregister();
        this.internalGradleWorkspaceService.unregister();
        this.workspaceOperationsService.unregister();
        this.publishedGradleVersionsService.unregister();
        this.loggerService.unregister();

        this.listenerRegistryServiceTracker.close();
        this.gradleLaunchConfigurationServiceTracker.close();
        this.processStreamsProviderServiceTracker.close();
        this.internalGradleWorkspaceServiceTracker.close();
        this.workspaceOperationsServiceTracker.close();
        this.publishedGradleVersionsServiceTracker.close();
        this.loggerServiceTracker.close();
    }

    public static CorePlugin getInstance() {
        return plugin;
    }

    public static Logger logger() {
        return (Logger) getInstance().loggerServiceTracker.getService();
    }

    public static PublishedGradleVersionsWrapper publishedGradleVersions() {
        return (PublishedGradleVersionsWrapper) getInstance().publishedGradleVersionsServiceTracker.getService();
    }

    public static WorkspaceOperations workspaceOperations() {
        return (WorkspaceOperations) getInstance().workspaceOperationsServiceTracker.getService();
    }

    public static InternalGradleWorkspace internalGradleWorkspace() {
        return (InternalGradleWorkspace) getInstance().internalGradleWorkspaceServiceTracker.getService();
    }

    public static ProcessStreamsProvider processStreamsProvider() {
        return (ProcessStreamsProvider) getInstance().processStreamsProviderServiceTracker.getService();
    }

    public static GradleLaunchConfigurationManager gradleLaunchConfigurationManager() {
        return (GradleLaunchConfigurationManager) getInstance().gradleLaunchConfigurationServiceTracker.getService();
    }

    public static ListenerRegistry listenerRegistry() {
        return (ListenerRegistry) getInstance().listenerRegistryServiceTracker.getService();
    }

    public static ModelPersistence modelPersistence() {
        return getInstance().modelPersistence;
    }

    public static InvocationCustomizer invocationCustomizer() {
        return getInstance().invocationCustomizer;
    }

    public static ConfigurationManager configurationManager() {
        return getInstance().configurationManager;
    }

    public static ExternalLaunchConfigurationManager externalLaunchConfigurationManager() {
        return getInstance().externalLaunchConfigurationManager;
    }

    public static ToolingApiOperationManager operationManager() {
        return getInstance().operationManager;
    }

    public static ExtensionManager extensionManager() {
        return getInstance().extensionManager;
    }
}"
4563;5;6026896;blob;major;2019-04-12 13:07:36.484508;class;org.eclipse.buildship.core.internal.CorePlugin;git@github.com:eclipse/buildship.git;3111a7a9fe3e22d6123366686874ecd42aa2a53a;/org.eclipse.buildship.core/src/main/java/org/eclipse/buildship/core/internal/CorePlugin.java;70;282;https://github.com/eclipse/buildship/blob/3111a7a9fe3e22d6123366686874ecd42aa2a53a/org.eclipse.buildship.core/src/main/java/org/eclipse/buildship/core/internal/CorePlugin.java/#L70-L282;1;"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public final class CorePlugin extends Plugin {

    public static final String PLUGIN_ID = ""org.eclipse.buildship.core""; //$NON-NLS-1$

    public static final String GRADLE_JOB_FAMILY = PLUGIN_ID + "".jobs"";

    private static CorePlugin plugin;

    // do not use generics-aware signature since this causes compilation troubles (JDK, Spock)
    // search the web for -target jsr14 to find out more about this obscurity
    private ServiceRegistration loggerService;
    private ServiceRegistration publishedGradleVersionsService;
    private ServiceRegistration workspaceOperationsService;
    private ServiceRegistration internalGradleWorkspaceService;
    private ServiceRegistration processStreamsProviderService;
    private ServiceRegistration gradleLaunchConfigurationService;
    private ServiceRegistration listenerRegistryService;

    // service tracker for each service to allow to register other service implementations of the
    // same type but with higher prioritization, useful for testing
    private ServiceTracker loggerServiceTracker;
    private ServiceTracker publishedGradleVersionsServiceTracker;
    private ServiceTracker workspaceOperationsServiceTracker;
    private ServiceTracker internalGradleWorkspaceServiceTracker;
    private ServiceTracker processStreamsProviderServiceTracker;
    private ServiceTracker gradleLaunchConfigurationServiceTracker;
    private ServiceTracker listenerRegistryServiceTracker;

    private DefaultModelPersistence modelPersistence;
    private ProjectChangeListener projectChangeListener;
    private SynchronizingBuildScriptUpdateListener buildScriptUpdateListener;
    private InvocationCustomizer invocationCustomizer;
    private ConfigurationManager configurationManager;
    private DefaultExternalLaunchConfigurationManager externalLaunchConfigurationManager;
    private ToolingApiOperationManager operationManager;
    private ExtensionManager extensionManager;

    @Override
    public void start(BundleContext bundleContext) throws Exception {
        super.start(bundleContext);
        plugin = this;
        ensureProxySettingsApplied();
        registerServices(bundleContext);
    }

    @Override
    public void stop(BundleContext context) throws Exception {
        unregisterServices();
        plugin = null;
        super.stop(context);
    }

    private void ensureProxySettingsApplied() throws Exception {
        // the proxy settings are set when the core.net plugin is started
        Platform.getBundle(""org.eclipse.core.net"").start(Bundle.START_TRANSIENT);
    }

    private void registerServices(BundleContext context) {
        // store services with low ranking such that they can be overridden
        // during testing or the like
        Dictionary<String, Object> preferences = new Hashtable<>();
        preferences.put(Constants.SERVICE_RANKING, 1);

        // initialize service trackers before the services are created
        this.loggerServiceTracker = createServiceTracker(context, Logger.class);
        this.publishedGradleVersionsServiceTracker = createServiceTracker(context, PublishedGradleVersionsWrapper.class);
        this.workspaceOperationsServiceTracker = createServiceTracker(context, WorkspaceOperations.class);
        this.internalGradleWorkspaceServiceTracker = createServiceTracker(context, InternalGradleWorkspace.class);
        this.processStreamsProviderServiceTracker = createServiceTracker(context, ProcessStreamsProvider.class);
        this.gradleLaunchConfigurationServiceTracker = createServiceTracker(context, GradleLaunchConfigurationManager.class);
        this.listenerRegistryServiceTracker = createServiceTracker(context, ListenerRegistry.class);

        // register all services
        this.loggerService = registerService(context, Logger.class, createLogger(), preferences);
        this.publishedGradleVersionsService = registerService(context, PublishedGradleVersionsWrapper.class, createPublishedGradleVersions(), preferences);
        this.workspaceOperationsService = registerService(context, WorkspaceOperations.class, createWorkspaceOperations(), preferences);
        this.internalGradleWorkspaceService = registerService(context, InternalGradleWorkspace.class, createGradleWorkspace(), preferences);
        this.processStreamsProviderService = registerService(context, ProcessStreamsProvider.class, createProcessStreamsProvider(), preferences);
        this.gradleLaunchConfigurationService = registerService(context, GradleLaunchConfigurationManager.class, createGradleLaunchConfigurationManager(), preferences);
        this.listenerRegistryService = registerService(context, ListenerRegistry.class, createListenerRegistry(), preferences);

        this.modelPersistence = DefaultModelPersistence.createAndRegister();
        this.projectChangeListener = ProjectChangeListener.createAndRegister();
        this.buildScriptUpdateListener = SynchronizingBuildScriptUpdateListener.createAndRegister();
        this.invocationCustomizer = new InvocationCustomizerCollector();
        this.configurationManager = new DefaultConfigurationManager();
        this.externalLaunchConfigurationManager = DefaultExternalLaunchConfigurationManager.createAndRegister();
        this.operationManager = new DefaultToolingApiOperationManager();
        this.extensionManager = new DefaultExtensionManager();
    }

    private ServiceTracker createServiceTracker(BundleContext context, Class<?> clazz) {
        ServiceTracker serviceTracker = new ServiceTracker(context, clazz.getName(), null);
        serviceTracker.open();
        return serviceTracker;
    }

    private <T> ServiceRegistration registerService(BundleContext context, Class<T> clazz, T service, Dictionary<String, Object> properties) {
        return context.registerService(clazz.getName(), service, properties);
    }

    private EclipseLogger createLogger() {
        Map<TraceScope, Boolean> tracingEnablement = Maps.newHashMap();
        for (TraceScope scope : CoreTraceScopes.values()) {
            String option = Platform.getDebugOption(""org.eclipse.buildship.core/trace/"" + scope.getScopeKey());
            tracingEnablement.put(scope, ""true"".equalsIgnoreCase(option));
        }
        return new EclipseLogger(getLog(), PLUGIN_ID, tracingEnablement);
    }

    private PublishedGradleVersionsWrapper createPublishedGradleVersions() {
        return new PublishedGradleVersionsWrapper();
    }

    private WorkspaceOperations createWorkspaceOperations() {
        return new DefaultWorkspaceOperations();
    }

    private InternalGradleWorkspace createGradleWorkspace() {
        return new DefaultGradleWorkspace();
    }

    private ProcessStreamsProvider createProcessStreamsProvider() {
        return new StdProcessStreamsProvider();
    }

    private GradleLaunchConfigurationManager createGradleLaunchConfigurationManager() {
        return new DefaultGradleLaunchConfigurationManager();
    }

    private ListenerRegistry createListenerRegistry() {
        return new DefaultListenerRegistry();
    }

    private void unregisterServices() {
        this.externalLaunchConfigurationManager.unregister();
        this.buildScriptUpdateListener.close();
        this.projectChangeListener.close();
        this.modelPersistence.close();
        this.listenerRegistryService.unregister();
        this.gradleLaunchConfigurationService.unregister();
        this.processStreamsProviderService.unregister();
        this.internalGradleWorkspaceService.unregister();
        this.workspaceOperationsService.unregister();
        this.publishedGradleVersionsService.unregister();
        this.loggerService.unregister();

        this.listenerRegistryServiceTracker.close();
        this.gradleLaunchConfigurationServiceTracker.close();
        this.processStreamsProviderServiceTracker.close();
        this.internalGradleWorkspaceServiceTracker.close();
        this.workspaceOperationsServiceTracker.close();
        this.publishedGradleVersionsServiceTracker.close();
        this.loggerServiceTracker.close();
    }

    public static CorePlugin getInstance() {
        return plugin;
    }

    public static Logger logger() {
        return (Logger) getInstance().loggerServiceTracker.getService();
    }

    public static PublishedGradleVersionsWrapper publishedGradleVersions() {
        return (PublishedGradleVersionsWrapper) getInstance().publishedGradleVersionsServiceTracker.getService();
    }

    public static WorkspaceOperations workspaceOperations() {
        return (WorkspaceOperations) getInstance().workspaceOperationsServiceTracker.getService();
    }

    public static InternalGradleWorkspace internalGradleWorkspace() {
        return (InternalGradleWorkspace) getInstance().internalGradleWorkspaceServiceTracker.getService();
    }

    public static ProcessStreamsProvider processStreamsProvider() {
        return (ProcessStreamsProvider) getInstance().processStreamsProviderServiceTracker.getService();
    }

    public static GradleLaunchConfigurationManager gradleLaunchConfigurationManager() {
        return (GradleLaunchConfigurationManager) getInstance().gradleLaunchConfigurationServiceTracker.getService();
    }

    public static ListenerRegistry listenerRegistry() {
        return (ListenerRegistry) getInstance().listenerRegistryServiceTracker.getService();
    }

    public static ModelPersistence modelPersistence() {
        return getInstance().modelPersistence;
    }

    public static InvocationCustomizer invocationCustomizer() {
        return getInstance().invocationCustomizer;
    }

    public static ConfigurationManager configurationManager() {
        return getInstance().configurationManager;
    }

    public static ExternalLaunchConfigurationManager externalLaunchConfigurationManager() {
        return getInstance().externalLaunchConfigurationManager;
    }

    public static ToolingApiOperationManager operationManager() {
        return getInstance().operationManager;
    }

    public static ExtensionManager extensionManager() {
        return getInstance().extensionManager;
    }
}"
740;13;6306007;long method;none;2019-03-29 12:38:49.805727;function;org.eclipse.leshan.core.node.ObjectLink#getObjectId;git@github.com:eclipse/leshan.git;eb75fc8b7d5560944e6d532f1a09d5e5c6e54559;/leshan-core/src/main/java/org/eclipse/leshan/core/node/ObjectLink.java;71;73;https://github.com/eclipse/leshan/blob/eb75fc8b7d5560944e6d532f1a09d5e5c6e54559/leshan-core/src/main/java/org/eclipse/leshan/core/node/ObjectLink.java/#L71-L73;1;"    public int getObjectId() {
        return objectId;
    }"
10123;13;4043845;data class;major;2019-07-25 12:57:50.046896;class;org.apache.asterix.common.config.BuildProperties;git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/asterixdb/asterix-common/src/main/java/org/apache/asterix/common/config/BuildProperties.java;24;34;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-common/src/main/java/org/apache/asterix/common/config/BuildProperties.java/#L24-L34;1;"public class BuildProperties extends AbstractProperties {

    public BuildProperties(PropertiesAccessor accessor) {
        super(accessor);
    }

    public Map<String, String> getAllProps() {
        return accessor.getBuildProperties();
    }

}"
1185;11;7210083;data class;critical;2019-03-29 13:34:53.270468;class;oracle.kubernetes.operator.helpers.CallBuilder.RequestParamsBuilder;git@github.com:oracle/weblogic-kubernetes-operator.git;1fb059d7e32b9b3514617d54e4dda41ab68e71ea;/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java;179;191;https://github.com/oracle/weblogic-kubernetes-operator/blob/1fb059d7e32b9b3514617d54e4dda41ab68e71ea/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java/#L179-L191;1;"  abstract static class RequestParamsBuilder<T> {
    T body;

    public RequestParamsBuilder(T body) {
      this.body = body;
    }

    abstract RequestParams buildRequestParams();

    void setBody(T body) {
      this.body = body;
    }
  }"
2693;3;4643718;data class;none;2019-04-02 06:53:41.822400;class;org.apache.flink.runtime.state.internal.InternalFoldingState;git@github.com:apache/flink.git;8068c8775ad067d75828e6360e7e0994348da9b9;/flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalFoldingState.java;35;36;https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalFoldingState.java/#L35-L36;1;"@Deprecated
public interface InternalFoldingState<K, N, T, ACC> extends InternalAppendingState<K, N, T, ACC, ACC>, FoldingState<T, ACC> {}"
10129;13;6923170;feature envy;critical;2019-07-25 13:39:51.570061;function;com.google.googlejavaformat.Doc.Tok#computeBreaks CommentsHelper|int|State;git@github.com:google/google-java-format.git;df76e0c7fe82711c8600768fca19d0ebaf2ca3d2;/core/src/main/java/com/google/googlejavaformat/Doc.java;753;758;https://github.com/google/google-java-format/blob/df76e0c7fe82711c8600768fca19d0ebaf2ca3d2/core/src/main/java/com/google/googlejavaformat/Doc.java/#L753-L758;0,5;"    @Override
    public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
      text = commentsHelper.rewrite(tok, maxWidth, state.column);
      int firstLineLength = text.length() - Iterators.getLast(Newlines.lineOffsetIterator(text));
      return state.withColumn(state.column + firstLineLength);
    }"
761;4;6329948;feature envy;major;2019-03-29 13:07:50.535716;function;org.eclipse.kapua.service.authorization.group.shiro.GroupServiceImpl#onKapuaEvent ServiceEvent;git@github.com:eclipse/kapua.git;11e610c657f7e473b52882833e33a2261bd3d67d;/service/security/shiro/src/main/java/org/eclipse/kapua/service/authorization/group/shiro/GroupServiceImpl.java;203;212;https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/service/security/shiro/src/main/java/org/eclipse/kapua/service/authorization/group/shiro/GroupServiceImpl.java/#L203-L212;1;"    public void onKapuaEvent(ServiceEvent kapuaEvent) throws KapuaException {
        if (kapuaEvent == null) {
            //service bus error. Throw some exception?
        }

        LOG.info(""GroupService: received kapua event from {}, operation {}"", kapuaEvent.getService(), kapuaEvent.getOperation());
        if (""account"".equals(kapuaEvent.getService()) && ""delete"".equals(kapuaEvent.getOperation())) {
            deleteGroupByAccountId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId());
        }
    }"
679;7;6183429;feature envy;major;2019-03-27 11:07:12.693485;function;org.eclipse.che.ide.util.dom.DomUtils.getSiblingIndexWithClassName Element|String;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/ide/commons-gwt/src/main/java/org/eclipse/che/ide/util/dom/DomUtils.java;171;180;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/commons-gwt/src/main/java/org/eclipse/che/ide/util/dom/DomUtils.java/#L171-L180;1;"  public static int getSiblingIndexWithClassName(Element element, String className) {
    int index = 0;
    while (element != null) {
      element = (Element) element.getPreviousSibling();
      if (element != null && Elements.hasClassName(className, element)) {
        ++index;
      }
    }
    return index;
  }"
5609;6;4756088;feature envy;major;2019-04-16 18:29:17.558575;function;org.apache.gobblin.util.AvroUtils.removeUncomparableFieldsFromRecord Schema|Set<Schema>;git@github.com:apache/incubator-gobblin.git;b0d130757669a5fed7c368d44f23f8a9c0d3ed4a;/gobblin-utility/src/main/java/org/apache/gobblin/util/AvroUtils.java;615;634;https://github.com/apache/incubator-gobblin/blob/b0d130757669a5fed7c368d44f23f8a9c0d3ed4a/gobblin-utility/src/main/java/org/apache/gobblin/util/AvroUtils.java/#L615-L634;1;"  private static Optional<Schema> removeUncomparableFieldsFromRecord(Schema record, Set<Schema> processed) {
    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);

    if (processed.contains(record)) {
      return Optional.absent();
    }
    processed.add(record);

    List<Field> fields = Lists.newArrayList();
    for (Field field : record.getFields()) {
      Optional<Schema> newFieldSchema = removeUncomparableFields(field.schema(), processed);
      if (newFieldSchema.isPresent()) {
        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));
      }
    }

    Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getNamespace(), false);
    newSchema.setFields(fields);
    return Optional.of(newSchema);
  }"
2181;3;8905404;data class;none;2019-04-01 13:23:27.495412;class;org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore.create_type_args.create_type_argsStandardSchemeFactory;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java;47633;47637;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java/#L47633-L47637;1;"    private static class create_type_argsStandardSchemeFactory implements SchemeFactory {
      public create_type_argsStandardScheme getScheme() {
        return new create_type_argsStandardScheme();
      }
    }"
14754;4;5515226;blob;none;2019-09-12 08:47:17.757262;class;org.apache.rocketmq.common.constant.DBMsgConstants;git@github.com:apache/rocketmq.git;971fa8ed8b209b39bdfe41c57cd64576d244e6bd;/common/src/main/java/org/apache/rocketmq/common/constant/DBMsgConstants.java;20;22;https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/common/src/main/java/org/apache/rocketmq/common/constant/DBMsgConstants.java/#L20-L22;1;"public class DBMsgConstants {
    public static final int MAX_BODY_SIZE = 64 * 1024 * 1024; //64KB
}"
1573;12;7725777;data class;critical;2019-03-29 14:00:50.945935;class;com.vmware.admiral.request.notification.NotificationsService.NotificationsAggregatorState;git@github.com:vmware/admiral.git;e02d0e77f65d0ee3541a378110ecd4233bdb6664;/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java;52;55;https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55;1;"    public static class NotificationsAggregatorState {
        public long recentEventLogsCount;
        public long activeRequestsCount;
    }"
1535;17;7657534;data class;major;2019-03-29 13:57:07.108192;class;org.springframework.vault.core.VaultSysTemplate.VaultInitializationResponseImpl;git@github.com:spring-projects/spring-vault.git;6e36eb10b02c6931c3b565c5d9d76f5e217bf309;/spring-vault-core/src/main/java/org/springframework/vault/core/VaultSysTemplate.java;414;425;https://github.com/spring-projects/spring-vault/blob/6e36eb10b02c6931c3b565c5d9d76f5e217bf309/spring-vault-core/src/main/java/org/springframework/vault/core/VaultSysTemplate.java/#L414-L425;1;"	@Data
	static class VaultInitializationResponseImpl implements VaultInitializationResponse {

		private List<String> keys = new ArrayList<>();

		@JsonProperty(""root_token"")
		private String rootToken = """";

		public VaultToken getRootToken() {
			return VaultToken.of(rootToken);
		}
	}"
698;7;6212333;long method;none;2019-03-27 11:13:13.589700;function;org.eclipse.che.ide.api.editor.events.GutterClickEvent#getEvent;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/events/GutterClickEvent.java;76;78;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/events/GutterClickEvent.java/#L76-L78;1;"  public MouseEvent getEvent() {
    return event;
  }"
2821;5;3822072;data class;none;2019-04-05 12:13:34.515796;class;org.apache.accumulo.tserver.tablet.Compactor.CompactionCanceledException;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/Compactor.java;76;78;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/Compactor.java/#L76-L78;1;"  public static class CompactionCanceledException extends Exception {
    private static final long serialVersionUID = 1L;
  }"
620;6;5939683;long method;none;2019-03-27 10:54:02.543909;function;org.apache.openejb.config.RemoteServer#setPortStartup int;git@github.com:apache/tomee.git;d21933b313aff812fe5188b57bf572a9ad649148;/container/openejb-core/src/main/java/org/apache/openejb/config/RemoteServer.java;141;143;https://github.com/apache/tomee/blob/d21933b313aff812fe5188b57bf572a9ad649148/container/openejb-core/src/main/java/org/apache/openejb/config/RemoteServer.java/#L141-L143;1;"    public void setPortStartup(final int portStartup) {
        this.portStartup = portStartup;
    }"
3864;4;5416350;long method;major;2019-04-05 13:29:23.028924;function;org.apache.phoenix.end2end.BaseAggregateIT#testGroupByOrderPreservingDescSort;git@github.com:apache/phoenix.git;69e5bb0b304a53967cef40b2a4cfc66e69ecaa51;/phoenix-core/src/it/java/org/apache/phoenix/end2end/BaseAggregateIT.java;386;427;https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/it/java/org/apache/phoenix/end2end/BaseAggregateIT.java/#L386-L427;1;"    @Test
    public void testGroupByOrderPreservingDescSort() throws Exception {
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(getUrl(), props);
        String tableName = generateUniqueName();
        conn.createStatement().execute(""CREATE TABLE "" + tableName + "" (k1 char(1) not null, k2 char(1) not null,"" +
                "" constraint pk primary key (k1,k2)) split on ('ac','jc','nc')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'a')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'b')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'c')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('a', 'd')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'a')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'b')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'c')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('j', 'd')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'a')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'b')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'c')"");
        conn.createStatement().execute(""UPSERT INTO "" + tableName + "" VALUES('n', 'd')"");
        conn.commit();
        QueryBuilder queryBuilder = new QueryBuilder()
            .setSelectExpression(""K1,COUNT(*)"")
            .setSelectColumns(Lists.newArrayList(""K1""))
            .setFullTableName(tableName)
            .setGroupByClause(""K1"")
            .setOrderByClause(""K1 DESC"");
        ResultSet rs = executeQuery(conn, queryBuilder);
        assertTrue(rs.next());
        assertEquals(""n"", rs.getString(1));
        assertEquals(4, rs.getLong(2));
        assertTrue(rs.next());
        assertEquals(""j"", rs.getString(1));
        assertEquals(4, rs.getLong(2));
        assertTrue(rs.next());
        assertEquals(""a"", rs.getString(1));
        assertEquals(4, rs.getLong(2));
        assertFalse(rs.next());
        String expectedPhoenixPlan = ""CLIENT PARALLEL 1-WAY REVERSE FULL SCAN OVER "" + tableName + ""\n"" +
                ""    SERVER FILTER BY FIRST KEY ONLY\n"" +
                ""    SERVER AGGREGATE INTO ORDERED DISTINCT ROWS BY [K1]"";
        validateQueryPlan(conn, queryBuilder, expectedPhoenixPlan, null);
    }"
4255;7;4395308;feature envy;major;2019-04-10 09:40:50.430303;function;org.apache.cxf.wsn.client.CreatePullPoint#create String;git@github.com:apache/cxf.git;6bf89e9c8804c8845ec4d38583dd33eea8256439;/services/wsn/wsn-api/src/main/java/org/apache/cxf/wsn/client/CreatePullPoint.java;58;64;https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/services/wsn/wsn-api/src/main/java/org/apache/cxf/wsn/client/CreatePullPoint.java/#L58-L64;1;"    public PullPoint create(String queueName) throws UnableToCreatePullPointFault {
        org.oasis_open.docs.wsn.b_2.CreatePullPoint request
            = new org.oasis_open.docs.wsn.b_2.CreatePullPoint();
        request.getOtherAttributes().put(NotificationBroker.QNAME_PULLPOINT_QUEUE_NAME, queueName);
        CreatePullPointResponse response = createPullPoint.createPullPoint(request);
        return new PullPoint(response.getPullPoint());
    }"
1959;16;3879673;long method;none;2019-03-29 18:05:17.755735;function;org.apache.ambari.server.audit.event.request.DeleteAlertGroupRequestAuditEvent.DeleteAlertGroupRequestAuditEvent;git@github.com:apache/ambari.git;2bc4779a1e6aabe638101fc8b0e28cd1963d6b13;/ambari-server/src/main/java/org/apache/ambari/server/audit/event/request/DeleteAlertGroupRequestAuditEvent.java;68;69;https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/ambari-server/src/main/java/org/apache/ambari/server/audit/event/request/DeleteAlertGroupRequestAuditEvent.java/#L68-L69;1;"  protected DeleteAlertGroupRequestAuditEvent() {
  }"
10719;13;5392183;blob;critical;2019-07-26 13:38:31.235411;class;org.apache.openejb.cdi.CurrentCreationalContext;git@github.com:apache/openejb.git;f10c077ade927d73bdbd9ed4cc28b79f58a1cd66;/openejb/container/openejb-core/src/main/java/org/apache/openejb/cdi/CurrentCreationalContext.java;24;38;https://github.com/apache/openejb/blob/f10c077ade927d73bdbd9ed4cc28b79f58a1cd66/openejb/container/openejb-core/src/main/java/org/apache/openejb/cdi/CurrentCreationalContext.java/#L24-L38;0;"public final class CurrentCreationalContext<T> {
    private final ThreadLocal<CreationalContext<T>> creationalContext = new ThreadLocal<CreationalContext<T>>();

    public CreationalContext<T> get() {
        return creationalContext.get();
    }

    public void set(CreationalContext<T> value) {
        creationalContext.set(value);
    }

    public void remove() {
        creationalContext.remove();
    }
}"
12950;20;3917715;data class;major;2019-08-16 13:31:14.570097;class;org.apache.archiva.rest.api.model.ArtifactTransferRequest;git@github.com:apache/archiva.git;d1242030bf232c0d9b68e4402188ee261924bf4b;/archiva-modules/archiva-web/archiva-rest/archiva-rest-api/src/main/java/org/apache/archiva/rest/api/model/ArtifactTransferRequest.java;29;45;https://github.com/apache/archiva/blob/d1242030bf232c0d9b68e4402188ee261924bf4b/archiva-modules/archiva-web/archiva-rest/archiva-rest-api/src/main/java/org/apache/archiva/rest/api/model/ArtifactTransferRequest.java/#L29-L45;1;"@XmlRootElement( name = ""artifactTransferRequest"" )
public class ArtifactTransferRequest
    extends Artifact
    implements Serializable
{
    private String targetRepositoryId;

    public String getTargetRepositoryId()
    {
        return targetRepositoryId;
    }

    public void setTargetRepositoryId( String targetRepositoryId )
    {
        this.targetRepositoryId = targetRepositoryId;
    }
}"
6757;3;7108130;long method;major;2019-05-20 09:26:34.101021;function;java.util.Base64.Encoder#encode0 byte[]|int|int|byte[];git@github.com:google/j2objc.git;471504a735b48d5d4ace51afa1542cc4790a921a;/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/Base64.java;391;438;https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/Base64.java/#L391-L438;1;"        private int encode0(byte[] src, int off, int end, byte[] dst) {
            char[] base64 = isURL ? toBase64URL : toBase64;
            int sp = off;
            int slen = (end - off) / 3 * 3;
            int sl = off + slen;
            if (linemax > 0 && slen  > linemax / 4 * 3)
                slen = linemax / 4 * 3;
            int dp = 0;
            while (sp < sl) {
                int sl0 = Math.min(sp + slen, sl);
                for (int sp0 = sp, dp0 = dp ; sp0 < sl0; ) {
                    int bits = (src[sp0++] & 0xff) << 16 |
                               (src[sp0++] & 0xff) <<  8 |
                               (src[sp0++] & 0xff);
                    dst[dp0++] = (byte)base64[(bits >>> 18) & 0x3f];
                    dst[dp0++] = (byte)base64[(bits >>> 12) & 0x3f];
                    dst[dp0++] = (byte)base64[(bits >>> 6)  & 0x3f];
                    dst[dp0++] = (byte)base64[bits & 0x3f];
                }
                int dlen = (sl0 - sp) / 3 * 4;
                dp += dlen;
                sp = sl0;
                if (dlen == linemax && sp < end) {
                    for (byte b : newline){
                        dst[dp++] = b;
                    }
                }
            }
            if (sp < end) {               // 1 or 2 leftover bytes
                int b0 = src[sp++] & 0xff;
                dst[dp++] = (byte)base64[b0 >> 2];
                if (sp == end) {
                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f];
                    if (doPadding) {
                        dst[dp++] = '=';
                        dst[dp++] = '=';
                    }
                } else {
                    int b1 = src[sp++] & 0xff;
                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f | (b1 >> 4)];
                    dst[dp++] = (byte)base64[(b1 << 2) & 0x3f];
                    if (doPadding) {
                        dst[dp++] = '=';
                    }
                }
            }
            return dp;
        }"
15100;4;5339993;data class;major;2019-09-12 10:49:13.203961;class;org.apache.nifi.registry.flow.mapping.InstantiatedVersionedLabel;git@github.com:apache/nifi.git;c8eff590efa3babcda0b755009224dcac168708b;/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java;22;40;https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java/#L22-L40;1;"public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {
    private final String instanceId;
    private final String groupId;

    public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {
        this.instanceId = instanceId;
        this.groupId = instanceGroupId;
    }

    @Override
    public String getInstanceId() {
        return instanceId;
    }

    @Override
    public String getInstanceGroupId() {
        return groupId;
    }
}"
3199;14;7032959;feature envy;critical;2019-04-05 12:44:45.342380;function;sage.MiniPlayer#getDVDTotalTitles;git@github.com:google/sagetv.git;a35e3a450b4c0134cb097b9e7de76dca08eb6654;/java/sage/MiniPlayer.java;2879;2884;https://github.com/google/sagetv/blob/a35e3a450b4c0134cb097b9e7de76dca08eb6654/java/sage/MiniPlayer.java/#L2879-L2884;1;"  public int getDVDTotalTitles()
  {
    if (bdp != null)
      return bdp.getNumTitles();
    return 0;
  }"
11480;3;6190083;feature envy;none;2019-08-05 11:57:31.212409;function;org.eclipse.che.ide.ext.java.client.progressor.ProgressMonitorPresenter#hide;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/plugins/plugin-java/che-plugin-java-ext-lang-client/src/main/java/org/eclipse/che/ide/ext/java/client/progressor/ProgressMonitorPresenter.java;74;76;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-java/che-plugin-java-ext-lang-client/src/main/java/org/eclipse/che/ide/ext/java/client/progressor/ProgressMonitorPresenter.java/#L74-L76;1;"  public void hide() {
    view.close();
  }"
14771;4;4402431;feature envy;major;2019-09-12 08:53:38.900975;function;org.apache.cxf.rs.security.jose.jwk.JwkUtils.fromRSAPrivateKey RSAPrivateKey|String|String;git@github.com:apache/cxf.git;6bf89e9c8804c8845ec4d38583dd33eea8256439;/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java;448;469;https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java/#L448-L469;1;"    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);
        if (pk instanceof RSAPrivateCrtKey) {
            RSAPrivateCrtKey pkCrt = (RSAPrivateCrtKey)pk;
            jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP,
                            Base64UrlUtility.encode(pkCrt.getPublicExponent().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT,
                            Base64UrlUtility.encode(pkCrt.getCrtCoefficient().toByteArray()));
        }
        // ""oth"" can be populated too if needed
        return jwk;
    }"
1409;1;7477969;blob;none;2019-03-29 13:49:57.730728;class;example.service.Customer119Service;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer119Service.java;7;11;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer119Service.java/#L7-L11;0;"@Service
public class Customer119Service {
	public Customer119Service(Customer119Repository repo) {
	}
}"
9274;13;4654593;feature envy;major;2019-07-23 15:24:12.332897;function;org.apache.flink.graph.types.valuearray.DoubleValueArray#write DataOutputView;git@github.com:apache/flink.git;8068c8775ad067d75828e6360e7e0994348da9b9;/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/types/valuearray/DoubleValueArray.java;179;186;https://github.com/apache/flink/blob/8068c8775ad067d75828e6360e7e0994348da9b9/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/types/valuearray/DoubleValueArray.java/#L179-L186;1;"	@Override
	public void write(DataOutputView out) throws IOException {
		out.writeInt(position);

		for (int i = 0; i < position; i++) {
			out.writeDouble(data[i]);
		}
	}"
11092;13;6633402;long method;major;2019-08-02 11:14:04.906143;function;com.esri.android.mapsapp.MapFragment#getSuggestions String;git@github.com:Esri/maps-app-android.git;1af1f74ece08f678ce7de7bf173034d30e1cb100;/maps-app/src/main/java/com/esri/android/mapsapp/MapFragment.java;735;781;https://github.com/Esri/maps-app-android/blob/1af1f74ece08f678ce7de7bf173034d30e1cb100/maps-app/src/main/java/com/esri/android/mapsapp/MapFragment.java/#L735-L781;1;"	 */
	private void getSuggestions(final String query) {
		if (query == null || query.isEmpty()) {
			return;
		}

		// Initialize the locatorSugestion parameters
		locatorParams(SUGGEST_PLACE);

		// Attach a listener to the locator task since
		// the LocatorTask may or may not be loaded the
		// the very first time a user types text into the search box.
		// If the Locator is already loaded, the following listener
		// is invoked immediately.

		mLocator.addDoneLoadingListener(new Runnable() {
			@Override public void run() {
				// Does this locator support suggestions?
				if (mLocator.getLoadStatus().name() != LoadStatus.LOADED.name()){
					//Log.i(TAG,""##### "" + mLocator.getLoadStatus().name());
				} else if (!mLocator.getLocatorInfo().isSupportsSuggestions()){
					return;
				}
				//og.i(TAG,""****** "" + mLocator.getLoadStatus().name());
				final ListenableFuture<List<SuggestResult>> suggestionsFuture = mLocator.suggestAsync(query, suggestParams);
				// Attach a done listener that executes upon completion of the async call
				suggestionsFuture.addDoneListener(new Runnable() {
					@Override
					public void run() {
						try {
							// Get the suggestions returned from the locator task.
							// Store retrieved suggestions for future use (e.g. if the user
							// selects a retrieved suggestion, it can easily be
							// geocoded).
							mSuggestionsList = suggestionsFuture.get();

							showSuggestedPlaceNames(mSuggestionsList);

						} catch (Exception e) {
							Log.e(TAG, ""Error on getting suggestions "" + e.getMessage());
						}
					}
				});
			}
		});
		// Initiate the asynchronous call
		mLocator.loadAsync();"
1337;1;6790483;feature envy;major;2019-03-29 13:45:19.234389;function;com.google.caliper.runner.target.LocalDevice#vmExecutablePath Vm;git@github.com:google/caliper.git;4e10eb02b7bfb5683c71be950ad2e30ff1f2c0a9;/caliper-runner/src/main/java/com/google/caliper/runner/target/LocalDevice.java;105;120;https://github.com/google/caliper/blob/4e10eb02b7bfb5683c71be950ad2e30ff1f2c0a9/caliper-runner/src/main/java/com/google/caliper/runner/target/LocalDevice.java/#L105-L120;0,5;"  @Override
  public String vmExecutablePath(Vm vm) {
    File homeDir = vmHomeDir(vm);
    for (String extension : EXECUTABLE_EXTENSIONS) {
      for (String dir : EXECUTABLE_DIRS) {
        File file = new File(homeDir, dir + vm.executable() + extension);
        if (file.isFile()) {
          return file.getAbsolutePath();
        }
      }
    }
    throw new VirtualMachineException(
        String.format(
            ""VM executable %s for VM %s not found under home dir %s"",
            vm.executable(), vm, homeDir));
  }"
13505;34;9095266;blob;major;2019-08-29 15:49:50.033173;class;com.oracle.truffle.r.nodes.function.FunctionExpressionNode;git@github.com:oracle/fastr.git;a1ee49060317621c0c9eceea8ec60040aca59b2d;/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/function/FunctionExpressionNode.java;46;110;https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/function/FunctionExpressionNode.java/#L46-L110;1;"public final class FunctionExpressionNode extends RSourceSectionNode implements RSyntaxNode, RSyntaxFunction {

    public static FunctionExpressionNode create(SourceSection src, RootCallTarget callTarget) {
        return new FunctionExpressionNode(src, callTarget);
    }

    @Child private SetVisibilityNode visibility = SetVisibilityNode.create();

    @CompilationFinal private RootCallTarget callTarget;
    private final PromiseDeoptimizeFrameNode deoptFrameNode;

    @CompilationFinal private boolean initialized = false;

    private FunctionExpressionNode(SourceSection src, RootCallTarget callTarget) {
        super(src);
        this.callTarget = callTarget;
        this.deoptFrameNode = EagerEvalHelper.optExprs() || EagerEvalHelper.optVars() || EagerEvalHelper.optDefault() ? new PromiseDeoptimizeFrameNode() : null;
    }

    @Override
    public RFunction execute(VirtualFrame frame) {
        visibility.execute(frame, true);
        MaterializedFrame matFrame = frame.materialize();
        if (deoptFrameNode != null) {
            // Deoptimize every promise which is now in this frame, as it might leave it's stack
            deoptFrameNode.deoptimizeFrame(RArguments.getArguments(matFrame));
        }
        if (!initialized) {
            CompilerDirectives.transferToInterpreterAndInvalidate();
            if (!FrameSlotChangeMonitor.isEnclosingFrameDescriptor(callTarget.getRootNode().getFrameDescriptor(), frame)) {
                if (!FrameSlotChangeMonitor.isEnclosingFrameDescriptor(callTarget.getRootNode().getFrameDescriptor(), null)) {
                    RRootNode root = (RRootNode) callTarget.getRootNode();
                    callTarget = root.duplicateWithNewFrameDescriptor();
                }
                FrameSlotChangeMonitor.initializeEnclosingFrame(callTarget.getRootNode().getFrameDescriptor(), frame);
            }
            initialized = true;
        }
        return RDataFactory.createFunction(RFunction.NO_NAME, RFunction.NO_NAME, callTarget, null, matFrame);
    }

    public RootCallTarget getCallTarget() {
        return callTarget;
    }

    @Override
    public RSyntaxElement[] getSyntaxArgumentDefaults() {
        return RASTUtils.asSyntaxNodes(((FunctionDefinitionNode) callTarget.getRootNode()).getFormalArguments().getArguments());
    }

    @Override
    public RSyntaxElement getSyntaxBody() {
        return ((FunctionDefinitionNode) callTarget.getRootNode()).getBody();
    }

    @Override
    public ArgumentsSignature getSyntaxSignature() {
        return ((FunctionDefinitionNode) callTarget.getRootNode()).getFormalArguments().getSignature();
    }

    @Override
    public String getSyntaxDebugName() {
        return ((RRootNode) callTarget.getRootNode()).getName();
    }
}"
1930;16;3856345;feature envy;major;2019-03-29 17:22:00.940566;function;org.apache.ivy.plugins.parser.xml.XmlModuleDescriptorWriter.printAllExcludes ModuleDescriptor|PrintWriter;git@github.com:apache/ant-ivy.git;4ffcf8f06f238b17e78e8033c3e8278833e452eb;/src/java/org/apache/ivy/plugins/parser/xml/XmlModuleDescriptorWriter.java;209;227;https://github.com/apache/ant-ivy/blob/4ffcf8f06f238b17e78e8033c3e8278833e452eb/src/java/org/apache/ivy/plugins/parser/xml/XmlModuleDescriptorWriter.java/#L209-L227;1;"    private static void printAllExcludes(ModuleDescriptor md, PrintWriter out) {
        ExcludeRule[] excludes = md.getAllExcludeRules();
        if (excludes.length > 0) {
            for (ExcludeRule exclude : excludes) {
                out.print(String.format(""\t\t<exclude org=\""%s\"" module=\""%s\"" artifact=\""%s\"" type=\""%s\"" ext=\""%s\"""",
                        XMLHelper.escape(exclude.getId().getModuleId().getOrganisation()),
                        XMLHelper.escape(exclude.getId().getModuleId().getName()),
                        XMLHelper.escape(exclude.getId().getName()),
                        XMLHelper.escape(exclude.getId().getType()),
                        XMLHelper.escape(exclude.getId().getExt())));
                String[] ruleConfs = exclude.getConfigurations();
                if (!Arrays.asList(ruleConfs).equals(Arrays.asList(md.getConfigurationsNames()))) {
                    out.print(listToPrefixedString(ruleConfs, "" conf=\""""));
                }
                out.print("" matcher=\"""" + XMLHelper.escape(exclude.getMatcher().getName()) + ""\"""");
                out.println(""/>"");
            }
        }
    }"
4287;7;8879106;blob;none;2019-04-10 09:54:26.651072;class;org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore.update_partition_column_statistics_result.update_partition_column_statistics_resultTupleSchemeFactory;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java;149388;149392;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java/#L149388-L149392;1;"    private static class update_partition_column_statistics_resultTupleSchemeFactory implements SchemeFactory {
      public update_partition_column_statistics_resultTupleScheme getScheme() {
        return new update_partition_column_statistics_resultTupleScheme();
      }
    }"
10733;4;7108130;long method;major;2019-07-26 19:51:05.704399;function;java.util.Base64.Encoder#encode0 byte[]|int|int|byte[];git@github.com:google/j2objc.git;471504a735b48d5d4ace51afa1542cc4790a921a;/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/Base64.java;391;438;https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/Base64.java/#L391-L438;1;"        private int encode0(byte[] src, int off, int end, byte[] dst) {
            char[] base64 = isURL ? toBase64URL : toBase64;
            int sp = off;
            int slen = (end - off) / 3 * 3;
            int sl = off + slen;
            if (linemax > 0 && slen  > linemax / 4 * 3)
                slen = linemax / 4 * 3;
            int dp = 0;
            while (sp < sl) {
                int sl0 = Math.min(sp + slen, sl);
                for (int sp0 = sp, dp0 = dp ; sp0 < sl0; ) {
                    int bits = (src[sp0++] & 0xff) << 16 |
                               (src[sp0++] & 0xff) <<  8 |
                               (src[sp0++] & 0xff);
                    dst[dp0++] = (byte)base64[(bits >>> 18) & 0x3f];
                    dst[dp0++] = (byte)base64[(bits >>> 12) & 0x3f];
                    dst[dp0++] = (byte)base64[(bits >>> 6)  & 0x3f];
                    dst[dp0++] = (byte)base64[bits & 0x3f];
                }
                int dlen = (sl0 - sp) / 3 * 4;
                dp += dlen;
                sp = sl0;
                if (dlen == linemax && sp < end) {
                    for (byte b : newline){
                        dst[dp++] = b;
                    }
                }
            }
            if (sp < end) {               // 1 or 2 leftover bytes
                int b0 = src[sp++] & 0xff;
                dst[dp++] = (byte)base64[b0 >> 2];
                if (sp == end) {
                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f];
                    if (doPadding) {
                        dst[dp++] = '=';
                        dst[dp++] = '=';
                    }
                } else {
                    int b1 = src[sp++] & 0xff;
                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f | (b1 >> 4)];
                    dst[dp++] = (byte)base64[(b1 << 2) & 0x3f];
                    if (doPadding) {
                        dst[dp++] = '=';
                    }
                }
            }
            return dp;
        }"
15311;21;4081252;feature envy;critical;2019-09-13 06:40:45.141671;function;org.apache.hyracks.storage.am.lsm.rtree.dataflow.LSMRTreeWithAntiMatterLocalResource#createInstance INCServiceContext;git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/hyracks-fullstack/hyracks/hyracks-storage-am-lsm-rtree/src/main/java/org/apache/hyracks/storage/am/lsm/rtree/dataflow/LSMRTreeWithAntiMatterLocalResource.java;96;109;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/hyracks-fullstack/hyracks/hyracks-storage-am-lsm-rtree/src/main/java/org/apache/hyracks/storage/am/lsm/rtree/dataflow/LSMRTreeWithAntiMatterLocalResource.java/#L96-L109;1;"    @Override
    public ILSMIndex createInstance(INCServiceContext serviceCtx) throws HyracksDataException {
        IIOManager ioManager = serviceCtx.getIoManager();
        FileReference file = ioManager.resolve(path);
        List<IVirtualBufferCache> virtualBufferCaches = vbcProvider.getVirtualBufferCaches(serviceCtx, file);
        ioOpCallbackFactory.initialize(serviceCtx, this);
        return LSMRTreeUtils.createLSMTreeWithAntiMatterTuples(ioManager, virtualBufferCaches, file,
                storageManager.getBufferCache(serviceCtx), typeTraits, cmpFactories, btreeCmpFactories,
                valueProviderFactories, rtreePolicyType,
                mergePolicyFactory.createMergePolicy(mergePolicyProperties, serviceCtx),
                opTrackerProvider.getOperationTracker(serviceCtx, this), ioSchedulerProvider.getIoScheduler(serviceCtx),
                ioOpCallbackFactory, linearizeCmpFactory, rtreeFields, filterTypeTraits, filterCmpFactories,
                filterFields, durable, isPointMBR, metadataPageManagerFactory);
    }"
12962;20;7725645;data class;major;2019-08-16 13:31:57.385026;class;com.vmware.xenon.common.jwt.Header;git@github.com:vmware/xenon.git;b6fb48b745985af2efc59b7ee0e5e7d69a289fbc;/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java;23;30;https://github.com/vmware/xenon/blob/b6fb48b745985af2efc59b7ee0e5e7d69a289fbc/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java/#L23-L30;0;"public class Header {
    @SerializedName(""typ"")
    public String type;
    @SerializedName(""alg"")
    public String algorithm;
    @SerializedName(""cty"")
    public String contentType;
}"
8460;12;9006040;long method;major;2019-07-19 12:06:58.382040;function;org.apache.solr.update.processor.DistributedZkUpdateProcessor#doDefensiveChecks DistribPhase;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor.java;953;1007;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor.java/#L953-L1007;1;"  private void doDefensiveChecks(DistribPhase phase) {
    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;
    if (isReplayOrPeersync) return;

    String from = req.getParams().get(DISTRIB_FROM);
    ClusterState clusterState = zkController.getClusterState();

    DocCollection docCollection = clusterState.getCollection(collection);
    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());
    boolean localIsLeader = cloudDesc.isLeader();
    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay
      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);
      if (fromShard != null) {
        if (mySlice.getState() == Slice.State.ACTIVE)  {
          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,
              ""Request says it is coming from parent shard leader but we are in active state"");
        }
        // shard splitting case -- check ranges to see if we are a sub-shard
        Slice fromSlice = docCollection.getSlice(fromShard);
        DocRouter.Range parentRange = fromSlice.getRange();
        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);
        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {
          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,
              ""Request says it is coming from parent shard leader but parent hash range is not superset of my range"");
        }
      } else {
        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?
        if (fromCollection == null)  {
          log.error(""Request says it is coming from leader, but we are the leader: "" + req.getParamString());
          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, ""Request says it is coming from leader, but we are the leader"");
          solrExc.setMetadata(""cause"", ""LeaderChanged"");
          throw solrExc;
        }
      }
    }

    int count = 0;
    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {
      count++;
      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value
      localIsLeader = cloudDesc.isLeader();
      try {
        Thread.sleep(500);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }

    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {
      log.error(""ClusterState says we are the leader, but locally we don't think so"");
      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,
          ""ClusterState says we are the leader ("" + zkController.getBaseUrl()
              + ""/"" + req.getCore().getName() + ""), but locally we don't think so. Request came from "" + from);
    }
  }"
3707;13;8401179;data class;major;2019-04-05 13:20:27.549765;class;org.apache.camel.component.infinispan.embedded.InfinispanAsyncLocalEventListener;git@github.com:apache/camel.git;8a85a70643c4d6eec2d3abddeea44ecb06c2f486;/components/camel-infinispan/src/main/java/org/apache/camel/component/infinispan/embedded/InfinispanAsyncLocalEventListener.java;24;29;https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-infinispan/src/main/java/org/apache/camel/component/infinispan/embedded/InfinispanAsyncLocalEventListener.java/#L24-L29;1;"@Listener(clustered = false, sync = false)
public class InfinispanAsyncLocalEventListener extends InfinispanSyncLocalEventListener {
    public InfinispanAsyncLocalEventListener(InfinispanConsumer consumer, Set<String> eventTypes) {
        super(consumer, eventTypes);
    }
}"
3188;16;3901039;blob;none;2019-04-05 12:44:13.677048;class;org.apache.accumulo.core.clientImpl.thrift.ClientService.revokeTablePermission_args.revokeTablePermission_argsTupleSchemeFactory;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/core/src/main/java/org/apache/accumulo/core/clientImpl/thrift/ClientService.java;27751;27755;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/clientImpl/thrift/ClientService.java/#L27751-L27755;1;"    private static class revokeTablePermission_argsTupleSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
      public revokeTablePermission_argsTupleScheme getScheme() {
        return new revokeTablePermission_argsTupleScheme();
      }
    }"
4106;23;4476433;long method;none;2019-04-07 09:00:22.243867;function;org.apache.drill.exec.physical.impl.xsort.managed.SortMemoryManager#getPreferredMergeBatchSize;git@github.com:apache/drill.git;5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3;/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/xsort/managed/SortMemoryManager.java;782;783;https://github.com/apache/drill/blob/5e2251a9fd659b81ebfcd6702ee4ee16b3f7b6b3/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/xsort/managed/SortMemoryManager.java/#L782-L783;1;"  @VisibleForTesting
  public int getPreferredMergeBatchSize() { return preferredMergeBatchSize; }"
762;11;6329418;long method;none;2019-03-29 13:07:51.495096;function;org.eclipse.kura.bluetooth.le.beacon.AdvertisingReportRecord#getEventType;git@github.com:eclipse/kura.git;5e9f3e3d03c8a9cc7857b3fb9080b256821bb32a;/kura/org.eclipse.kura.api/src/main/java/org/eclipse/kura/bluetooth/le/beacon/AdvertisingReportRecord.java;30;32;https://github.com/eclipse/kura/blob/5e9f3e3d03c8a9cc7857b3fb9080b256821bb32a/kura/org.eclipse.kura.api/src/main/java/org/eclipse/kura/bluetooth/le/beacon/AdvertisingReportRecord.java/#L30-L32;1;"    public AdvertisingReportEventType getEventType() {
        return this.eventType;
    }"
10755;4;4124615;blob;major;2019-07-26 20:02:21.219891;class;org.apache.brooklyn.rest.resources.SensorResource;git@github.com:apache/brooklyn-server.git;880eb1da00f6358d7fd76d065322e3685bfb1a04;/rest/rest-resources/src/main/java/org/apache/brooklyn/rest/resources/SensorResource.java;46;183;https://github.com/apache/brooklyn-server/blob/880eb1da00f6358d7fd76d065322e3685bfb1a04/rest/rest-resources/src/main/java/org/apache/brooklyn/rest/resources/SensorResource.java/#L46-L183;1;"@HaHotStateRequired
public class SensorResource extends AbstractBrooklynRestResource implements SensorApi {

    private static final Logger log = LoggerFactory.getLogger(SensorResource.class);

    @Override
    public List<SensorSummary> list(final String application, final String entityToken) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"",
                    Entitlements.getEntitlementContext().user(), entity);
        }

        List<SensorSummary> result = Lists.newArrayList();
        
        for (AttributeSensor<?> sensor : filter(entity.getEntityType().getSensors(), AttributeSensor.class)) {
            // Exclude config that user is not allowed to see
            if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
                log.trace(""User {} not authorized to see sensor {} of entity {}; excluding from AttributeSensor list results"", 
                        new Object[] {Entitlements.getEntitlementContext().user(), sensor.getName(), entity});
                continue;
            }
            result.add(SensorTransformer.sensorSummary(entity, sensor, ui.getBaseUriBuilder()));
        }
        
        return result;
    }

    @Override
    public Map<String, Object> batchSensorRead(final String application, final String entityToken, final Boolean raw) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"",
                    Entitlements.getEntitlementContext().user(), entity);
        }

        Map<String, Object> sensorMap = Maps.newHashMap();
        @SuppressWarnings(""rawtypes"")
        Iterable<AttributeSensor> sensors = filter(entity.getEntityType().getSensors(), AttributeSensor.class);

        for (AttributeSensor<?> sensor : sensors) {
            // Exclude sensors that user is not allowed to see
            if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
                log.trace(""User {} not authorized to see sensor {} of entity {}; excluding from current-state results"", 
                        new Object[] {Entitlements.getEntitlementContext().user(), sensor.getName(), entity});
                continue;
            }

            Object value = entity.getAttribute(findSensor(entity, sensor.getName()));
            sensorMap.put(sensor.getName(), 
                resolving(value).preferJson(true).asJerseyOutermostReturnValue(false).raw(raw).context(entity).timeout(Duration.ZERO).renderAs(sensor).resolve());
        }
        return sensorMap;
    }

    protected Object get(boolean preferJson, String application, String entityToken, String sensorName, Boolean raw) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        AttributeSensor<?> sensor = findSensor(entity, sensorName);
        
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"",
                    Entitlements.getEntitlementContext().user(), entity);
        }
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s' sensor '%s'"",
                    Entitlements.getEntitlementContext().user(), entity, sensor.getName());
        }
        
        Object value = entity.getAttribute(sensor);
        return resolving(value).preferJson(preferJson).asJerseyOutermostReturnValue(true).raw(raw).context(entity).immediately(true).renderAs(sensor).resolve();
    }

    @Override
    public String getPlain(String application, String entityToken, String sensorName, final Boolean raw) {
        return (String) get(false, application, entityToken, sensorName, raw);
    }

    @Override
    public Object get(final String application, final String entityToken, String sensorName, final Boolean raw) {
        return get(true, application, entityToken, sensorName, raw);
    }

    private AttributeSensor<?> findSensor(Entity entity, String name) {
        Sensor<?> s = entity.getEntityType().getSensor(name);
        if (s instanceof AttributeSensor) return (AttributeSensor<?>) s;
        return new BasicAttributeSensor<Object>(Object.class, name);
    }
    
    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    @Override
    public void setFromMap(String application, String entityToken, Map newValues) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"",
                Entitlements.getEntitlementContext().user(), entity);
        }

        if (log.isDebugEnabled())
            log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" setting sensors ""+newValues);
        for (Object entry: newValues.entrySet()) {
            String sensorName = Strings.toString(((Map.Entry)entry).getKey());
            Object newValue = ((Map.Entry)entry).getValue();
            
            AttributeSensor sensor = findSensor(entity, sensorName);
            entity.sensors().set(sensor, newValue);
        }
    }
    
    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    @Override
    public void set(String application, String entityToken, String sensorName, Object newValue) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"",
                Entitlements.getEntitlementContext().user(), entity);
        }
        
        AttributeSensor sensor = findSensor(entity, sensorName);
        if (log.isDebugEnabled())
            log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" setting sensor ""+sensorName+"" to ""+newValue);
        entity.sensors().set(sensor, newValue);
    }
    
    @Override
    public void delete(String application, String entityToken, String sensorName) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"",
                Entitlements.getEntitlementContext().user(), entity);
        }
        
        AttributeSensor<?> sensor = findSensor(entity, sensorName);
        if (log.isDebugEnabled())
            log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" deleting sensor ""+sensorName);
        ((EntityInternal)entity).sensors().remove(sensor);
    }
    
}"
10827;4;4568919;long method;major;2019-07-26 20:38:46.369512;function;org.apache.fop.fonts.truetype.OpenFont#readFont FontFileReader|String|String;git@github.com:apache/fop.git;caced35327f6b6d6eeac2a13543f3c458e902101;/fop-core/src/main/java/org/apache/fop/fonts/truetype/OpenFont.java;813;862;https://github.com/apache/fop/blob/caced35327f6b6d6eeac2a13543f3c458e902101/fop-core/src/main/java/org/apache/fop/fonts/truetype/OpenFont.java/#L813-L862;1;"    public boolean readFont(FontFileReader in, String header, String name) throws IOException {
        initializeFont(in);
        /*
         * Check if TrueType collection, and that the name
         * exists in the collection
         */
        if (!checkTTC(header, name)) {
            if (name == null) {
                throw new IllegalArgumentException(
                    ""For TrueType collection you must specify which font ""
                    + ""to select (-ttcname)"");
            } else {
                throw new IOException(
                    ""Name does not exist in the TrueType collection: "" + name);
            }
        }

        readDirTabs();
        readFontHeader();
        getNumGlyphs();
        if (log.isDebugEnabled()) {
            log.debug(""Number of glyphs in font: "" + numberOfGlyphs);
        }
        readHorizontalHeader();
        readHorizontalMetrics();
        initAnsiWidths();
        readPostScript();
        readOS2();
        determineAscDesc();

        readName();
        boolean pcltFound = readPCLT();
        // Read cmap table and fill in ansiwidths
        boolean valid = readCMAP();
        if (!valid) {
            return false;
        }

        // Create cmaps for bfentries
        createCMaps();
        updateBBoxAndOffset();

        if (useKerning) {
            readKerning();
        }
        handleCharacterSpacing(in);

        guessVerticalMetricsFromGlyphBBox();
        return true;
    }"
1229;12;7239385;data class;critical;2019-03-29 13:38:34.793986;class;org.robolectric.res.android.LoadedArsc.DynamicPackageEntry;git@github.com:robolectric/robolectric.git;525bfcfc0e0ed1653ad57341b564c6857e11dc50;/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java;62;75;https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java/#L62-L75;1;"  static class DynamicPackageEntry {

    // public:
    //
    // DynamicPackageEntry() =default;

    DynamicPackageEntry(String package_name, int package_id) {
      this.package_name = package_name;
      this.package_id = package_id;
    }

    String package_name;
    int package_id = 0;
  }"
10635;13;5855589;feature envy;critical;2019-07-26 12:55:24.795178;function;org.apache.catalina.ha.session.DeltaSession#endAccess;git@github.com:apache/tomcat.git;a9c1a0661198d9ba37c1facd8385fe05d538c4ad;/java/org/apache/catalina/ha/session/DeltaSession.java;412;418;https://github.com/apache/tomcat/blob/a9c1a0661198d9ba37c1facd8385fe05d538c4ad/java/org/apache/catalina/ha/session/DeltaSession.java/#L412-L418;1;"    @Override
    public void endAccess() {
        super.endAccess() ;
        if(manager instanceof ClusterManagerBase) {
            ((ClusterManagerBase)manager).registerSessionAtReplicationValve(this);
        }
    }"
14994;13;7725777;data class;critical;2019-09-12 10:09:15.256964;class;com.vmware.admiral.request.notification.NotificationsService.NotificationsAggregatorState;git@github.com:vmware/admiral.git;e02d0e77f65d0ee3541a378110ecd4233bdb6664;/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java;52;55;https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55;1;"    public static class NotificationsAggregatorState {
        public long recentEventLogsCount;
        public long activeRequestsCount;
    }"
748;5;6328926;feature envy;none;2019-03-29 13:04:56.182194;function;org.eclipse.kapua.app.console.module.api.shared.model.session.GwtSession#hasPermission String|GwtSessionPermissionAction|GwtSessionPermissionScope;git@github.com:eclipse/kapua.git;11e610c657f7e473b52882833e33a2261bd3d67d;/console/module/api/src/main/java/org/eclipse/kapua/app/console/module/api/shared/model/session/GwtSession.java;187;189;https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/console/module/api/src/main/java/org/eclipse/kapua/app/console/module/api/shared/model/session/GwtSession.java/#L187-L189;1;"    public boolean hasPermission(String domain, GwtSessionPermissionAction action, GwtSessionPermissionScope targetScope) {
        return hasPermission(new GwtSessionPermission(domain, action, targetScope));
    }"
2209;3;8962839;blob;none;2019-04-01 13:24:48.297266;class;org.apache.hive.service.rpc.thrift.TCLIService.GetResultSetMetadata_result.GetResultSetMetadata_resultStandardSchemeFactory;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/service-rpc/src/gen/thrift/gen-javabean/org/apache/hive/service/rpc/thrift/TCLIService.java;15412;15416;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/service-rpc/src/gen/thrift/gen-javabean/org/apache/hive/service/rpc/thrift/TCLIService.java/#L15412-L15416;1;"    private static class GetResultSetMetadata_resultStandardSchemeFactory implements SchemeFactory {
      public GetResultSetMetadata_resultStandardScheme getScheme() {
        return new GetResultSetMetadata_resultStandardScheme();
      }
    }"
7797;3;6999436;blob;major;2019-07-13 00:48:06.102781;class;org.physical_web.physicalweb.MainActivity;git@github.com:google/physical-web.git;12604319e99b6d6dff451fc5a58a13a271f1dc7a;/android/PhysicalWeb/app/src/main/java/org/physical_web/physicalweb/MainActivity.java;39;228;https://github.com/google/physical-web/blob/12604319e99b6d6dff451fc5a58a13a271f1dc7a/android/PhysicalWeb/app/src/main/java/org/physical_web/physicalweb/MainActivity.java/#L39-L228;0;"public class MainActivity extends Activity {
  private static final String TAG  = MainActivity.class.getSimpleName();
  private static final int REQUEST_ENABLE_BT = 0;
  private static final int REQUEST_LOCATION = 1;
  private static final String NEARBY_BEACONS_FRAGMENT_TAG = ""NearbyBeaconsFragmentTag"";
  private static final String SETTINGS_FRAGMENT_TAG = ""SettingsFragmentTag"";
  private static final String BLOCKED_URLS_FRAGMENT_TAG = ""BlockedUrlsFragmentTag"";
  private static final String ABOUT_FRAGMENT_TAG = ""AboutFragmentTag"";
  private static final String DEMOS_FRAGMENT_TAG = ""DemosFragmentTag"";

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Utils.setSharedPreferencesDefaultValues(this);
    PermissionCheck.getInstance().setCheckingPermissions(false);
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }

  /**
   * Called when a menu item is tapped.
   */
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
      // If the about menu item was selected
      case R.id.action_about:
        showAboutFragment();
        return true;
      // If the settings menu item was selected
      case R.id.action_settings:
        showSettingsFragment();
        return true;
      case R.id.block_settings:
        showBlockedFragment();
        return true;
      case R.id.action_demos:
        showDemosFragment();
        return true;
      // If the action bar up button was pressed
      case android.R.id.home:
        getFragmentManager().popBackStack();
        getActionBar().setDisplayHomeAsUpEnabled(false);
    }
    return super.onOptionsItemSelected(item);
  }

  /**
   * Ensures Bluetooth is available on the beacon and it is enabled. If not,
   * displays a dialog requesting user permission to enable Bluetooth.
   */
  private void checkPermissions(BluetoothAdapter bluetoothAdapter) {
    // Acquire lock
    PermissionCheck.getInstance().setCheckingPermissions(true);
    if (!bluetoothAdapter.isEnabled()) {
      Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
      startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
      return;
    }
    ensureLocationPermissionIsEnabled();
  }

  @Override
  protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    Log.d(TAG, ""onActivityResult"");
    if (requestCode == REQUEST_ENABLE_BT && resultCode == -1) {
      ensureLocationPermissionIsEnabled();
      return;
    }
    Toast.makeText(this, getString(R.string.bt_on), Toast.LENGTH_LONG).show();
    finish();
  }

  private void ensureLocationPermissionIsEnabled() {
    if (Build.VERSION.SDK_INT >= 23 && ContextCompat.checkSelfPermission(this,
        android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
      ActivityCompat.requestPermissions(this, new String[]{
          android.Manifest.permission.ACCESS_COARSE_LOCATION}, REQUEST_LOCATION);
      return;
    }
    PermissionCheck.getInstance().setCheckingPermissions(false);
    finishLoad();
  }

  @Override
  public void onRequestPermissionsResult(int requestCode,
      String permissions[], int[] grantResults) {
    switch (requestCode) {
      case REQUEST_LOCATION: {
        // If request is cancelled, the result arrays are empty.
        if (grantResults.length > 0
            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
          PermissionCheck.getInstance().setCheckingPermissions(false);
        } else {
          Toast.makeText(getApplicationContext(),
              getString(R.string.loc_permission), Toast.LENGTH_LONG).show();
          finish();
        }
        break;
      }
      default:
    }
  }

  @Override
  protected void onResume() {
    super.onResume();
    // Lock to prevent onResume from running until all permissions are granted
    if (!PermissionCheck.getInstance().isCheckingPermissions()) {
      Log.d(TAG, ""resumed MainActivity"");
      BluetoothManager btManager = (BluetoothManager) getSystemService(BLUETOOTH_SERVICE);
      BluetoothAdapter btAdapter = btManager != null ? btManager.getAdapter() : null;
      if (btAdapter == null) {
        Toast.makeText(getApplicationContext(),
            R.string.error_bluetooth_support, Toast.LENGTH_LONG).show();
        finish();
        return;
      }
      if (Utils.checkIfUserHasOptedIn(this)) {
        Log.d(TAG, ""checkingPermissions"");
        checkPermissions(btAdapter);
      } else {
        // Show the oob activity
        Intent intent = new Intent(this, OobActivity.class);
        startActivity(intent);
      }
    }
  }

  private void finishLoad() {
    Intent intent = new Intent(this, ScreenListenerService.class);
    startService(intent);
    NearbyBeaconsFragment nearbyBeaconsFragment =
        (NearbyBeaconsFragment) getFragmentManager().findFragmentByTag(NEARBY_BEACONS_FRAGMENT_TAG);
    if (nearbyBeaconsFragment != null) {
      nearbyBeaconsFragment.restartScan();
    } else {
      showFragment(new NearbyBeaconsFragment(), NEARBY_BEACONS_FRAGMENT_TAG, false);
    }
  }

  /**
   * Show the fragment to configure the app.
   */
  private void showSettingsFragment() {
    showFragment(new SettingsFragment(), SETTINGS_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying information about this application.
   */
  private void showAboutFragment() {
    showFragment(new AboutFragment(), ABOUT_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying the blocked URLs.
   */
  private void showBlockedFragment() {
    showFragment(new BlockedFragment(), BLOCKED_URLS_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying the demos.
   */
  private void showDemosFragment() {
    showFragment(new DemosFragment(), DEMOS_FRAGMENT_TAG, true);
  }

  @SuppressLint(""CommitTransaction"")
  private void showFragment(Fragment newFragment, String fragmentTag, boolean addToBackStack) {
    FragmentTransaction transaction = getFragmentManager().beginTransaction()
        .setCustomAnimations(
            R.animator.fade_in_and_slide_up_fragment,
            R.animator.fade_out_fragment,
            R.animator.fade_in_activity,
            R.animator.fade_out_fragment)
        .replace(R.id.main_activity_container, newFragment, fragmentTag);
    if (addToBackStack) {
      transaction.addToBackStack(null);
    }
    transaction.commit();
  }
}"
5410;6;4309297;feature envy;major;2019-04-16 17:45:28.138060;function;org.apache.directory.api.ldap.model.schema.registries.ImmutableComparatorRegistry#iterator;git@github.com:apache/directory-ldap-api.git;5b93e102556ad2191b5d30411708410d1b1a9d71;/ldap/model/src/main/java/org/apache/directory/api/ldap/model/schema/registries/ImmutableComparatorRegistry.java;148;152;https://github.com/apache/directory-ldap-api/blob/5b93e102556ad2191b5d30411708410d1b1a9d71/ldap/model/src/main/java/org/apache/directory/api/ldap/model/schema/registries/ImmutableComparatorRegistry.java/#L148-L152;1;"    @Override
    public Iterator<LdapComparator<?>> iterator()
    {
        return immutableComparatorRegistry.iterator();
    }"
14133;21;6190083;long method;none;2019-09-02 08:44:11.452470;function;org.eclipse.che.ide.ext.java.client.progressor.ProgressMonitorPresenter#hide;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/plugins/plugin-java/che-plugin-java-ext-lang-client/src/main/java/org/eclipse/che/ide/ext/java/client/progressor/ProgressMonitorPresenter.java;74;76;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-java/che-plugin-java-ext-lang-client/src/main/java/org/eclipse/che/ide/ext/java/client/progressor/ProgressMonitorPresenter.java/#L74-L76;1;"  public void hide() {
    view.close();
  }"
3848;20;8341412;blob;none;2019-04-05 13:27:58.943870;class;p1.subp1.SubC1;git@github.com:eclipse/org.aspectj.git;370f291c359cd159c5f3f0abd6e9e53e81234a07;/tests/pureJava/p1/subp1/SubC1.java;3;5;https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/tests/pureJava/p1/subp1/SubC1.java/#L3-L5;1;"public class SubC1 {

}"
1581;12;7725645;data class;critical;2019-03-29 14:01:17.793078;class;com.vmware.xenon.common.jwt.Header;git@github.com:vmware/xenon.git;b6fb48b745985af2efc59b7ee0e5e7d69a289fbc;/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java;23;30;https://github.com/vmware/xenon/blob/b6fb48b745985af2efc59b7ee0e5e7d69a289fbc/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java/#L23-L30;0;"public class Header {
    @SerializedName(""typ"")
    public String type;
    @SerializedName(""alg"")
    public String algorithm;
    @SerializedName(""cty"")
    public String contentType;
}"
1391;13;7457519;blob;none;2019-03-29 13:48:29.993333;class;example.repo.Customer840Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/repo/Customer840Repository.java;9;12;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer840Repository.java/#L9-L12;0;"public interface Customer840Repository extends CrudRepository<Customer840, Long> {

	List<Customer840> findByLastName(String lastName);
}"
1909;5;3929567;data class;none;2019-03-29 14:33:30.045083;class;org.apache.accumulo.core.tabletserver.thrift.TabletClientService.conditionalUpdate_args.conditionalUpdate_argsStandardSchemeFactory;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/core/src/main/java/org/apache/accumulo/core/tabletserver/thrift/TabletClientService.java;21097;21101;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/tabletserver/thrift/TabletClientService.java/#L21097-L21101;1;"    private static class conditionalUpdate_argsStandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
      public conditionalUpdate_argsStandardScheme getScheme() {
        return new conditionalUpdate_argsStandardScheme();
      }
    }"
1384;12;7457996;data class;major;2019-03-29 13:47:53.184713;class;example.model.Customer388;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/model/Customer388.java;8;27;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer388.java/#L8-L27;0;"@Entity
public class Customer388 {

	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id;
	private String firstName;
	private String lastName;

	protected Customer388() {}

	public Customer388(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	@Override
	public String toString() {
		return String.format(""Customer388[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}

}"
730;8;6257015;data class;critical;2019-03-27 15:30:11.081335;class;org.eclipse.hawkbit.HawkbitServerProperties.Build;git@github.com:eclipse/hawkbit.git;51be28147f6f575b6c1ab4a5ef84ffd9174f1209;/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java;75;90;https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90;1;"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }"
724;7;6244777;long method;none;2019-03-27 11:22:26.295414;function;org.eclipse.hono.config.ServiceConfigProperties#getPort;git@github.com:eclipse/hono.git;ec84947227564c6459801f708bdeabd7687a8bf0;/core/src/main/java/org/eclipse/hono/config/ServiceConfigProperties.java;72;74;https://github.com/eclipse/hono/blob/ec84947227564c6459801f708bdeabd7687a8bf0/core/src/main/java/org/eclipse/hono/config/ServiceConfigProperties.java/#L72-L74;1;"    public final int getPort() {
        return port;
    }"
9334;13;4081252;feature envy;major;2019-07-23 16:03:47.227538;function;org.apache.hyracks.storage.am.lsm.rtree.dataflow.LSMRTreeWithAntiMatterLocalResource#createInstance INCServiceContext;git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/hyracks-fullstack/hyracks/hyracks-storage-am-lsm-rtree/src/main/java/org/apache/hyracks/storage/am/lsm/rtree/dataflow/LSMRTreeWithAntiMatterLocalResource.java;96;109;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/hyracks-fullstack/hyracks/hyracks-storage-am-lsm-rtree/src/main/java/org/apache/hyracks/storage/am/lsm/rtree/dataflow/LSMRTreeWithAntiMatterLocalResource.java/#L96-L109;1;"    @Override
    public ILSMIndex createInstance(INCServiceContext serviceCtx) throws HyracksDataException {
        IIOManager ioManager = serviceCtx.getIoManager();
        FileReference file = ioManager.resolve(path);
        List<IVirtualBufferCache> virtualBufferCaches = vbcProvider.getVirtualBufferCaches(serviceCtx, file);
        ioOpCallbackFactory.initialize(serviceCtx, this);
        return LSMRTreeUtils.createLSMTreeWithAntiMatterTuples(ioManager, virtualBufferCaches, file,
                storageManager.getBufferCache(serviceCtx), typeTraits, cmpFactories, btreeCmpFactories,
                valueProviderFactories, rtreePolicyType,
                mergePolicyFactory.createMergePolicy(mergePolicyProperties, serviceCtx),
                opTrackerProvider.getOperationTracker(serviceCtx, this), ioSchedulerProvider.getIoScheduler(serviceCtx),
                ioOpCallbackFactory, linearizeCmpFactory, rtreeFields, filterTypeTraits, filterCmpFactories,
                filterFields, durable, isPointMBR, metadataPageManagerFactory);
    }"
15086;20;5339993;data class;major;2019-09-12 10:45:45.389109;class;org.apache.nifi.registry.flow.mapping.InstantiatedVersionedLabel;git@github.com:apache/nifi.git;c8eff590efa3babcda0b755009224dcac168708b;/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java;22;40;https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java/#L22-L40;1;"public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {
    private final String instanceId;
    private final String groupId;

    public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {
        this.instanceId = instanceId;
        this.groupId = instanceGroupId;
    }

    @Override
    public String getInstanceId() {
        return instanceId;
    }

    @Override
    public String getInstanceGroupId() {
        return groupId;
    }
}"
3008;17;7468395;blob;none;2019-04-05 12:27:30.940777;class;example.service.Customer1585Service;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer1585Service.java;7;11;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer1585Service.java/#L7-L11;0;"@Service
public class Customer1585Service {
	public Customer1585Service(Customer1585Repository repo) {
	}
}"
1026;17;6920597;long method;none;2019-03-29 13:26:48.744586;function;com.google.gdata.data.analytics.AccountFeed#addSegment Segment;git@github.com:google/gdata-java-client.git;c6202a55f5f29afb37ffcf876674dca372f3fb4c;/java/src/com/google/gdata/data/analytics/AccountFeed.java;74;76;https://github.com/google/gdata-java-client/blob/c6202a55f5f29afb37ffcf876674dca372f3fb4c/java/src/com/google/gdata/data/analytics/AccountFeed.java/#L74-L76;0,5;"  public void addSegment(Segment segment) {
    getSegments().add(segment);
  }"
9781;10;9379644;feature envy;major;2019-07-24 12:41:51.923453;function;com.sun.org.apache.xml.internal.security.c14n.ClassLoaderUtils.loadClass2 String|Class<?>;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/c14n/ClassLoaderUtils.java;66;83;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/c14n/ClassLoaderUtils.java/#L66-L83;1;"    private static Class<?> loadClass2(String className, Class<?> callingClass)
        throws ClassNotFoundException {
        try {
            return Class.forName(className);
        } catch (ClassNotFoundException ex) {
            try {
                if (ClassLoaderUtils.class.getClassLoader() != null) {
                    return ClassLoaderUtils.class.getClassLoader().loadClass(className);
                }
            } catch (ClassNotFoundException exc) {
                if (callingClass != null && callingClass.getClassLoader() != null) {
                    return callingClass.getClassLoader().loadClass(className);
                }
            }
            LOG.debug(ex.getMessage(), ex);
            throw ex;
        }
    }"
7846;3;7930012;blob;major;2019-07-17 19:10:27.691531;class;org.eclipse.draw2d.PolylineConnection;git@github.com:eclipse/gef-legacy.git;14563a9e1f2af636a5364d195cf07dbff6f35fa6;/org.eclipse.draw2d/src/org/eclipse/draw2d/PolylineConnection.java;36;392;https://github.com/eclipse/gef-legacy/blob/14563a9e1f2af636a5364d195cf07dbff6f35fa6/org.eclipse.draw2d/src/org/eclipse/draw2d/PolylineConnection.java/#L36-L392;0;"public class PolylineConnection extends Polyline implements Connection,
		AnchorListener {

	private ConnectionAnchor startAnchor, endAnchor;
	private ConnectionRouter connectionRouter = ConnectionRouter.NULL;
	private RotatableDecoration startArrow, endArrow;

	{
		setLayoutManager(new DelegatingLayout());
		addPoint(new Point(0, 0));
		addPoint(new Point(100, 100));
	}

	/**
	 * Hooks the source and target anchors.
	 * 
	 * @see Figure#addNotify()
	 */
	public void addNotify() {
		super.addNotify();
		hookSourceAnchor();
		hookTargetAnchor();
	}

	/**
	 * Appends the given routing listener to the list of listeners.
	 * 
	 * @param listener
	 *            the routing listener
	 * @since 3.2
	 */
	public void addRoutingListener(RoutingListener listener) {
		if (connectionRouter instanceof RoutingNotifier) {
			RoutingNotifier notifier = (RoutingNotifier) connectionRouter;
			notifier.listeners.add(listener);
		} else
			connectionRouter = new RoutingNotifier(connectionRouter, listener);
	}

	/**
	 * Called by the anchors of this connection when they have moved,
	 * revalidating this polyline connection.
	 * 
	 * @param anchor
	 *            the anchor that moved
	 */
	public void anchorMoved(ConnectionAnchor anchor) {
		revalidate();
	}

	/**
	 * Returns the bounds which holds all the points in this polyline
	 * connection. Returns any previously existing bounds, else calculates by
	 * unioning all the children's dimensions.
	 * 
	 * @return the bounds
	 */
	public Rectangle getBounds() {
		if (bounds == null) {
			super.getBounds();
			for (int i = 0; i < getChildren().size(); i++) {
				IFigure child = (IFigure) getChildren().get(i);
				bounds.union(child.getBounds());
			}
		}
		return bounds;
	}

	/**
	 * Returns the <code>ConnectionRouter</code> used to layout this connection.
	 * Will not return <code>null</code>.
	 * 
	 * @return this connection's router
	 */
	public ConnectionRouter getConnectionRouter() {
		if (connectionRouter instanceof RoutingNotifier)
			return ((RoutingNotifier) connectionRouter).realRouter;
		return connectionRouter;
	}

	/**
	 * Returns this connection's routing constraint from its connection router.
	 * May return <code>null</code>.
	 * 
	 * @return the connection's routing constraint
	 */
	public Object getRoutingConstraint() {
		if (getConnectionRouter() != null)
			return getConnectionRouter().getConstraint(this);
		else
			return null;
	}

	/**
	 * @return the anchor at the start of this polyline connection (may be null)
	 */
	public ConnectionAnchor getSourceAnchor() {
		return startAnchor;
	}

	/**
	 * @return the source decoration (may be null)
	 */
	protected RotatableDecoration getSourceDecoration() {
		return startArrow;
	}

	/**
	 * @return the anchor at the end of this polyline connection (may be null)
	 */
	public ConnectionAnchor getTargetAnchor() {
		return endAnchor;
	}

	/**
	 * @return the target decoration (may be null)
	 * 
	 * @since 2.0
	 */
	protected RotatableDecoration getTargetDecoration() {
		return endArrow;
	}

	private void hookSourceAnchor() {
		if (getSourceAnchor() != null)
			getSourceAnchor().addAnchorListener(this);
	}

	private void hookTargetAnchor() {
		if (getTargetAnchor() != null)
			getTargetAnchor().addAnchorListener(this);
	}

	/**
	 * Layouts this polyline. If the start and end anchors are present, the
	 * connection router is used to route this, after which it is laid out. It
	 * also fires a moved method.
	 */
	public void layout() {
		if (getSourceAnchor() != null && getTargetAnchor() != null)
			connectionRouter.route(this);

		Rectangle oldBounds = bounds;
		super.layout();
		bounds = null;

		if (!getBounds().contains(oldBounds)) {
			getParent().translateToParent(oldBounds);
			getUpdateManager().addDirtyRegion(getParent(), oldBounds);
		}

		repaint();
		fireFigureMoved();
	}

	/**
	 * Called just before the receiver is being removed from its parent. Results
	 * in removing itself from the connection router.
	 * 
	 * @since 2.0
	 */
	public void removeNotify() {
		unhookSourceAnchor();
		unhookTargetAnchor();
		connectionRouter.remove(this);
		super.removeNotify();
	}

	/**
	 * Removes the first occurence of the given listener.
	 * 
	 * @param listener
	 *            the listener being removed
	 * @since 3.2
	 */
	public void removeRoutingListener(RoutingListener listener) {
		if (connectionRouter instanceof RoutingNotifier) {
			RoutingNotifier notifier = (RoutingNotifier) connectionRouter;
			notifier.listeners.remove(listener);
			if (notifier.listeners.isEmpty())
				connectionRouter = notifier.realRouter;
		}
	}

	/**
	 * @see IFigure#revalidate()
	 */
	public void revalidate() {
		super.revalidate();
		connectionRouter.invalidate(this);
	}

	/**
	 * Sets the connection router which handles the layout of this polyline.
	 * Generally set by the parent handling the polyline connection.
	 * 
	 * @param cr
	 *            the connection router
	 */
	public void setConnectionRouter(ConnectionRouter cr) {
		if (cr == null)
			cr = ConnectionRouter.NULL;
		ConnectionRouter oldRouter = getConnectionRouter();
		if (oldRouter != cr) {
			connectionRouter.remove(this);
			if (connectionRouter instanceof RoutingNotifier)
				((RoutingNotifier) connectionRouter).realRouter = cr;
			else
				connectionRouter = cr;
			firePropertyChange(Connection.PROPERTY_CONNECTION_ROUTER,
					oldRouter, cr);
			revalidate();
		}
	}

	/**
	 * Sets the routing constraint for this connection.
	 * 
	 * @param cons
	 *            the constraint
	 */
	public void setRoutingConstraint(Object cons) {
		if (connectionRouter != null)
			connectionRouter.setConstraint(this, cons);
		revalidate();
	}

	/**
	 * Sets the anchor to be used at the start of this polyline connection.
	 * 
	 * @param anchor
	 *            the new source anchor
	 */
	public void setSourceAnchor(ConnectionAnchor anchor) {
		if (anchor == startAnchor)
			return;
		unhookSourceAnchor();
		// No longer needed, revalidate does this.
		// getConnectionRouter().invalidate(this);
		startAnchor = anchor;
		if (getParent() != null)
			hookSourceAnchor();
		revalidate();
	}

	/**
	 * Sets the decoration to be used at the start of the {@link Connection}.
	 * 
	 * @param dec
	 *            the new source decoration
	 * @since 2.0
	 */
	public void setSourceDecoration(RotatableDecoration dec) {
		if (startArrow == dec)
			return;
		if (startArrow != null)
			remove(startArrow);
		startArrow = dec;
		if (startArrow != null)
			add(startArrow, new ArrowLocator(this, ConnectionLocator.SOURCE));
	}

	/**
	 * Sets the anchor to be used at the end of the polyline connection. Removes
	 * this listener from the old anchor and adds it to the new anchor.
	 * 
	 * @param anchor
	 *            the new target anchor
	 */
	public void setTargetAnchor(ConnectionAnchor anchor) {
		if (anchor == endAnchor)
			return;
		unhookTargetAnchor();
		// No longer needed, revalidate does this.
		// getConnectionRouter().invalidate(this);
		endAnchor = anchor;
		if (getParent() != null)
			hookTargetAnchor();
		revalidate();
	}

	/**
	 * Sets the decoration to be used at the end of the {@link Connection}.
	 * 
	 * @param dec
	 *            the new target decoration
	 */
	public void setTargetDecoration(RotatableDecoration dec) {
		if (endArrow == dec)
			return;
		if (endArrow != null)
			remove(endArrow);
		endArrow = dec;
		if (endArrow != null)
			add(endArrow, new ArrowLocator(this, ConnectionLocator.TARGET));
	}

	private void unhookSourceAnchor() {
		if (getSourceAnchor() != null)
			getSourceAnchor().removeAnchorListener(this);
	}

	private void unhookTargetAnchor() {
		if (getTargetAnchor() != null)
			getTargetAnchor().removeAnchorListener(this);
	}

	final class RoutingNotifier implements ConnectionRouter {

		ConnectionRouter realRouter;
		List listeners = new ArrayList(1);

		RoutingNotifier(ConnectionRouter router, RoutingListener listener) {
			realRouter = router;
			listeners.add(listener);
		}

		public Object getConstraint(Connection connection) {
			return realRouter.getConstraint(connection);
		}

		public void invalidate(Connection connection) {
			for (int i = 0; i < listeners.size(); i++)
				((RoutingListener) listeners.get(i)).invalidate(connection);

			realRouter.invalidate(connection);
		}

		public void route(Connection connection) {
			boolean consumed = false;
			for (int i = 0; i < listeners.size(); i++)
				consumed |= ((RoutingListener) listeners.get(i))
						.route(connection);

			if (!consumed)
				realRouter.route(connection);

			for (int i = 0; i < listeners.size(); i++)
				((RoutingListener) listeners.get(i)).postRoute(connection);
		}

		public void remove(Connection connection) {
			for (int i = 0; i < listeners.size(); i++)
				((RoutingListener) listeners.get(i)).remove(connection);
			realRouter.remove(connection);
		}

		public void setConstraint(Connection connection, Object constraint) {
			for (int i = 0; i < listeners.size(); i++)
				((RoutingListener) listeners.get(i)).setConstraint(connection,
						constraint);
			realRouter.setConstraint(connection, constraint);
		}

	}

}"
1104;12;7120110;long method;none;2019-03-29 13:31:01.154177;function;com.microsoftopentechnologies.azchat.web.data.beans.UserMessageBean#getMediaType;git@github.com:Microsoft/azure-chat-for-java.git;4456bea8830c5edf8c211db1d7816b849372d6ed;/azchat-web/src/main/java/com/microsoftopentechnologies/azchat/web/data/beans/UserMessageBean.java;91;93;https://github.com/Microsoft/azure-chat-for-java/blob/4456bea8830c5edf8c211db1d7816b849372d6ed/azchat-web/src/main/java/com/microsoftopentechnologies/azchat/web/data/beans/UserMessageBean.java/#L91-L93;0;"	public String getMediaType() {
		return mediaType;
	}"
14669;4;6019048;data class;major;2019-09-12 08:07:48.089383;class;org.cloudfoundry.identity.uaa.account.ChangeEmailController.ValidEmail;git@github.com:cloudfoundry/uaa.git;f3b66dd2a250c1309a86cade560ac9a9cfeafec7;/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java;147;158;https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158;1;"    public static class ValidEmail {
        @Email
        String newEmail;

        public String getNewEmail() {
            return newEmail;
        }

        public void setNewEmail(String email) {
            this.newEmail = email;
        }
    }"
1415;1;7483452;feature envy;none;2019-03-29 13:50:03.109027;function;example.service.Customer123Service.Customer123Service Customer123Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer123Service.java;9;10;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer123Service.java/#L9-L10;0;"	public Customer123Service(Customer123Repository repo) {
	}"
12666;3;3922349;long method;major;2019-08-06 20:12:56.162053;function;org.apache.aries.rsa.discovery.endpoint.PropertiesMapper#fromProps Map<String, Object>;git@github.com:apache/aries-rsa.git;f5aa5ca62c3948d7e471c3a839089180650cf4f2;/discovery/local/src/main/java/org/apache/aries/rsa/discovery/endpoint/PropertiesMapper.java;233;280;https://github.com/apache/aries-rsa/blob/f5aa5ca62c3948d7e471c3a839089180650cf4f2/discovery/local/src/main/java/org/apache/aries/rsa/discovery/endpoint/PropertiesMapper.java/#L233-L280;1;"    public List<PropertyType> fromProps(Map<String, Object> m) {
        List<PropertyType> props = new ArrayList<PropertyType>();
        for (Map.Entry<String, Object> entry : m.entrySet()) {
            String key = entry.getKey();
            Object val = entry.getValue();

            PropertyType propEl = new PropertyType();
            propEl.setName(key);
            ObjectFactory factory = new ObjectFactory();
            if (val.getClass().isArray()) {
                ArrayType arrayEl = new ArrayType();
                propEl.getContent().add(factory.createArray(arrayEl));
                for (Object o : normalizeArray(val)) {
                    setValueType(propEl, o);
                    ValueType valueType =  new ValueType();
                    valueType.getContent().add(o.toString());
                    arrayEl.getValue().add(valueType);
                }
            } else if (val instanceof List) {
                ArrayType listEl = new ArrayType();
                propEl.getContent().add(factory.createList(listEl));
                handleCollectionValue((Collection<?>) val, propEl, listEl);
            } else if (val instanceof Set) {
                ArrayType setEl = new ArrayType();
                propEl.getContent().add(factory.createSet(setEl));
                handleCollectionValue((Collection<?>) val, propEl, setEl);
            } else if (val instanceof String
                    || val instanceof Character
                    || val instanceof Boolean
                    || val instanceof Byte) {
                setValueType(propEl, val);
                propEl.setValue(val.toString());
            } else if (val instanceof Long
                    || val instanceof Double
                    || val instanceof Float
                    || val instanceof Integer
                    || val instanceof Short) {
                // various numbers..   maybe ""val instanceof Number""?
                setValueType(propEl, val);
                propEl.setValue(val.toString());
            } else {
                // Don't add this property as the value type is not supported
                continue;
            }
            props.add(propEl);
        }
        return props;
    }"
15008;13;9104666;blob;major;2019-09-12 10:13:38.373808;class;com.oracle.truffle.r.nodes.control.WhileNode;git@github.com:oracle/fastr.git;a1ee49060317621c0c9eceea8ec60040aca59b2d;/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/control/WhileNode.java;42;114;https://github.com/oracle/fastr/blob/a1ee49060317621c0c9eceea8ec60040aca59b2d/com.oracle.truffle.r.nodes/src/com/oracle/truffle/r/nodes/control/WhileNode.java/#L42-L114;1;"public final class WhileNode extends AbstractLoopNode implements RSyntaxNode, RSyntaxCall {

    @Child private LoopNode loop;
    @Child private SetVisibilityNode visibility = SetVisibilityNode.create();

    public WhileNode(SourceSection src, RSyntaxLookup operator, RSyntaxNode condition, RSyntaxNode body) {
        super(src, operator);
        this.loop = Truffle.getRuntime().createLoopNode(new WhileRepeatingNode(this, ConvertBooleanNode.create(condition), body.asRNode()));
    }

    @Override
    public Object execute(VirtualFrame frame) {
        loop.executeLoop(frame);
        visibility.execute(frame, false);
        return RNull.instance;
    }

    private static final class WhileRepeatingNode extends AbstractRepeatingNode {

        @Child private ConvertBooleanNode condition;

        private final ConditionProfile conditionProfile = ConditionProfile.createCountingProfile();
        private final BranchProfile normalBlock = BranchProfile.create();
        private final BranchProfile breakBlock = BranchProfile.create();
        private final BranchProfile nextBlock = BranchProfile.create();

        // only used for toString
        private final WhileNode whileNode;

        WhileRepeatingNode(WhileNode whileNode, ConvertBooleanNode condition, RNode body) {
            super(body);
            this.whileNode = whileNode;
            this.condition = condition;
            // pre-initialize the profile so that loop exits to not deoptimize
            conditionProfile.profile(false);
        }

        @Override
        public boolean executeRepeating(VirtualFrame frame) {
            try {
                if (conditionProfile.profile(condition.executeByte(frame) == RRuntime.LOGICAL_TRUE)) {
                    body.voidExecute(frame);
                    normalBlock.enter();
                    return true;
                } else {
                    return false;
                }
            } catch (BreakException e) {
                breakBlock.enter();
                return false;
            } catch (NextException e) {
                nextBlock.enter();
                return true;
            }
        }

        @Override
        public String toString() {
            return whileNode.toString();
        }
    }

    @Override
    public RSyntaxElement[] getSyntaxArguments() {
        WhileRepeatingNode repeatingNode = (WhileRepeatingNode) loop.getRepeatingNode();
        return new RSyntaxElement[]{repeatingNode.condition.asRSyntaxNode(), repeatingNode.body.asRSyntaxNode()};
    }

    @Override
    public ArgumentsSignature getSyntaxSignature() {
        return ArgumentsSignature.empty(2);
    }
}"
11738;3;7372240;blob;major;2019-08-05 15:58:01.684352;class;org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer;git@github.com:spring-projects/spring-boot.git;2225b362991f225e3a93f00e160526d2b8abdfb2;/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/annotation/EndpointDiscoverer.java;67;532;https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/annotation/EndpointDiscoverer.java/#L67-L532;1;"public abstract class EndpointDiscoverer<E extends ExposableEndpoint<O>, O extends Operation>
		implements EndpointsSupplier<E> {

	private final ApplicationContext applicationContext;

	private final Collection<EndpointFilter<E>> filters;

	private final DiscoveredOperationsFactory<O> operationsFactory;

	private final Map<EndpointBean, E> filterEndpoints = new ConcurrentHashMap<>();

	private volatile Collection<E> endpoints;

	/**
	 * Create a new {@link EndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param filters filters to apply
	 */
	public EndpointDiscoverer(ApplicationContext applicationContext,
			ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<E>> filters) {
		Assert.notNull(applicationContext, ""ApplicationContext must not be null"");
		Assert.notNull(parameterValueMapper, ""ParameterValueMapper must not be null"");
		Assert.notNull(invokerAdvisors, ""InvokerAdvisors must not be null"");
		Assert.notNull(filters, ""Filters must not be null"");
		this.applicationContext = applicationContext;
		this.filters = Collections.unmodifiableCollection(filters);
		this.operationsFactory = getOperationsFactory(parameterValueMapper,
				invokerAdvisors);
	}

	private DiscoveredOperationsFactory<O> getOperationsFactory(
			ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors) {
		return new DiscoveredOperationsFactory<O>(parameterValueMapper, invokerAdvisors) {

			@Override
			protected O createOperation(EndpointId endpointId,
					DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
				return EndpointDiscoverer.this.createOperation(endpointId,
						operationMethod, invoker);
			}

		};
	}

	@Override
	public final Collection<E> getEndpoints() {
		if (this.endpoints == null) {
			this.endpoints = discoverEndpoints();
		}
		return this.endpoints;
	}

	private Collection<E> discoverEndpoints() {
		Collection<EndpointBean> endpointBeans = createEndpointBeans();
		addExtensionBeans(endpointBeans);
		return convertToEndpoints(endpointBeans);
	}

	private Collection<EndpointBean> createEndpointBeans() {
		Map<EndpointId, EndpointBean> byId = new LinkedHashMap<>();
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(
				this.applicationContext, Endpoint.class);
		for (String beanName : beanNames) {
			if (!ScopedProxyUtils.isScopedTarget(beanName)) {
				EndpointBean endpointBean = createEndpointBean(beanName);
				EndpointBean previous = byId.putIfAbsent(endpointBean.getId(),
						endpointBean);
				Assert.state(previous == null,
						() -> ""Found two endpoints with the id '"" + endpointBean.getId()
								+ ""': '"" + endpointBean.getBeanName() + ""' and '""
								+ previous.getBeanName() + ""'"");
			}
		}
		return byId.values();
	}

	private EndpointBean createEndpointBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new EndpointBean(beanName, bean);
	}

	private void addExtensionBeans(Collection<EndpointBean> endpointBeans) {
		Map<EndpointId, EndpointBean> byId = endpointBeans.stream()
				.collect(Collectors.toMap(EndpointBean::getId, Function.identity()));
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(
				this.applicationContext, EndpointExtension.class);
		for (String beanName : beanNames) {
			ExtensionBean extensionBean = createExtensionBean(beanName);
			EndpointBean endpointBean = byId.get(extensionBean.getEndpointId());
			Assert.state(endpointBean != null,
					() -> (""Invalid extension '"" + extensionBean.getBeanName()
							+ ""': no endpoint found with id '""
							+ extensionBean.getEndpointId() + ""'""));
			addExtensionBean(endpointBean, extensionBean);
		}
	}

	private ExtensionBean createExtensionBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new ExtensionBean(beanName, bean);
	}

	private void addExtensionBean(EndpointBean endpointBean,
			ExtensionBean extensionBean) {
		if (isExtensionExposed(endpointBean, extensionBean)) {
			Assert.state(
					isEndpointExposed(endpointBean) || isEndpointFiltered(endpointBean),
					() -> ""Endpoint bean '"" + endpointBean.getBeanName()
							+ ""' cannot support the extension bean '""
							+ extensionBean.getBeanName() + ""'"");
			endpointBean.addExtension(extensionBean);
		}
	}

	private Collection<E> convertToEndpoints(Collection<EndpointBean> endpointBeans) {
		Set<E> endpoints = new LinkedHashSet<>();
		for (EndpointBean endpointBean : endpointBeans) {
			if (isEndpointExposed(endpointBean)) {
				endpoints.add(convertToEndpoint(endpointBean));
			}
		}
		return Collections.unmodifiableSet(endpoints);
	}

	private E convertToEndpoint(EndpointBean endpointBean) {
		MultiValueMap<OperationKey, O> indexed = new LinkedMultiValueMap<>();
		EndpointId id = endpointBean.getId();
		addOperations(indexed, id, endpointBean.getBean(), false);
		if (endpointBean.getExtensions().size() > 1) {
			String extensionBeans = endpointBean.getExtensions().stream()
					.map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(
					""Found multiple extensions for the endpoint bean ""
							+ endpointBean.getBeanName() + "" ("" + extensionBeans + "")"");
		}
		for (ExtensionBean extensionBean : endpointBean.getExtensions()) {
			addOperations(indexed, id, extensionBean.getBean(), true);
		}
		assertNoDuplicateOperations(endpointBean, indexed);
		List<O> operations = indexed.values().stream().map(this::getLast)
				.filter(Objects::nonNull).collect(Collectors.collectingAndThen(
						Collectors.toList(), Collections::unmodifiableList));
		return createEndpoint(endpointBean.getBean(), id,
				endpointBean.isEnabledByDefault(), operations);
	}

	private void addOperations(MultiValueMap<OperationKey, O> indexed, EndpointId id,
			Object target, boolean replaceLast) {
		Set<OperationKey> replacedLast = new HashSet<>();
		Collection<O> operations = this.operationsFactory.createOperations(id, target);
		for (O operation : operations) {
			OperationKey key = createOperationKey(operation);
			O last = getLast(indexed.get(key));
			if (replaceLast && replacedLast.add(key) && last != null) {
				indexed.get(key).remove(last);
			}
			indexed.add(key, operation);
		}
	}

	private <T> T getLast(List<T> list) {
		return CollectionUtils.isEmpty(list) ? null : list.get(list.size() - 1);
	}

	private void assertNoDuplicateOperations(EndpointBean endpointBean,
			MultiValueMap<OperationKey, O> indexed) {
		List<OperationKey> duplicates = indexed.entrySet().stream()
				.filter((entry) -> entry.getValue().size() > 1).map(Map.Entry::getKey)
				.collect(Collectors.toList());
		if (!duplicates.isEmpty()) {
			Set<ExtensionBean> extensions = endpointBean.getExtensions();
			String extensionBeanNames = extensions.stream()
					.map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(
					""Unable to map duplicate endpoint operations: ""
							+ duplicates.toString() + "" to "" + endpointBean.getBeanName()
							+ (extensions.isEmpty() ? """"
									: "" ("" + extensionBeanNames + "")""));
		}
	}

	private boolean isExtensionExposed(EndpointBean endpointBean,
			ExtensionBean extensionBean) {
		return isFilterMatch(extensionBean.getFilter(), endpointBean)
				&& isExtensionExposed(extensionBean.getBean());
	}

	/**
	 * Determine if an extension bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param extensionBean the extension bean
	 * @return {@code true} if the extension is exposed
	 */
	protected boolean isExtensionExposed(Object extensionBean) {
		return true;
	}

	private boolean isEndpointExposed(EndpointBean endpointBean) {
		return isFilterMatch(endpointBean.getFilter(), endpointBean)
				&& !isEndpointFiltered(endpointBean)
				&& isEndpointExposed(endpointBean.getBean());
	}

	/**
	 * Determine if an endpoint bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param endpointBean the endpoint bean
	 * @return {@code true} if the endpoint is exposed
	 */
	protected boolean isEndpointExposed(Object endpointBean) {
		return true;
	}

	private boolean isEndpointFiltered(EndpointBean endpointBean) {
		for (EndpointFilter<E> filter : this.filters) {
			if (!isFilterMatch(filter, endpointBean)) {
				return true;
			}
		}
		return false;
	}

	@SuppressWarnings(""unchecked"")
	private boolean isFilterMatch(Class<?> filter, EndpointBean endpointBean) {
		if (!isEndpointExposed(endpointBean.getBean())) {
			return false;
		}
		if (filter == null) {
			return true;
		}
		E endpoint = getFilterEndpoint(endpointBean);
		Class<?> generic = ResolvableType.forClass(EndpointFilter.class, filter)
				.resolveGeneric(0);
		if (generic == null || generic.isInstance(endpoint)) {
			EndpointFilter<E> instance = (EndpointFilter<E>) BeanUtils
					.instantiateClass(filter);
			return isFilterMatch(instance, endpoint);
		}
		return false;

	}

	private boolean isFilterMatch(EndpointFilter<E> filter, EndpointBean endpointBean) {
		return isFilterMatch(filter, getFilterEndpoint(endpointBean));
	}

	@SuppressWarnings(""unchecked"")
	private boolean isFilterMatch(EndpointFilter<E> filter, E endpoint) {
		return LambdaSafe.callback(EndpointFilter.class, filter, endpoint)
				.withLogger(EndpointDiscoverer.class).invokeAnd((f) -> f.match(endpoint))
				.get();
	}

	private E getFilterEndpoint(EndpointBean endpointBean) {
		E endpoint = this.filterEndpoints.get(endpointBean);
		if (endpoint == null) {
			endpoint = createEndpoint(endpointBean.getBean(), endpointBean.getId(),
					endpointBean.isEnabledByDefault(), Collections.emptySet());
			this.filterEndpoints.put(endpointBean, endpoint);
		}
		return endpoint;
	}

	@SuppressWarnings(""unchecked"")
	protected Class<? extends E> getEndpointType() {
		return (Class<? extends E>) ResolvableType
				.forClass(EndpointDiscoverer.class, getClass()).resolveGeneric(0);
	}

	/**
	 * Factory method called to create the {@link ExposableEndpoint endpoint}.
	 * @param endpointBean the source endpoint bean
	 * @param id the ID of the endpoint
	 * @param enabledByDefault if the endpoint is enabled by default
	 * @param operations the endpoint operations
	 * @return a created endpoint (a {@link DiscoveredEndpoint} is recommended)
	 */
	protected abstract E createEndpoint(Object endpointBean, EndpointId id,
			boolean enabledByDefault, Collection<O> operations);

	/**
	 * Factory method to create an {@link Operation endpoint operation}.
	 * @param endpointId the endpoint id
	 * @param operationMethod the operation method
	 * @param invoker the invoker to use
	 * @return a created operation
	 */
	protected abstract O createOperation(EndpointId endpointId,
			DiscoveredOperationMethod operationMethod, OperationInvoker invoker);

	/**
	 * Create an {@link OperationKey} for the given operation.
	 * @param operation the source operation
	 * @return the operation key
	 */
	protected abstract OperationKey createOperationKey(O operation);

	/**
	 * A key generated for an {@link Operation} based on specific criteria from the actual
	 * operation implementation.
	 */
	protected static final class OperationKey {

		private final Object key;

		private final Supplier<String> description;

		/**
		 * Create a new {@link OperationKey} instance.
		 * @param key the underlying key for the operation
		 * @param description a human readable description of the key
		 */
		public OperationKey(Object key, Supplier<String> description) {
			Assert.notNull(key, ""Key must not be null"");
			Assert.notNull(description, ""Description must not be null"");
			this.key = key;
			this.description = description;
		}

		@Override
		public boolean equals(Object obj) {
			if (obj == this) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.key.equals(((OperationKey) obj).key);
		}

		@Override
		public int hashCode() {
			return this.key.hashCode();
		}

		@Override
		public String toString() {
			return this.description.get();
		}

	}

	/**
	 * Information about an {@link Endpoint @Endpoint} bean.
	 */
	private static class EndpointBean {

		private final String beanName;

		private final Object bean;

		private final EndpointId id;

		private boolean enabledByDefault;

		private final Class<?> filter;

		private Set<ExtensionBean> extensions = new LinkedHashSet<>();

		EndpointBean(String beanName, Object bean) {
			AnnotationAttributes attributes = AnnotatedElementUtils
					.findMergedAnnotationAttributes(bean.getClass(), Endpoint.class, true,
							true);
			String id = attributes.getString(""id"");
			Assert.state(StringUtils.hasText(id),
					() -> ""No @Endpoint id attribute specified for ""
							+ bean.getClass().getName());
			this.beanName = beanName;
			this.bean = bean;
			this.id = EndpointId.of(id);
			this.enabledByDefault = (Boolean) attributes.get(""enableByDefault"");
			this.filter = getFilter(this.bean.getClass());
		}

		public void addExtension(ExtensionBean extensionBean) {
			this.extensions.add(extensionBean);
		}

		public Set<ExtensionBean> getExtensions() {
			return this.extensions;
		}

		private Class<?> getFilter(Class<?> type) {
			AnnotationAttributes attributes = AnnotatedElementUtils
					.getMergedAnnotationAttributes(type, FilteredEndpoint.class);
			if (attributes == null) {
				return null;
			}
			return attributes.getClass(""value"");
		}

		public String getBeanName() {
			return this.beanName;
		}

		public Object getBean() {
			return this.bean;
		}

		public EndpointId getId() {
			return this.id;
		}

		public boolean isEnabledByDefault() {
			return this.enabledByDefault;
		}

		public Class<?> getFilter() {
			return this.filter;
		}

	}

	/**
	 * Information about an {@link EndpointExtension EndpointExtension} bean.
	 */
	private static class ExtensionBean {

		private final String beanName;

		private final Object bean;

		private final EndpointId endpointId;

		private final Class<?> filter;

		ExtensionBean(String beanName, Object bean) {
			this.bean = bean;
			this.beanName = beanName;
			AnnotationAttributes attributes = AnnotatedElementUtils
					.getMergedAnnotationAttributes(bean.getClass(),
							EndpointExtension.class);
			Class<?> endpointType = attributes.getClass(""endpoint"");
			AnnotationAttributes endpointAttributes = AnnotatedElementUtils
					.findMergedAnnotationAttributes(endpointType, Endpoint.class, true,
							true);
			Assert.state(endpointAttributes != null, () -> ""Extension ""
					+ endpointType.getName() + "" does not specify an endpoint"");
			this.endpointId = EndpointId.of(endpointAttributes.getString(""id""));
			this.filter = attributes.getClass(""filter"");
		}

		public String getBeanName() {
			return this.beanName;
		}

		public Object getBean() {
			return this.bean;
		}

		public EndpointId getEndpointId() {
			return this.endpointId;
		}

		public Class<?> getFilter() {
			return this.filter;
		}

	}

}"
3767;16;6666668;long method;none;2019-04-05 13:23:55.577247;function;com.facebook.ads.sdk.ProductItemCommerceInsights.ProductItemCommerceInsights;git@github.com:facebook/facebook-java-business-sdk.git;561f1a75e1220b55a160a1b92b0187f72be9cd08;/src/main/java/com/facebook/ads/sdk/ProductItemCommerceInsights.java;66;67;https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/ProductItemCommerceInsights.java/#L66-L67;1;"  public ProductItemCommerceInsights() {
  }"
7885;3;4901851;feature envy;major;2019-07-17 19:27:54.525186;function;org.apache.jackrabbit.oak.security.authentication.token.TokenValidatorProvider.TokenValidator#childNodeChanged String|NodeState|NodeState;git@github.com:apache/jackrabbit-oak.git;fa85f54a065e01c0a1cb8c03af74194fdf521ddd;/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenValidatorProvider.java;130;142;https://github.com/apache/jackrabbit-oak/blob/fa85f54a065e01c0a1cb8c03af74194fdf521ddd/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenValidatorProvider.java/#L130-L142;1;"        @Override
        public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
            Tree beforeTree = (parentBefore == null) ? null : parentBefore.getChild(name);
            Tree afterTree = parentAfter.getChild(name);

            if (isTokenTree(beforeTree) || isTokenTree(afterTree)) {
                validateTokenTree(afterTree);
            } else if (isTokensParent(beforeTree) || isTokensParent(afterTree)) {
                validateTokensParent(afterTree);
            }

            return new VisibleValidator(new TokenValidator(beforeTree, afterTree, commitInfo), true, true);
        }"
4060;5;4830091;feature envy;major;2019-04-05 15:17:24.049503;function;org.apache.isis.schema.services.jaxb.JaxbServiceDefault#configure Marshaller;git@github.com:apache/isis.git;2af2ef3e2edcb807d742f089839e0571d8132bd9;/core/applib/src/main/java/org/apache/isis/schema/services/jaxb/JaxbServiceDefault.java;93;99;https://github.com/apache/isis/blob/2af2ef3e2edcb807d742f089839e0571d8132bd9/core/applib/src/main/java/org/apache/isis/schema/services/jaxb/JaxbServiceDefault.java/#L93-L99;1;"    @Override
    protected void configure(final Marshaller marshaller) {
        marshaller.setAdapter(PersistentEntityAdapter.class,
                serviceRegistry.injectServicesInto(new PersistentEntityAdapter()));
        marshaller.setAdapter(PersistentEntitiesAdapter.class,
                serviceRegistry.injectServicesInto(new PersistentEntitiesAdapter()));
    }"
10772;4;4256584;feature envy;major;2019-07-26 20:12:30.751771;function;org.apache.commons.net.discard.DiscardUDPClient#send byte[]|int|InetAddress|int;git@github.com:apache/commons-net.git;fb7aae4c64f7d2bf6dced00c49c3ffc428b2d572;/src/main/java/org/apache/commons/net/discard/DiscardUDPClient.java;63;71;https://github.com/apache/commons-net/blob/fb7aae4c64f7d2bf6dced00c49c3ffc428b2d572/src/main/java/org/apache/commons/net/discard/DiscardUDPClient.java/#L63-L71;1;"    public void send(byte[] data, int length, InetAddress host, int port)
    throws IOException
    {
        _sendPacket.setData(data);
        _sendPacket.setLength(length);
        _sendPacket.setAddress(host);
        _sendPacket.setPort(port);
        _socket_.send(_sendPacket);
    }"
6319;7;5182713;blob;major;2019-04-23 16:34:38.645496;class;org.apache.kylin.source.datagen.ModelDataGenerator;git@github.com:apache/kylin.git;6ee0212af9d5b50096850c9cb76031b7cdd67402;/core-metadata/src/main/java/org/apache/kylin/source/datagen/ModelDataGenerator.java;56;328;https://github.com/apache/kylin/blob/6ee0212af9d5b50096850c9cb76031b7cdd67402/core-metadata/src/main/java/org/apache/kylin/source/datagen/ModelDataGenerator.java/#L56-L328;1;"public class ModelDataGenerator {
    private static final Logger logger = LoggerFactory.getLogger(ModelDataGenerator.class);
    final private DataModelDesc model;
    final private int targetRows;
    final private ResourceStore outputStore;
    final private String outputPath;

    boolean outprint = false; // for debug

    public ModelDataGenerator(DataModelDesc model, int nRows) {
        this(model, nRows, ResourceStore.getStore(model.getConfig()));
    }

    private ModelDataGenerator(DataModelDesc model, int nRows, ResourceStore outputStore) {
        this(model, nRows, outputStore, ""/data"");
    }

    private ModelDataGenerator(DataModelDesc model, int nRows, ResourceStore outputStore, String outputPath) {
        this.model = model;
        this.targetRows = nRows;
        this.outputStore = outputStore;
        this.outputPath = outputPath;
    }

    public void generate() throws IOException {
        Set<TableDesc> generated = new HashSet<>();
        Set<TableDesc> allTableDesc = new LinkedHashSet<>();

        JoinTableDesc[] allTables = model.getJoinTables();
        for (int i = allTables.length - 1; i >= -1; i--) { // reverse order needed for FK generation
            TableDesc table = (i == -1) ? model.getRootFactTable().getTableDesc()
                    : allTables[i].getTableRef().getTableDesc();
            allTableDesc.add(table);

            if (generated.contains(table))
                continue;

            logger.info(String.format(Locale.ROOT, ""generating data for %s"", table));
            boolean gen = generateTable(table);

            if (gen)
                generated.add(table);
        }

        generateDDL(allTableDesc);
    }

    private boolean generateTable(TableDesc table) throws IOException {
        TableGenConfig config = new TableGenConfig(table, this);
        if (!config.needGen)
            return false;

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        PrintWriter pout = new PrintWriter(new OutputStreamWriter(bout, StandardCharsets.UTF_8));

        generateTableInternal(table, config, pout);

        pout.close();
        bout.close();

        saveResource(bout.toByteArray(), path(table));
        return true;
    }

    private void generateTableInternal(TableDesc table, TableGenConfig config, PrintWriter out) throws IOException {
        ColumnDesc[] columns = table.getColumns();
        ColumnGenerator[] colGens = new ColumnGenerator[columns.length];
        Iterator<String>[] colIters = new Iterator[columns.length];

        // config.rows is either a multiplier (0,1] or an absolute row number
        int tableRows = (int) ((config.rows > 1) ? config.rows : targetRows * config.rows);
        tableRows = Math.max(1, tableRows);

        // same seed for all columns, to ensure composite FK columns generate correct pairs
        long seed = System.currentTimeMillis();

        for (int i = 0; i < columns.length; i++) {
            colGens[i] = new ColumnGenerator(columns[i], tableRows, this);
            colIters[i] = colGens[i].generate(seed);
        }

        for (int i = 0; i < tableRows; i++) {
            for (int c = 0; c < columns.length; c++) {
                if (c > 0)
                    out.print("","");

                String v = colIters[c].next();
                Preconditions.checkState(v == null || !v.contains("",""));

                out.print(v);
            }
            out.print(""\n"");
        }
    }

    private void generateDDL(Set<TableDesc> tables) throws IOException {

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        PrintWriter pout = new PrintWriter(new OutputStreamWriter(bout, StandardCharsets.UTF_8));

        generateDatabaseDDL(tables, pout);
        generateCreateTableDDL(tables, pout);
        generateLoadDataDDL(tables, pout);

        pout.close();
        bout.close();

        saveResource(bout.toByteArray(), path(model));
    }

    private void generateDatabaseDDL(Set<TableDesc> tables, PrintWriter out) {
        Set<String> dbs = new HashSet<>();
        for (TableDesc t : tables) {
            String db = t.getDatabase();
            if (StringUtils.isBlank(db) == false && ""DEFAULT"".equals(db) == false)
                dbs.add(db);
        }

        for (String db : dbs) {
            out.print(""CREATE DATABASE IF NOT EXISTS "" + normHiveIdentifier(db) + "";\n"");
        }
        out.print(""\n"");
    }

    private void generateCreateTableDDL(Set<TableDesc> tables, PrintWriter out) {
        for (TableDesc t : tables) {
            if (t.isView())
                continue;

            out.print(""DROP TABLE IF EXISTS "" + normHiveIdentifier(t.getIdentity()) + "";\n"");

            out.print(""CREATE TABLE "" + normHiveIdentifier(t.getIdentity()) + ""("" + ""\n"");

            for (int i = 0; i < t.getColumns().length; i++) {
                ColumnDesc col = t.getColumns()[i];
                out.print(""    "");
                if (i > 0) {
                    out.print("","");
                }
                out.print(normHiveIdentifier(col.getName()) + "" "" + hiveType(col.getType()) + ""\n"");
            }

            out.print("")"" + ""\n"");
            out.print(""ROW FORMAT DELIMITED FIELDS TERMINATED BY ','"" + ""\n"");
            out.print(""STORED AS TEXTFILE"" + "";\n"");
            out.print(""\n"");
        }
    }

    private String normHiveIdentifier(String orig) {
        return ""`"" + orig + ""`"";
    }

    private String hiveType(DataType type) {
        String t = type.toString();
        if (t.startsWith(""varchar""))
            return ""string"";
        else if (t.startsWith(""integer""))
            return ""int"";
        else
            return t;
    }

    private void generateLoadDataDDL(Set<TableDesc> tables, PrintWriter out) {
        for (TableDesc t : tables) {
            if (t.isView()) {
                out.print(""-- "" + t.getIdentity() + "" is view \n"");
                continue;
            }

            out.print(""LOAD DATA LOCAL INPATH '"" + t.getIdentity() + "".csv' OVERWRITE INTO TABLE ""
                    + normHiveIdentifier(t.getIdentity()) + "";\n"");
        }
    }

    public boolean existsInStore(TableDesc table) throws IOException {
        return outputStore.exists(path(table));
    }

    public boolean isPK(ColumnDesc col) {
        for (JoinTableDesc joinTable : model.getJoinTables()) {
            JoinDesc join = joinTable.getJoin();
            for (TblColRef pk : join.getPrimaryKeyColumns()) {
                if (pk.getColumnDesc().equals(col))
                    return true;
            }
        }
        return false;
    }

    public List<String> getPkValuesIfIsFk(ColumnDesc fk) throws IOException {
        JoinTableDesc[] joinTables = model.getJoinTables();
        for (int i = 0; i < joinTables.length; i++) {
            JoinTableDesc joinTable = joinTables[i];
            ColumnDesc pk = findPk(joinTable, fk);
            if (pk == null)
                continue;

            List<String> pkValues = getPkValues(pk);
            if (pkValues != null)
                return pkValues;
        }
        return null;
    }

    private ColumnDesc findPk(JoinTableDesc joinTable, ColumnDesc fk) {
        TblColRef[] fkCols = joinTable.getJoin().getForeignKeyColumns();
        for (int i = 0; i < fkCols.length; i++) {
            if (fkCols[i].getColumnDesc().equals(fk))
                return joinTable.getJoin().getPrimaryKeyColumns()[i].getColumnDesc();
        }
        return null;
    }

    public List<String> getPkValues(ColumnDesc pk) throws IOException {
        if (existsInStore(pk.getTable()) == false)
            return null;

        List<String> r = new ArrayList<>();

        BufferedReader in = new BufferedReader(
                new InputStreamReader(outputStore.getResource(path(pk.getTable())).content(), ""UTF-8""));
        try {
            String line;
            while ((line = in.readLine()) != null) {
                r.add(line.split("","")[pk.getZeroBasedIndex()]);
            }
        } finally {
            IOUtils.closeQuietly(in);
        }
        return r;
    }

    private void saveResource(byte[] content, String path) throws IOException {
        System.out.println(""Generated "" + outputStore.getReadableResourcePath(path));
        if (outprint) {
            System.out.println(Bytes.toString(content));
        }
        outputStore.putResource(path, new ByteArrayInputStream(content), System.currentTimeMillis());
    }

    private String path(TableDesc table) {
        return outputPath + ""/"" + table.getIdentity() + "".csv"";
    }

    private String path(DataModelDesc model) {
        return outputPath + ""/"" + ""ddl_"" + model.getName() + "".sql"";
    }

    public DataModelDesc getModle() {
        return model;
    }

    public static void main(String[] args) throws IOException {
        String modelName = args[0];
        int nRows = Integer.parseInt(args[1]);
        String outputDir = args.length > 2 ? args[2] : null;

        KylinConfig conf = KylinConfig.getInstanceFromEnv();
        DataModelDesc model = DataModelManager.getInstance(conf).getDataModelDesc(modelName);
        ResourceStore store = outputDir == null ? ResourceStore.getStore(conf)
                : ResourceStore.getStore(mockup(outputDir));

        ModelDataGenerator gen = new ModelDataGenerator(model, nRows, store);
        gen.generate();
    }

    private static KylinConfig mockup(String outputDir) {
        KylinConfig mockup = KylinConfig.createKylinConfig(KylinConfig.getInstanceFromEnv());
        mockup.setMetadataUrl(new File(outputDir).getAbsolutePath());
        return mockup;
    }
}"
12460;3;5515226;data class;none;2019-08-06 16:34:59.686632;class;org.apache.rocketmq.common.constant.DBMsgConstants;git@github.com:apache/rocketmq.git;971fa8ed8b209b39bdfe41c57cd64576d244e6bd;/common/src/main/java/org/apache/rocketmq/common/constant/DBMsgConstants.java;20;22;https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/common/src/main/java/org/apache/rocketmq/common/constant/DBMsgConstants.java/#L20-L22;1;"public class DBMsgConstants {
    public static final int MAX_BODY_SIZE = 64 * 1024 * 1024; //64KB
}"
648;6;6016779;long method;none;2019-03-27 10:59:05.316731;function;org.cloudfoundry.client.v3.packages..PackageState String;git@github.com:cloudfoundry/cf-java-client.git;6fabcf647302158b638cf2c44cee389e1df9b964;/cloudfoundry-client/src/main/java/org/cloudfoundry/client/v3/packages/PackageState.java;59;61;https://github.com/cloudfoundry/cf-java-client/blob/6fabcf647302158b638cf2c44cee389e1df9b964/cloudfoundry-client/src/main/java/org/cloudfoundry/client/v3/packages/PackageState.java/#L59-L61;1;"    PackageState(String value) {
        this.value = value;
    }"
10404;30;4788662;long method;major;2019-07-26 09:51:54.239488;function;org.apache.sentry.provider.db.service.thrift.TListSentryPrivilegesRequest#equals TListSentryPrivilegesRequest;git@github.com:apache/incubator-sentry.git;4643f988a5e0ce2b9749e6365edea3a16482de86;/sentry-provider/sentry-provider-db/src/gen/thrift/gen-javabean/org/apache/sentry/provider/db/service/thrift/TListSentryPrivilegesRequest.java;360;401;https://github.com/apache/incubator-sentry/blob/4643f988a5e0ce2b9749e6365edea3a16482de86/sentry-provider/sentry-provider-db/src/gen/thrift/gen-javabean/org/apache/sentry/provider/db/service/thrift/TListSentryPrivilegesRequest.java/#L360-L401;0;"  public boolean equals(TListSentryPrivilegesRequest that) {
    if (that == null)
      return false;

    boolean this_present_protocol_version = true;
    boolean that_present_protocol_version = true;
    if (this_present_protocol_version || that_present_protocol_version) {
      if (!(this_present_protocol_version && that_present_protocol_version))
        return false;
      if (this.protocol_version != that.protocol_version)
        return false;
    }

    boolean this_present_requestorUserName = true && this.isSetRequestorUserName();
    boolean that_present_requestorUserName = true && that.isSetRequestorUserName();
    if (this_present_requestorUserName || that_present_requestorUserName) {
      if (!(this_present_requestorUserName && that_present_requestorUserName))
        return false;
      if (!this.requestorUserName.equals(that.requestorUserName))
        return false;
    }

    boolean this_present_roleName = true && this.isSetRoleName();
    boolean that_present_roleName = true && that.isSetRoleName();
    if (this_present_roleName || that_present_roleName) {
      if (!(this_present_roleName && that_present_roleName))
        return false;
      if (!this.roleName.equals(that.roleName))
        return false;
    }

    boolean this_present_authorizableHierarchy = true && this.isSetAuthorizableHierarchy();
    boolean that_present_authorizableHierarchy = true && that.isSetAuthorizableHierarchy();
    if (this_present_authorizableHierarchy || that_present_authorizableHierarchy) {
      if (!(this_present_authorizableHierarchy && that_present_authorizableHierarchy))
        return false;
      if (!this.authorizableHierarchy.equals(that.authorizableHierarchy))
        return false;
    }

    return true;
  }"
9355;13;5423428;feature envy;major;2019-07-23 16:06:04.933119;function;org.apache.phoenix.hbase.index.write.IndexWriter.getFailurePolicy RegionCoprocessorEnvironment;git@github.com:apache/phoenix.git;69e5bb0b304a53967cef40b2a4cfc66e69ecaa51;/phoenix-core/src/main/java/org/apache/phoenix/hbase/index/write/IndexWriter.java;87;100;https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/hbase/index/write/IndexWriter.java/#L87-L100;1;"  public static IndexFailurePolicy getFailurePolicy(RegionCoprocessorEnvironment env)
      throws IOException {
    Configuration conf = env.getConfiguration();
    try {
      IndexFailurePolicy committer =
          conf.getClass(INDEX_FAILURE_POLICY_CONF_KEY, PhoenixIndexFailurePolicy.class,
            IndexFailurePolicy.class).newInstance();
      return committer;
    } catch (InstantiationException e) {
      throw new IOException(e);
    } catch (IllegalAccessException e) {
      throw new IOException(e);
    }
  }"
1024;4;6940151;feature envy;none;2019-03-29 13:26:47.129551;function;com.google.gdata.util.VersionRegistry#getDefaultVersions;git@github.com:google/gdata-java-client.git;c6202a55f5f29afb37ffcf876674dca372f3fb4c;/java/src/com/google/gdata/util/VersionRegistry.java;201;203;https://github.com/google/gdata-java-client/blob/c6202a55f5f29afb37ffcf876674dca372f3fb4c/java/src/com/google/gdata/util/VersionRegistry.java/#L201-L203;0,5;"  public List<Version> getDefaultVersions() {
    return defaultVersions;
  }"
3086;14;7863608;blob;critical;2019-04-05 12:34:32.883113;class;org.apache.geode.internal.cache.persistence.PersistentReplicatedTestBase;git@github.com:apache/geode.git;8fd839e8b73e40bd2dfd14f331b587431bd35a66;/geode-core/src/distributedTest/java/org/apache/geode/internal/cache/persistence/PersistentReplicatedTestBase.java;42;242;https://github.com/apache/geode/blob/8fd839e8b73e40bd2dfd14f331b587431bd35a66/geode-core/src/distributedTest/java/org/apache/geode/internal/cache/persistence/PersistentReplicatedTestBase.java/#L42-L242;1;"public abstract class PersistentReplicatedTestBase extends JUnit4CacheTestCase {

  protected static final int MAX_WAIT = 60 * 1000;
  protected static String REGION_NAME = ""region"";
  protected File diskDir;
  protected static String SAVED_ACK_WAIT_THRESHOLD;

  @Override
  public final void postSetUp() throws Exception {
    Invoke.invokeInEveryVM(PersistentReplicatedTestBase.class, ""setRegionName"",
        new Object[] {getUniqueName()});
    setRegionName(getUniqueName());
    diskDir = new File(""diskDir-"" + getName()).getAbsoluteFile();
    FileUtils.deleteDirectory(diskDir);
    diskDir.mkdir();
    diskDir.deleteOnExit();
  }

  public static void setRegionName(String testName) {
    REGION_NAME = testName + ""Region"";
  }

  @Override
  public final void postTearDownCacheTestCase() throws Exception {
    FileUtils.deleteDirectory(diskDir);
    postTearDownPersistentReplicatedTestBase();
  }

  protected void postTearDownPersistentReplicatedTestBase() throws Exception {}

  protected void waitForBlockedInitialization(VM vm) {
    vm.invoke(new SerializableRunnable() {

      @Override
      public void run() {
        GeodeAwaitility.await().untilAsserted(new WaitCriterion() {

          @Override
          public String description() {
            return ""Waiting for another persistent member to come online"";
          }

          @Override
          public boolean done() {
            GemFireCacheImpl cache = (GemFireCacheImpl) getCache();
            PersistentMemberManager mm = cache.getPersistentMemberManager();
            Map<String, Set<PersistentMemberID>> regions = mm.getWaitingRegions();
            boolean done = !regions.isEmpty();
            return done;
          }

        });

      }

    });
  }

  protected SerializableRunnable createPersistentRegionWithoutCompaction(final VM vm0) {
    SerializableRunnable createRegion = new SerializableRunnable(""Create persistent region"") {
      @Override
      public void run() {
        Cache cache = getCache();
        DiskStoreFactory dsf = cache.createDiskStoreFactory();
        File dir = getDiskDirForVM(vm0);
        dir.mkdirs();
        dsf.setDiskDirs(new File[] {dir});
        dsf.setMaxOplogSize(1);
        dsf.setAutoCompact(false);
        dsf.setAllowForceCompaction(true);
        dsf.setCompactionThreshold(20);
        DiskStore ds = dsf.create(REGION_NAME);
        RegionFactory rf = new RegionFactory();
        rf.setDiskStoreName(ds.getName());
        rf.setDiskSynchronous(true);
        rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
        rf.setScope(Scope.DISTRIBUTED_ACK);
        rf.create(REGION_NAME);
      }
    };
    vm0.invoke(createRegion);
    return createRegion;
  }

  protected void closeRegion(final VM vm) {
    SerializableRunnable closeRegion = new SerializableRunnable(""Close persistent region"") {
      @Override
      public void run() {
        Cache cache = getCache();
        Region region = cache.getRegion(REGION_NAME);
        region.close();
      }
    };
    vm.invoke(closeRegion);
  }

  protected void closeCache(final VM vm) {
    SerializableRunnable closeCache = new SerializableRunnable(""close cache"") {
      @Override
      public void run() {
        Cache cache = getCache();
        cache.close();
      }
    };
    vm.invoke(closeCache);
  }

  protected AsyncInvocation closeCacheAsync(VM vm0) {
    SerializableRunnable close = new SerializableRunnable() {
      @Override
      public void run() {
        Cache cache = getCache();
        cache.close();
      }
    };

    return vm0.invokeAsync(close);
  }

  protected void createNonPersistentRegion(VM vm) throws Exception {
    SerializableRunnable createRegion = new SerializableRunnable(""Create non persistent region"") {
      @Override
      public void run() {
        Cache cache = getCache();
        RegionFactory rf = new RegionFactory();
        rf.setDataPolicy(DataPolicy.REPLICATE);
        rf.setScope(Scope.DISTRIBUTED_ACK);
        rf.create(REGION_NAME);
      }
    };
    vm.invoke(createRegion);
  }

  protected AsyncInvocation createPersistentRegionWithWait(VM vm) throws Exception {
    return _createPersistentRegion(vm, true);
  }

  protected void createPersistentRegion(VM vm) throws Exception {
    _createPersistentRegion(vm, false);
  }

  private AsyncInvocation _createPersistentRegion(VM vm, boolean wait) throws Exception {
    AsyncInvocation future = createPersistentRegionAsync(vm);
    long waitTime = wait ? 500 : MAX_WAIT;
    future.join(waitTime);
    if (future.isAlive() && !wait) {
      fail(""Region not created within"" + MAX_WAIT);
    }
    if (!future.isAlive() && wait) {
      fail(""Did not expect region creation to complete"");
    }
    if (!wait && future.exceptionOccurred()) {
      throw new RuntimeException(future.getException());
    }
    return future;
  }

  protected AsyncInvocation createPersistentRegionAsync(final VM vm) {
    SerializableRunnable createRegion = new SerializableRunnable(""Create persistent region"") {
      @Override
      public void run() {
        Cache cache = getCache();
        DiskStoreFactory dsf = cache.createDiskStoreFactory();
        File dir = getDiskDirForVM(vm);
        dir.mkdirs();
        dsf.setDiskDirs(new File[] {dir});
        dsf.setMaxOplogSize(1);
        DiskStore ds = dsf.create(REGION_NAME);
        RegionFactory rf = new RegionFactory();
        rf.setDiskStoreName(ds.getName());
        rf.setDiskSynchronous(true);
        rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
        rf.setScope(Scope.DISTRIBUTED_ACK);
        rf.create(REGION_NAME);
      }
    };
    return vm.invokeAsync(createRegion);
  }

  protected File getDiskDirForVM(final VM vm) {
    File dir = new File(diskDir, String.valueOf(vm.getId()));
    return dir;
  }

  protected void backupDir(VM vm) throws IOException {
    File dirForVM = getDiskDirForVM(vm);
    File backFile = new File(dirForVM.getParent(), dirForVM.getName() + "".bk"");
    FileUtils.copyDirectory(dirForVM, backFile);
  }

  protected void restoreBackup(VM vm) throws IOException {
    File dirForVM = getDiskDirForVM(vm);
    File backFile = new File(dirForVM.getParent(), dirForVM.getName() + "".bk"");
    if (!backFile.renameTo(dirForVM)) {
      FileUtils.deleteDirectory(dirForVM);
      FileUtils.copyDirectory(backFile, dirForVM);
      FileUtils.deleteDirectory(backFile);
    }
  }

}"
716;7;6241200;long method;none;2019-03-27 11:18:39.998893;function;org.eclipse.elk.alg.layered.p5edges.loops.labeling.ThreeCornerLoopLabelPositionGenerator.ThreeCornerLoopLabelPositionGenerator SelfLoopNode;git@github.com:eclipse/elk.git;9a87764f00d863463b1be6de1920d8aa3c3ade70;/plugins/org.eclipse.elk.alg.layered/src/org/eclipse/elk/alg/layered/p5edges/loops/labeling/ThreeCornerLoopLabelPositionGenerator.java;34;36;https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.alg.layered/src/org/eclipse/elk/alg/layered/p5edges/loops/labeling/ThreeCornerLoopLabelPositionGenerator.java/#L34-L36;1;"    public ThreeCornerLoopLabelPositionGenerator(final SelfLoopNode slNode) {
        super(slNode);
    }"
3068;17;4979404;data class;major;2019-04-05 12:32:31.607162;class;org.jclouds.profitbricks.domain.DataCenter.Request.CreatePayload;git@github.com:apache/jclouds.git;c2670079fabe74f163f43fbade0866469f7a84ec;/providers/profitbricks/src/main/java/org/jclouds/profitbricks/domain/DataCenter.java;103;110;https://github.com/apache/jclouds/blob/c2670079fabe74f163f43fbade0866469f7a84ec/providers/profitbricks/src/main/java/org/jclouds/profitbricks/domain/DataCenter.java/#L103-L110;1;"      @AutoValue
      public abstract static class CreatePayload {

         public abstract String name();

         public abstract Location location();

      }"
2121;3;8738655;blob;none;2019-04-01 13:20:45.636647;class;org.apache.airavata.registry.api.RegistryService.updateWorkflow_args.updateWorkflow_argsStandardSchemeFactory;git@github.com:apache/airavata.git;391843a00eefa7b6213e845f2f044b4e042894d5;/modules/registry/registry-server/registry-api-stubs/src/main/java/org/apache/airavata/registry/api/RegistryService.java;153508;153512;https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/registry/registry-server/registry-api-stubs/src/main/java/org/apache/airavata/registry/api/RegistryService.java/#L153508-L153512;1;"    private static class updateWorkflow_argsStandardSchemeFactory implements SchemeFactory {
      public updateWorkflow_argsStandardScheme getScheme() {
        return new updateWorkflow_argsStandardScheme();
      }
    }"
5603;6;7482608;data class;major;2019-04-16 18:28:29.624659;class;example.model.Customer223;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/model/Customer223.java;8;27;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer223.java/#L8-L27;0;"@Entity
public class Customer223 {

	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id;
	private String firstName;
	private String lastName;

	protected Customer223() {}

	public Customer223(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	@Override
	public String toString() {
		return String.format(""Customer223[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}

}"
14726;20;8920121;long method;major;2019-09-12 08:22:46.207068;function;org.apache.hadoop.hive.ql.exec.TopNHash#tryStoreVectorizedKey HiveKey|boolean|int;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/ql/src/java/org/apache/hadoop/hive/ql/exec/TopNHash.java;213;262;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/exec/TopNHash.java/#L213-L262;1;"  public void tryStoreVectorizedKey(HiveKey key, boolean partColsIsNull, int batchIndex)
      throws HiveException, IOException {
    // Assumption - batchIndex is increasing; startVectorizedBatch was called
    int size = indexes.size();
    int index = size < topN ? size : evicted;
    keys[index] = Arrays.copyOf(key.getBytes(), key.getLength());
    distKeyLengths[index] = key.getDistKeyLength();
    hashes[index] = key.hashCode();
    Integer collisionIndex = indexes.store(index);
    if (null != collisionIndex) {
      /*
       * since there is a collision index will be used for the next value 
       * so have the map point back to original index.
       */
      if ( indexes instanceof HashForGroup ) {
        indexes.store(collisionIndex);
      }
      // forward conditional on the survival of the corresponding key currently in indexes.
      ++batchNumForwards;
      batchIndexToResult[batchIndex] = MAY_FORWARD - collisionIndex;
      return;
    }
    indexToBatchIndex[index] = batchIndex;
    batchIndexToResult[batchIndex] = index;
    if (size != topN) return;
    evicted = indexes.removeBiggest();  // remove the biggest key
    if (index == evicted) {
      excluded++;
      batchIndexToResult[batchIndex] = EXCLUDE;
      indexToBatchIndex[index] = -1;
      return; // input key is bigger than any of keys in hash
    }
    removed(evicted);
    int evictedBatchIndex = indexToBatchIndex[evicted];
    if (evictedBatchIndex >= 0) {
      // reset the result for the evicted index
      batchIndexToResult[evictedBatchIndex] = EXCLUDE;
      indexToBatchIndex[evicted] = -1;
    }
    // Evict all results grouped with this index; it cannot be any key further in the batch.
    // If we evict a key from this batch, the keys grouped with it cannot be earlier that that key.
    // If we evict a key that is not from this batch, initial i = (-1) + 1 = 0, as intended.
    int evictedForward = (MAY_FORWARD - evicted);
    for (int i = evictedBatchIndex + 1; i < batchIndex && (batchNumForwards > 0); ++i) {
      if (batchIndexToResult[i] == evictedForward) {
        batchIndexToResult[i] = EXCLUDE;
        --batchNumForwards;
      }
    }
  }"
5129;5;6514981;feature envy;major;2019-04-12 15:01:17.409025;function;org.eclipse.tycho.p2.target.filters.TargetPlatformFilterEvaluator.DebugFilterLogger#unitKept IInstallableUnit;git@github.com:eclipse/tycho.git;913062f90a6bad5c8c2b57c77111a52e698105d5;/tycho-bundles/org.eclipse.tycho.p2.resolver.impl/src/main/java/org/eclipse/tycho/p2/target/filters/TargetPlatformFilterEvaluator.java;287;291;https://github.com/eclipse/tycho/blob/913062f90a6bad5c8c2b57c77111a52e698105d5/tycho-bundles/org.eclipse.tycho.p2.resolver.impl/src/main/java/org/eclipse/tycho/p2/target/filters/TargetPlatformFilterEvaluator.java/#L287-L291;1;"        @Override
        public void unitKept(IInstallableUnit unit) {
            super.unitKept(unit);
            logger.debug(""  Keeping unit "" + unit.getId() + ""/"" + unit.getVersion());
        }"
1509;12;7588699;feature envy;critical;2019-03-29 13:55:18.654152;function;org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition#getFactoryMethodMetadata;git@github.com:spring-projects/spring-framework.git;3a0f309e2c9fdbbf7fb2d348be861528177f8555;/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java;426;430;https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java/#L426-L430;1;"		@Override
		@NonNull
		public MethodMetadata getFactoryMethodMetadata() {
			return this.factoryMethodMetadata;
		}"
4180;23;7785135;data class;none;2019-04-07 09:27:30.652157;class;org.apache.wicket.examples.forminput.BeforeAndAfterBorder;git@github.com:apache/wicket.git;c2d344219ef8046508ca40653c9de485b3cbd4c4;/wicket-examples/src/main/java/org/apache/wicket/examples/forminput/BeforeAndAfterBorder.java;31;33;https://github.com/apache/wicket/blob/c2d344219ef8046508ca40653c9de485b3cbd4c4/wicket-examples/src/main/java/org/apache/wicket/examples/forminput/BeforeAndAfterBorder.java/#L31-L33;1;"public class BeforeAndAfterBorder extends BorderBehavior
{
}"
14843;21;6019048;data class;major;2019-09-12 09:06:02.187195;class;org.cloudfoundry.identity.uaa.account.ChangeEmailController.ValidEmail;git@github.com:cloudfoundry/uaa.git;f3b66dd2a250c1309a86cade560ac9a9cfeafec7;/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java;147;158;https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158;1;"    public static class ValidEmail {
        @Email
        String newEmail;

        public String getNewEmail() {
            return newEmail;
        }

        public void setNewEmail(String email) {
            this.newEmail = email;
        }
    }"
8524;12;4172212;feature envy;major;2019-07-19 12:29:29.748384;function;org.apache.cayenne.ashwood.WeightedAshwoodEntitySorter.WeightedAshwoodEntitySorter;git@github.com:apache/cayenne.git;5be5235ed1c02589b6300e9729cf3c308c0173e8;/cayenne-server/src/main/java/org/apache/cayenne/ashwood/WeightedAshwoodEntitySorter.java;42;46;https://github.com/apache/cayenne/blob/5be5235ed1c02589b6300e9729cf3c308c0173e8/cayenne-server/src/main/java/org/apache/cayenne/ashwood/WeightedAshwoodEntitySorter.java/#L42-L46;1;"    public WeightedAshwoodEntitySorter() {
        this.weightedDbEntityComparator = new WeightedDbEntityComparator();
        this.weightedObjEntityComparator = new WeightedObjEntityComparator();
        this.entityWeights = Collections.emptyMap();
    }"
15086;20;5339993;data class;major;2019-09-12 10:45:45.389109;class;org.apache.nifi.registry.flow.mapping.InstantiatedVersionedLabel;git@github.com:apache/nifi.git;c8eff590efa3babcda0b755009224dcac168708b;/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java;22;40;https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java/#L22-L40;1;"public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {
    private final String instanceId;
    private final String groupId;

    public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {
        this.instanceId = instanceId;
        this.groupId = instanceGroupId;
    }

    @Override
    public String getInstanceId() {
        return instanceId;
    }

    @Override
    public String getInstanceGroupId() {
        return groupId;
    }
}"
12796;13;6036658;feature envy;major;2019-08-09 15:50:49.883863;function;org.eclipse.concierge.Resources.ConciergeBundleWiring#cleanup;git@github.com:eclipse/concierge.git;4c73cacebc5ecbdef24d4256ab506359294f7a55;/framework/org.eclipse.concierge/src/org/eclipse/concierge/Resources.java;626;640;https://github.com/eclipse/concierge/blob/4c73cacebc5ecbdef24d4256ab506359294f7a55/framework/org.eclipse.concierge/src/org/eclipse/concierge/Resources.java/#L626-L640;1;"		void cleanup() {
			for (final BundleWire requiredWire : requiredWires.getAllValues()) {
				final ConciergeBundleWiring bw = ((ConciergeBundleWire) requiredWire).providerWiring;
				if (bw != null) {
					bw.inUseSet.remove(revision);
				}
			}
			for (final BundleWire hostWire : providedWires
					.lookup(HostNamespace.HOST_NAMESPACE)) {
				final ConciergeBundleWiring bw = ((ConciergeBundleWire) hostWire).requirerWiring;
				if (bw != null) {
					bw.inUseSet.remove(revision);
				}
			}
		}"
10874;1;7391055;data class;major;2019-07-29 12:07:50.519096;class;org.springframework.data.release.model.Release;git@github.com:spring-projects/spring-data-dev-tools.git;a25ff3ae28026f132871f7172c6ba5c3b64e1671;/release-tools/src/main/java/org/springframework/data/release/model/Release.java;25;33;https://github.com/spring-projects/spring-data-dev-tools/blob/a25ff3ae28026f132871f7172c6ba5c3b64e1671/release-tools/src/main/java/org/springframework/data/release/model/Release.java/#L25-L33;0;"@Value
public class Release {

	private final String id;
	private final ProjectKey projectKey;
	private final String name;
	private final String description;
	private final LocalDate date;
}"
3173;1;4784081;feature envy;major;2019-04-05 12:41:28.957278;function;org.apache.sentry.hdfs.service.thrift.SentryHDFSService.handle_hms_notification_result.handle_hms_notification_resultStandardScheme#write org.apache.thrift.protocol.TProtocol|handle_hms_notification_result;git@github.com:apache/incubator-sentry.git;4643f988a5e0ce2b9749e6365edea3a16482de86;/sentry-hdfs/sentry-hdfs-common/src/gen/thrift/gen-javabean/org/apache/sentry/hdfs/service/thrift/SentryHDFSService.java;1004;1010;https://github.com/apache/incubator-sentry/blob/4643f988a5e0ce2b9749e6365edea3a16482de86/sentry-hdfs/sentry-hdfs-common/src/gen/thrift/gen-javabean/org/apache/sentry/hdfs/service/thrift/SentryHDFSService.java/#L1004-L1010;0;"      public void write(org.apache.thrift.protocol.TProtocol oprot, handle_hms_notification_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }"
11250;3;4241628;blob;major;2019-08-04 19:58:55.888937;class;org.apache.commons.imaging.formats.jpeg.xmp.JpegRewriter;git@github.com:apache/commons-imaging.git;fa7c16f434061d441d1c0d9dbcfd0f4c3092c880;/src/main/java/org/apache/commons/imaging/formats/jpeg/xmp/JpegRewriter.java;40;353;https://github.com/apache/commons-imaging/blob/fa7c16f434061d441d1c0d9dbcfd0f4c3092c880/src/main/java/org/apache/commons/imaging/formats/jpeg/xmp/JpegRewriter.java/#L40-L353;1;"public class JpegRewriter extends BinaryFileParser {
    private static final ByteOrder JPEG_BYTE_ORDER = ByteOrder.BIG_ENDIAN;
    private static final SegmentFilter EXIF_SEGMENT_FILTER = new SegmentFilter() {
        @Override
        public boolean filter(final JFIFPieceSegment segment) {
            return segment.isExifSegment();
        }
    };
    private static final SegmentFilter XMP_SEGMENT_FILTER = new SegmentFilter() {
        @Override
        public boolean filter(final JFIFPieceSegment segment) {
            return segment.isXmpSegment();
        }
    };
    private static final SegmentFilter PHOTOSHOP_APP13_SEGMENT_FILTER = new SegmentFilter() {
        @Override
        public boolean filter(final JFIFPieceSegment segment) {
            return segment.isPhotoshopApp13Segment();
        }
    };

    /**
     * Constructor. to guess whether a file contains an image based on its file
     * extension.
     */
    public JpegRewriter() {
        setByteOrder(JPEG_BYTE_ORDER);
    }

    protected static class JFIFPieces {
        public final List<JFIFPiece> pieces;
        public final List<JFIFPiece> segmentPieces;

        public JFIFPieces(final List<JFIFPiece> pieces,
                final List<JFIFPiece> segmentPieces) {
            this.pieces = pieces;
            this.segmentPieces = segmentPieces;
        }

    }

    protected abstract static class JFIFPiece {
        protected abstract void write(OutputStream os) throws IOException;

        @Override
        public String toString() {
            return ""["" + this.getClass().getName() + ""]"";
        }
    }

    protected static class JFIFPieceSegment extends JFIFPiece {
        public final int marker;
        private final byte[] markerBytes;
        private final byte[] segmentLengthBytes;
        private final byte[] segmentData;

        public JFIFPieceSegment(final int marker, final byte[] segmentData) {
            this(marker,
                    ByteConversions.toBytes((short) marker, JPEG_BYTE_ORDER),
                    ByteConversions.toBytes((short) (segmentData.length + 2), JPEG_BYTE_ORDER),
                    segmentData);
        }

        JFIFPieceSegment(final int marker, final byte[] markerBytes,
                final byte[] segmentLengthBytes, final byte[] segmentData) {
            this.marker = marker;
            this.markerBytes = markerBytes;
            this.segmentLengthBytes = segmentLengthBytes;
            this.segmentData = segmentData; // TODO clone?
        }

        @Override
        public String toString() {
            return ""["" + this.getClass().getName() + "" (0x""
                    + Integer.toHexString(marker) + "")]"";
        }

        @Override
        protected void write(final OutputStream os) throws IOException {
            os.write(markerBytes);
            os.write(segmentLengthBytes);
            os.write(segmentData);
        }

        public boolean isApp1Segment() {
            return marker == JpegConstants.JPEG_APP1_MARKER;
        }

        public boolean isAppSegment() {
            return marker >= JpegConstants.JPEG_APP0_MARKER && marker <= JpegConstants.JPEG_APP15_MARKER;
        }

        public boolean isExifSegment() {
            if (marker != JpegConstants.JPEG_APP1_MARKER) {
                return false;
            }
            if (!startsWith(segmentData, JpegConstants.EXIF_IDENTIFIER_CODE)) {
                return false;
            }
            return true;
        }

        public boolean isPhotoshopApp13Segment() {
            if (marker != JpegConstants.JPEG_APP13_MARKER) {
                return false;
            }
            if (!new IptcParser().isPhotoshopJpegSegment(segmentData)) {
                return false;
            }
            return true;
        }

        public boolean isXmpSegment() {
            if (marker != JpegConstants.JPEG_APP1_MARKER) {
                return false;
            }
            if (!startsWith(segmentData, JpegConstants.XMP_IDENTIFIER)) {
                return false;
            }
            return true;
        }

        public byte[] getSegmentData() {
            return segmentData; // TODO clone?
        }

    }

    static class JFIFPieceImageData extends JFIFPiece {
        private final byte[] markerBytes;
        private final byte[] imageData;

        JFIFPieceImageData(final byte[] markerBytes, final byte[] imageData) {
            super();
            this.markerBytes = markerBytes;
            this.imageData = imageData;
        }

        @Override
        protected void write(final OutputStream os) throws IOException {
            os.write(markerBytes);
            os.write(imageData);
        }
    }

    protected JFIFPieces analyzeJFIF(final ByteSource byteSource) throws ImageReadException, IOException {
        final List<JFIFPiece> pieces = new ArrayList<>();
        final List<JFIFPiece> segmentPieces = new ArrayList<>();

        final JpegUtils.Visitor visitor = new JpegUtils.Visitor() {
            // return false to exit before reading image data.
            @Override
            public boolean beginSOS() {
                return true;
            }

            @Override
            public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {
                pieces.add(new JFIFPieceImageData(markerBytes, imageData));
            }

            // return false to exit traversal.
            @Override
            public boolean visitSegment(final int marker, final byte[] markerBytes,
                    final int segmentLength, final byte[] segmentLengthBytes,
                    final byte[] segmentData) throws ImageReadException, IOException {
                final JFIFPiece piece = new JFIFPieceSegment(marker, markerBytes,
                        segmentLengthBytes, segmentData);
                pieces.add(piece);
                segmentPieces.add(piece);

                return true;
            }
        };

        new JpegUtils().traverseJFIF(byteSource, visitor);

        return new JFIFPieces(pieces, segmentPieces);
    }

    private interface SegmentFilter {
        boolean filter(JFIFPieceSegment segment);
    }

    protected <T extends JFIFPiece> List<T> removeXmpSegments(final List<T> segments) {
        return filterSegments(segments, XMP_SEGMENT_FILTER);
    }

    protected <T extends JFIFPiece> List<T> removePhotoshopApp13Segments(
            final List<T> segments) {
        return filterSegments(segments, PHOTOSHOP_APP13_SEGMENT_FILTER);
    }

    protected <T extends JFIFPiece> List<T> findPhotoshopApp13Segments(
            final List<T> segments) {
        return filterSegments(segments, PHOTOSHOP_APP13_SEGMENT_FILTER, true);
    }

    protected <T extends JFIFPiece> List<T> removeExifSegments(final List<T> segments) {
        return filterSegments(segments, EXIF_SEGMENT_FILTER);
    }

    protected <T extends JFIFPiece> List<T> filterSegments(final List<T> segments,
            final SegmentFilter filter) {
        return filterSegments(segments, filter, false);
    }

    protected <T extends JFIFPiece> List<T> filterSegments(final List<T> segments,
            final SegmentFilter filter, final boolean reverse) {
        final List<T> result = new ArrayList<>();

        for (final T piece : segments) {
            if (piece instanceof JFIFPieceSegment) {
                if (filter.filter((JFIFPieceSegment) piece) ^ !reverse) {
                    result.add(piece);
                }
            } else if (!reverse) {
                result.add(piece);
            }
        }

        return result;
    }

    protected <T extends JFIFPiece, U extends JFIFPiece> List<JFIFPiece> insertBeforeFirstAppSegments(
            final List<T> segments, final List<U> newSegments) throws ImageWriteException {
        int firstAppIndex = -1;
        for (int i = 0; i < segments.size(); i++) {
            final JFIFPiece piece = segments.get(i);
            if (!(piece instanceof JFIFPieceSegment)) {
                continue;
            }

            final JFIFPieceSegment segment = (JFIFPieceSegment) piece;
            if (segment.isAppSegment()) {
                if (firstAppIndex == -1) {
                    firstAppIndex = i;
                }
            }
        }

        final List<JFIFPiece> result = new ArrayList<JFIFPiece>(segments);
        if (firstAppIndex == -1) {
            throw new ImageWriteException(""JPEG file has no APP segments."");
        }
        result.addAll(firstAppIndex, newSegments);
        return result;
    }

    protected <T extends JFIFPiece, U extends JFIFPiece> List<JFIFPiece> insertAfterLastAppSegments(
            final List<T> segments, final List<U> newSegments) throws ImageWriteException {
        int lastAppIndex = -1;
        for (int i = 0; i < segments.size(); i++) {
            final JFIFPiece piece = segments.get(i);
            if (!(piece instanceof JFIFPieceSegment)) {
                continue;
            }

            final JFIFPieceSegment segment = (JFIFPieceSegment) piece;
            if (segment.isAppSegment()) {
                lastAppIndex = i;
            }
        }

        final List<JFIFPiece> result = new ArrayList<JFIFPiece>(segments);
        if (lastAppIndex == -1) {
            if (segments.size() < 1) {
                throw new ImageWriteException(""JPEG file has no APP segments."");
            }
            result.addAll(1, newSegments);
        } else {
            result.addAll(lastAppIndex + 1, newSegments);
        }

        return result;
    }

    protected void writeSegments(final OutputStream outputStream,
            final List<? extends JFIFPiece> segments) throws IOException {
        try (DataOutputStream os = new DataOutputStream(outputStream)) {
            JpegConstants.SOI.writeTo(os);

            for (final JFIFPiece piece : segments) {
                piece.write(os);
            }
        }
    }

    // private void writeSegment(OutputStream os, JFIFPieceSegment piece)
    // throws ImageWriteException, IOException
    // {
    // byte markerBytes[] = convertShortToByteArray(JPEG_APP1_MARKER,
    // JPEG_BYTE_ORDER);
    // if (piece.segmentData.length > 0xffff)
    // throw new JpegSegmentOverflowException(""Jpeg segment is too long: ""
    // + piece.segmentData.length);
    // int segmentLength = piece.segmentData.length + 2;
    // byte segmentLengthBytes[] = convertShortToByteArray(segmentLength,
    // JPEG_BYTE_ORDER);
    //
    // os.write(markerBytes);
    // os.write(segmentLengthBytes);
    // os.write(piece.segmentData);
    // }

    public static class JpegSegmentOverflowException extends ImageWriteException {
        private static final long serialVersionUID = -1062145751550646846L;

        public JpegSegmentOverflowException(final String message) {
            super(message);
        }
    }

}"
1128;5;7155736;long method;none;2019-03-29 13:32:10.023872;function;com.microsoft.sqlserver.jdbc.TDSChannel.ProxyInputStream#read byte[];git@github.com:Microsoft/mssql-jdbc.git;84484edf7944de56749fd2648d0af2ffa2459b7a;/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java;988;990;https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java/#L988-L990;0;"        public int read(byte[] b) throws IOException {
            return readInternal(b, 0, b.length);
        }"
10724;13;7239385;data class;critical;2019-07-26 13:39:49.307616;class;org.robolectric.res.android.LoadedArsc.DynamicPackageEntry;git@github.com:robolectric/robolectric.git;525bfcfc0e0ed1653ad57341b564c6857e11dc50;/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java;62;75;https://github.com/robolectric/robolectric/blob/525bfcfc0e0ed1653ad57341b564c6857e11dc50/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java/#L62-L75;1;"  static class DynamicPackageEntry {

    // public:
    //
    // DynamicPackageEntry() =default;

    DynamicPackageEntry(String package_name, int package_id) {
      this.package_name = package_name;
      this.package_id = package_id;
    }

    String package_name;
    int package_id = 0;
  }"
14551;4;6904479;long method;major;2019-09-11 15:05:41.058064;function;com.sun.tools.javadoc.main.DocletInvoker#invoke String|Object|Class<?>[]|Object[];git@github.com:google/error-prone-javac.git;a53d069bbdb2c60232ed3811c19b65e41c3e60e0;/src/jdk.javadoc/share/classes/com/sun/tools/javadoc/main/DocletInvoker.java;303;357;https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.javadoc/share/classes/com/sun/tools/javadoc/main/DocletInvoker.java/#L303-L357;0;"    private Object invoke(String methodName, Object returnValueIfNonExistent,
                          Class<?>[] paramTypes, Object[] params)
        throws DocletInvokeException {
            Method meth;
            try {
                meth = docletClass.getMethod(methodName, paramTypes);
            } catch (NoSuchMethodException exc) {
                if (returnValueIfNonExistent == null) {
                    messager.error(Messager.NOPOS, ""main.doclet_method_not_found"",
                                   docletClassName, methodName);
                    throw new DocletInvokeException();
                } else {
                    return returnValueIfNonExistent;
                }
            } catch (SecurityException exc) {
                messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            if (!Modifier.isStatic(meth.getModifiers())) {
                messager.error(Messager.NOPOS, ""main.doclet_method_must_be_static"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            ClassLoader savedCCL =
                Thread.currentThread().getContextClassLoader();
            try {
                if (appClassLoader != null) // will be null if doclet class provided via API
                    Thread.currentThread().setContextClassLoader(appClassLoader);
                return meth.invoke(null , params);
            } catch (IllegalArgumentException | NullPointerException exc) {
                messager.error(Messager.NOPOS, ""main.internal_error_exception_thrown"",
                               docletClassName, methodName, exc.toString());
                throw new DocletInvokeException();
            } catch (IllegalAccessException exc) {
                messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            catch (InvocationTargetException exc) {
                Throwable err = exc.getTargetException();
                if (apiMode)
                    throw new ClientCodeException(err);
                if (err instanceof java.lang.OutOfMemoryError) {
                    messager.error(Messager.NOPOS, ""main.out.of.memory"");
                } else {
                    messager.error(Messager.NOPOS, ""main.exception_thrown"",
                               docletClassName, methodName, exc.toString());
                    exc.getTargetException().printStackTrace(System.err);
                }
                throw new DocletInvokeException();
            } finally {
                Thread.currentThread().setContextClassLoader(savedCCL);
            }
    }"
8215;3;5519299;blob;major;2019-07-18 14:15:45.187275;class;org.apache.rocketmq.broker.slave.SlaveSynchronize;git@github.com:apache/rocketmq.git;971fa8ed8b209b39bdfe41c57cd64576d244e6bd;/broker/src/main/java/org/apache/rocketmq/broker/slave/SlaveSynchronize.java;31;144;https://github.com/apache/rocketmq/blob/971fa8ed8b209b39bdfe41c57cd64576d244e6bd/broker/src/main/java/org/apache/rocketmq/broker/slave/SlaveSynchronize.java/#L31-L144;1;"public class SlaveSynchronize {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
    private final BrokerController brokerController;
    private volatile String masterAddr = null;

    public SlaveSynchronize(BrokerController brokerController) {
        this.brokerController = brokerController;
    }

    public String getMasterAddr() {
        return masterAddr;
    }

    public void setMasterAddr(String masterAddr) {
        this.masterAddr = masterAddr;
    }

    public void syncAll() {
        this.syncTopicConfig();
        this.syncConsumerOffset();
        this.syncDelayOffset();
        this.syncSubscriptionGroupConfig();
    }

    private void syncTopicConfig() {
        String masterAddrBak = this.masterAddr;
        if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
            try {
                TopicConfigSerializeWrapper topicWrapper =
                    this.brokerController.getBrokerOuterAPI().getAllTopicConfig(masterAddrBak);
                if (!this.brokerController.getTopicConfigManager().getDataVersion()
                    .equals(topicWrapper.getDataVersion())) {

                    this.brokerController.getTopicConfigManager().getDataVersion()
                        .assignNewOne(topicWrapper.getDataVersion());
                    this.brokerController.getTopicConfigManager().getTopicConfigTable().clear();
                    this.brokerController.getTopicConfigManager().getTopicConfigTable()
                        .putAll(topicWrapper.getTopicConfigTable());
                    this.brokerController.getTopicConfigManager().persist();

                    log.info(""Update slave topic config from master, {}"", masterAddrBak);
                }
            } catch (Exception e) {
                log.error(""SyncTopicConfig Exception, {}"", masterAddrBak, e);
            }
        }
    }

    private void syncConsumerOffset() {
        String masterAddrBak = this.masterAddr;
        if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
            try {
                ConsumerOffsetSerializeWrapper offsetWrapper =
                    this.brokerController.getBrokerOuterAPI().getAllConsumerOffset(masterAddrBak);
                this.brokerController.getConsumerOffsetManager().getOffsetTable()
                    .putAll(offsetWrapper.getOffsetTable());
                this.brokerController.getConsumerOffsetManager().persist();
                log.info(""Update slave consumer offset from master, {}"", masterAddrBak);
            } catch (Exception e) {
                log.error(""SyncConsumerOffset Exception, {}"", masterAddrBak, e);
            }
        }
    }

    private void syncDelayOffset() {
        String masterAddrBak = this.masterAddr;
        if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
            try {
                String delayOffset =
                    this.brokerController.getBrokerOuterAPI().getAllDelayOffset(masterAddrBak);
                if (delayOffset != null) {

                    String fileName =
                        StorePathConfigHelper.getDelayOffsetStorePath(this.brokerController
                            .getMessageStoreConfig().getStorePathRootDir());
                    try {
                        MixAll.string2File(delayOffset, fileName);
                    } catch (IOException e) {
                        log.error(""Persist file Exception, {}"", fileName, e);
                    }
                }
                log.info(""Update slave delay offset from master, {}"", masterAddrBak);
            } catch (Exception e) {
                log.error(""SyncDelayOffset Exception, {}"", masterAddrBak, e);
            }
        }
    }

    private void syncSubscriptionGroupConfig() {
        String masterAddrBak = this.masterAddr;
        if (masterAddrBak != null  && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
            try {
                SubscriptionGroupWrapper subscriptionWrapper =
                    this.brokerController.getBrokerOuterAPI()
                        .getAllSubscriptionGroupConfig(masterAddrBak);

                if (!this.brokerController.getSubscriptionGroupManager().getDataVersion()
                    .equals(subscriptionWrapper.getDataVersion())) {
                    SubscriptionGroupManager subscriptionGroupManager =
                        this.brokerController.getSubscriptionGroupManager();
                    subscriptionGroupManager.getDataVersion().assignNewOne(
                        subscriptionWrapper.getDataVersion());
                    subscriptionGroupManager.getSubscriptionGroupTable().clear();
                    subscriptionGroupManager.getSubscriptionGroupTable().putAll(
                        subscriptionWrapper.getSubscriptionGroupTable());
                    subscriptionGroupManager.persist();
                    log.info(""Update slave Subscription Group from master, {}"", masterAddrBak);
                }
            } catch (Exception e) {
                log.error(""SyncSubscriptionGroup Exception, {}"", masterAddrBak, e);
            }
        }
    }
}"
3600;1;8532133;long method;major;2019-04-05 13:12:36.008575;function;org.apache.cloudstack.network.contrail.management.ServerDBSyncImpl#syncAll short;git@github.com:apache/cloudstack.git;8d3feb100aab4a45b31a789f444038b892161eec;/plugins/network-elements/juniper-contrail/src/main/java/org/apache/cloudstack/network/contrail/management/ServerDBSyncImpl.java;129;174;https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/plugins/network-elements/juniper-contrail/src/main/java/org/apache/cloudstack/network/contrail/management/ServerDBSyncImpl.java/#L129-L174;1;"    @Override
    public short syncAll(short syncMode) {
        short syncState = SYNC_STATE_IN_SYNC;

        /* vnc classes need to be synchronized with cloudstack */
        s_logger.debug(""syncing cloudstack db with vnc"");
        try {
            for (Class<?> cls : _vncClasses) {

                /* lock the sync mode*/
                _lockSyncMode.lock();
                _rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;
                _dbSync.setSyncMode(syncMode);

                if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
                    s_logger.debug(""sync check start: "" + DBSyncGeneric.getClassName(cls));
                } else {
                    s_logger.debug(""sync start: "" + DBSyncGeneric.getClassName(cls));
                }

                if (_dbSync.sync(cls) == false) {
                    if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
                        s_logger.info(""out of sync detected: "" + DBSyncGeneric.getClassName(cls));
                    } else {
                        s_logger.info(""out of sync detected and re-synced: "" + DBSyncGeneric.getClassName(cls));
                    }
                    syncState = SYNC_STATE_OUT_OF_SYNC;
                }
                if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
                    s_logger.debug(""sync check finish: "" + DBSyncGeneric.getClassName(cls));
                } else {
                    s_logger.debug(""sync finish: "" + DBSyncGeneric.getClassName(cls));
                }
                /* unlock the sync mode */
                _lockSyncMode.unlock();
            }
        } catch (Exception ex) {
            s_logger.warn(""DB Synchronization"", ex);
            syncState = SYNC_STATE_UNKNOWN;
            if (_lockSyncMode.isLocked()) {
                _lockSyncMode.unlock();
            }
        }

        return syncState;
    }"
1423;4;7485370;feature envy;none;2019-03-29 13:50:09.381403;function;example.service.Customer1085Service.Customer1085Service Customer1085Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer1085Service.java;9;10;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer1085Service.java/#L9-L10;0;"	public Customer1085Service(Customer1085Repository repo) {
	}"
12805;13;6243619;feature envy;major;2019-08-09 16:02:13.394956;function;org.eclipse.elk.alg.radial.options.#create;git@github.com:eclipse/elk.git;9a87764f00d863463b1be6de1920d8aa3c3ade70;/plugins/org.eclipse.elk.alg.radial/src/org/eclipse/elk/alg/radial/options/AnnulusWedgeCriteria.java;37;47;https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.alg.radial/src/org/eclipse/elk/alg/radial/options/AnnulusWedgeCriteria.java/#L37-L47;1;"    public IAnnulusWedgeCriteria create() {
        switch (this) {
        case LEAF_NUMBER:
            return new AnnulusWedgeByLeafs();
        case NODE_SIZE:
            return new AnnulusWedgeByNodeSpace();
        default:
            throw new IllegalArgumentException(
                    ""No implementation is available for the layout option "" + this.toString());
        }
    }"
9019;20;5223561;data class;major;2019-07-23 14:42:59.347553;class;org.apache.ode.bpel.engine.migration.MigrationHandler.MigrationLink;git@github.com:apache/ode.git;b2ddc6436891f84f716ffcbed8c1cd1e374bd805;/bpel-runtime/src/main/java/org/apache/ode/bpel/engine/migration/MigrationHandler.java;113;122;https://github.com/apache/ode/blob/b2ddc6436891f84f716ffcbed8c1cd1e374bd805/bpel-runtime/src/main/java/org/apache/ode/bpel/engine/migration/MigrationHandler.java/#L113-L122;1;"    private static class MigrationLink {
        int source;
        int target;
        Migration[] migrations;
        public MigrationLink(int source, int target, Migration[] migrations) {
            this.source = source;
            this.target = target;
            this.migrations = migrations;
        }
    }"
9783;10;5000200;blob;major;2019-07-24 12:42:04.253836;class;org.jclouds.glesys.options.AddDomainOptions.Builder;git@github.com:apache/jclouds.git;c2670079fabe74f163f43fbade0866469f7a84ec;/providers/glesys/src/main/java/org/jclouds/glesys/options/AddDomainOptions.java;21;77;https://github.com/apache/jclouds/blob/c2670079fabe74f163f43fbade0866469f7a84ec/providers/glesys/src/main/java/org/jclouds/glesys/options/AddDomainOptions.java/#L21-L77;1;"   public static class Builder {
      /**
       * @see AddDomainOptions#primaryNameServer
       */
      public static AddDomainOptions primaryNameServer(String primaryNameServer) {
         return AddDomainOptions.class.cast(new AddDomainOptions().primaryNameServer(primaryNameServer));
      }

      /**
       * @see AddDomainOptions#responsiblePerson
       */
      public static AddDomainOptions responsiblePerson(String responsiblePerson) {
         return AddDomainOptions.class.cast(new AddDomainOptions().responsiblePerson(responsiblePerson));
      }

      /**
       * @see AddDomainOptions#ttl
       */
      public static AddDomainOptions ttl(int ttl) {
         return AddDomainOptions.class.cast(new AddDomainOptions().ttl(ttl));
      }

      /**
       * @see AddDomainOptions#refresh
       */
      public static AddDomainOptions refresh(int refresh) {
         return AddDomainOptions.class.cast(new AddDomainOptions().refresh(refresh));
      }

      /**
       * @see AddDomainOptions#retry
       */
      public static AddDomainOptions retry(int retry) {
         return AddDomainOptions.class.cast(new AddDomainOptions().retry(retry));
      }

      /**
       * @see AddDomainOptions#expire
       */
      public static AddDomainOptions expire(int expire) {
         return AddDomainOptions.class.cast(new AddDomainOptions().expire(expire));
      }

      /**
       * @see AddDomainOptions#minimum
       */
      public static AddDomainOptions minimum(int minimum) {
         return AddDomainOptions.class.cast(new AddDomainOptions().minimum(minimum));
      }

      /**
       * @see AddDomainOptions#minimalRecords
       */
      public static AddDomainOptions minimalRecords() {
         return AddDomainOptions.class.cast(new AddDomainOptions().minimalRecords());
      }
   }"
1074;10;7074847;data class;major;2019-03-29 13:29:43.413789;class;com.linkedin.gradle.python.util.OperatingSystem.Solaris;git@github.com:linkedin/pygradle.git;4b04b7980dc47a76b816184ebbcfe0b3f5cefadd;/pygradle-plugin/src/main/groovy/com/linkedin/gradle/python/util/OperatingSystem.java;363;382;https://github.com/linkedin/pygradle/blob/4b04b7980dc47a76b816184ebbcfe0b3f5cefadd/pygradle-plugin/src/main/groovy/com/linkedin/gradle/python/util/OperatingSystem.java/#L363-L382;1;"    static class Solaris extends OperatingSystem.Unix {
        @Override
        public String getFamilyName() {
            return ""solaris"";
        }

        @Override
        protected String getOsPrefix() {
            return ""sunos"";
        }

        @Override
        protected String getArch() {
            String arch = System.getProperty(""os.arch"");
            if (arch.equals(""i386"") || arch.equals(""x86"")) {
                return ""x86"";
            }
            return super.getArch();
        }
    }"
10721;13;5793029;blob;major;2019-07-26 13:39:13.857192;class;org.apache.tika.language.LanguageProfile.Interleaved;git@github.com:apache/tika.git;4131c6e30f2e0eb1feb85e0f7576531d4e830468;/tika-core/src/main/java/org/apache/tika/language/LanguageProfile.java;224;311;https://github.com/apache/tika/blob/4131c6e30f2e0eb1feb85e0f7576531d4e830468/tika-core/src/main/java/org/apache/tika/language/LanguageProfile.java/#L224-L311;1;"    private class Interleaved {

        private char[] entries = null; // <ngram(length chars)><count(2 chars)>*
        private int size = 0; // Number of entries (one entry = length+2 chars)
        private long entriesGeneratedAtCount = -1; // Keeps track of when the sequential structure was current

        /**
         * Ensure that the entries array is in sync with the ngrams.
         */
        public void update() {
            if (count == entriesGeneratedAtCount) { // Already up to date
                return;
            }
            size = ngrams.size();
            final int numChars = (length+2)*size;
            if (entries == null || entries.length < numChars) {
                entries = new char[numChars];
            }
            int pos = 0;
            for (Map.Entry<String, Counter> entry: getSortedNgrams()) {
                for (int l = 0 ; l < length ; l++) {
                    entries[pos + l] = entry.getKey().charAt(l);
                }
                entries[pos + length] = (char)(entry.getValue().count / 65536); // Upper 16 bit
                entries[pos + length + 1] = (char)(entry.getValue().count % 65536); // lower 16 bit
                pos += length + 2;
            }
            entriesGeneratedAtCount = count;
        }

        public Entry firstEntry() {
            Entry entry = new Entry();
            if (size > 0) {
                entry.update(0);
            }
            return entry;
        }
        
        private List<Map.Entry<String, Counter>> getSortedNgrams() {
            List<Map.Entry<String, Counter>> entries = new ArrayList<Map.Entry<String, Counter>>(ngrams.size());
            entries.addAll(ngrams.entrySet());
            Collections.sort(entries, new Comparator<Map.Entry<String, Counter>>() {
                @Override
                public int compare(Map.Entry<String, Counter> o1, Map.Entry<String, Counter> o2) {
                    return o1.getKey().compareTo(o2.getKey());
                }
            });
            return entries;
        }
        
        private class Entry implements Comparable<Entry> {
            char[] ngram = new char[length];
            int count = 0;
            int pos = 0;

            private void update(int pos) {
                this.pos = pos;
                if (pos >= size) { // Reached the end
                    return;
                }
                final int origo = pos*(length+2);
                System.arraycopy(entries, origo, ngram, 0, length);
                count = entries[origo+length] * 65536 + entries[origo+length+1];
            }

            @Override
            public int compareTo(Entry other) {
                for (int i = 0 ; i < ngram.length ; i++) {
                    if (ngram[i] != other.ngram[i]) {
                        return ngram[i] - other.ngram[i];
                    }
                }
                return 0;
            }
            public boolean hasNext() {
                return pos < size-1;
            }
            public boolean hasNgram() {
                return pos < size;
            }
            public void next() {
                update(pos+1);
            }
            public String toString() {
                return new String(ngram) + ""("" + count + "")"";
            }
        }
    }"
726;8;6247819;long method;none;2019-03-27 15:19:07.115379;function;org.eclipse.hawkbit.repository.event.remote.entity.ActionCreatedEvent.ActionCreatedEvent;git@github.com:eclipse/hawkbit.git;51be28147f6f575b6c1ab4a5ef84ffd9174f1209;/hawkbit-repository/hawkbit-repository-api/src/main/java/org/eclipse/hawkbit/repository/event/remote/entity/ActionCreatedEvent.java;23;25;https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-repository/hawkbit-repository-api/src/main/java/org/eclipse/hawkbit/repository/event/remote/entity/ActionCreatedEvent.java/#L23-L25;1;"    public ActionCreatedEvent() {
        // for serialization libs like jackson
    }"
14662;4;7725777;data class;major;2019-09-12 08:05:24.128604;class;com.vmware.admiral.request.notification.NotificationsService.NotificationsAggregatorState;git@github.com:vmware/admiral.git;e02d0e77f65d0ee3541a378110ecd4233bdb6664;/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java;52;55;https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/notification/NotificationsService.java/#L52-L55;1;"    public static class NotificationsAggregatorState {
        public long recentEventLogsCount;
        public long activeRequestsCount;
    }"
4305;7;6017760;blob;none;2019-04-10 09:59:48.528217;class;org.cloudfoundry.identity.uaa.db.postgresql.V2_5_3__Migrate_Groups_For_Zones;git@github.com:cloudfoundry/uaa.git;f3b66dd2a250c1309a86cade560ac9a9cfeafec7;/server/src/main/java/org/cloudfoundry/identity/uaa/db/postgresql/V2_5_3__Migrate_Groups_For_Zones.java;20;21;https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/db/postgresql/V2_5_3__Migrate_Groups_For_Zones.java/#L20-L21;1;"public class V2_5_3__Migrate_Groups_For_Zones extends Create_Groups_For_Zones_2_5_2 {
}"
10606;13;7257899;feature envy;major;2019-07-26 12:37:55.355531;function;org.graalvm.visualvm.lib.profiler.snaptracer.impl.timeline.TimelineXYPainter#getSelectionBounds ItemSelection|ChartContext;git@github.com:oracle/visualvm.git;d9b10575b53d535e10c6e8c41831ebe38483c65b;/visualvm/libs.profiler/profiler.snaptracer/src/org/graalvm/visualvm/lib/profiler/snaptracer/impl/timeline/TimelineXYPainter.java;145;158;https://github.com/oracle/visualvm/blob/d9b10575b53d535e10c6e8c41831ebe38483c65b/visualvm/libs.profiler/profiler.snaptracer/src/org/graalvm/visualvm/lib/profiler/snaptracer/impl/timeline/TimelineXYPainter.java/#L145-L158;1;"    public LongRect getSelectionBounds(ItemSelection selection, ChartContext context) {

        XYItemSelection sel = (XYItemSelection)selection;
        XYItem item  = sel.getItem();
        int selectedValueIndex = sel.getValueIndex();

        if (selectedValueIndex == -1 ||
            selectedValueIndex >= item.getValuesCount())
            // This happens on reset - bounds of the selection are unknown, let's clear whole area
            return new LongRect(0, 0, context.getViewportWidth(),
                                context.getViewportHeight());
        else
            return getViewBounds(item, selectedValueIndex, context);
    }"
15100;4;5339993;data class;major;2019-09-12 10:49:13.203961;class;org.apache.nifi.registry.flow.mapping.InstantiatedVersionedLabel;git@github.com:apache/nifi.git;c8eff590efa3babcda0b755009224dcac168708b;/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java;22;40;https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/InstantiatedVersionedLabel.java/#L22-L40;1;"public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {
    private final String instanceId;
    private final String groupId;

    public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {
        this.instanceId = instanceId;
        this.groupId = instanceGroupId;
    }

    @Override
    public String getInstanceId() {
        return instanceId;
    }

    @Override
    public String getInstanceGroupId() {
        return groupId;
    }
}"
3247;14;8662937;feature envy;critical;2019-04-05 12:47:06.234845;function;org.apache.ofbiz.content.content.ContentSearchSession.ContentSearchOptions.setResultSortOrder ResultSortOrder|HttpSession;git@github.com:apache/ofbiz-framework.git;b1304439219bb04c396f5d000bec9c5fbb194b59;/applications/content/src/main/java/org/apache/ofbiz/content/content/ContentSearchSession.java;90;94;https://github.com/apache/ofbiz-framework/blob/b1304439219bb04c396f5d000bec9c5fbb194b59/applications/content/src/main/java/org/apache/ofbiz/content/content/ContentSearchSession.java/#L90-L94;1;"        public static void setResultSortOrder(ResultSortOrder resultSortOrder, HttpSession session) {
            ContentSearchOptions contentSearchOptions = getContentSearchOptions(session);
            contentSearchOptions.resultSortOrder = resultSortOrder;
            contentSearchOptions.changed = true;
        }"
12297;3;8736644;blob;major;2019-08-06 11:45:29.519739;class;org.apache.hadoop.mapreduce.v2.hs.HistoryClientService;git@github.com:apache/hadoop-common.git;42a61a4fbc88303913c4681f0d40ffcc737e70b5;/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/HistoryClientService.java;99;435;https://github.com/apache/hadoop-common/blob/42a61a4fbc88303913c4681f0d40ffcc737e70b5/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/HistoryClientService.java/#L99-L435;0;"public class HistoryClientService extends AbstractService {

  private static final Log LOG = LogFactory.getLog(HistoryClientService.class);

  private HSClientProtocol protocolHandler;
  private Server server;
  private WebApp webApp;
  private InetSocketAddress bindAddress;
  private HistoryContext history;
  private JHSDelegationTokenSecretManager jhsDTSecretManager;
  
  public HistoryClientService(HistoryContext history,
      JHSDelegationTokenSecretManager jhsDTSecretManager) {
    super(""HistoryClientService"");
    this.history = history;
    this.protocolHandler = new HSClientProtocolHandler();
    this.jhsDTSecretManager = jhsDTSecretManager;
  }

  protected void serviceStart() throws Exception {
    Configuration conf = getConfig();
    YarnRPC rpc = YarnRPC.create(conf);
    initializeWebApp(conf);
    InetSocketAddress address = conf.getSocketAddr(
        JHAdminConfig.MR_HISTORY_BIND_HOST,
        JHAdminConfig.MR_HISTORY_ADDRESS,
        JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,
        JHAdminConfig.DEFAULT_MR_HISTORY_PORT);

    server =
        rpc.getServer(HSClientProtocol.class, protocolHandler, address,
            conf, jhsDTSecretManager,
            conf.getInt(JHAdminConfig.MR_HISTORY_CLIENT_THREAD_COUNT,
                JHAdminConfig.DEFAULT_MR_HISTORY_CLIENT_THREAD_COUNT));

    // Enable service authorization?
    if (conf.getBoolean(
        CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,
        false)) {
      server.refreshServiceAcl(conf, new ClientHSPolicyProvider());
    }
    
    server.start();
    this.bindAddress = conf.updateConnectAddr(JHAdminConfig.MR_HISTORY_BIND_HOST,
                                              JHAdminConfig.MR_HISTORY_ADDRESS,
                                              JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,
                                              server.getListenerAddress());
    LOG.info(""Instantiated HistoryClientService at "" + this.bindAddress);

    super.serviceStart();
  }

  @VisibleForTesting
  protected void initializeWebApp(Configuration conf) {
    webApp = new HsWebApp(history);
    InetSocketAddress bindAddress = MRWebAppUtil.getJHSWebBindAddress(conf);
    // NOTE: there should be a .at(InetSocketAddress)
    WebApps
        .$for(""jobhistory"", HistoryClientService.class, this, ""ws"")
        .with(conf)
        .withHttpSpnegoKeytabKey(
            JHAdminConfig.MR_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)
        .withHttpSpnegoPrincipalKey(
            JHAdminConfig.MR_WEBAPP_SPNEGO_USER_NAME_KEY)
        .at(NetUtils.getHostPortString(bindAddress)).start(webApp);
    
    String connectHost = MRWebAppUtil.getJHSWebappURLWithoutScheme(conf).split("":"")[0];
    MRWebAppUtil.setJHSWebappURLWithoutScheme(conf,
        connectHost + "":"" + webApp.getListenerAddress().getPort());
  }

  @Override
  protected void serviceStop() throws Exception {
    if (server != null) {
      server.stop();
    }
    if (webApp != null) {
      webApp.stop();
    }
    super.serviceStop();
  }

  @Private
  public MRClientProtocol getClientHandler() {
    return this.protocolHandler;
  }

  @Private
  public InetSocketAddress getBindAddress() {
    return this.bindAddress;
  }

  private class HSClientProtocolHandler implements HSClientProtocol {

    private RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null);

    public InetSocketAddress getConnectAddress() {
      return getBindAddress();
    }
    
    private Job verifyAndGetJob(final JobId jobID) throws IOException {
      UserGroupInformation loginUgi = null;
      Job job = null;
      try {
        loginUgi = UserGroupInformation.getLoginUser();
        job = loginUgi.doAs(new PrivilegedExceptionAction<Job>() {

          @Override
          public Job run() throws Exception {
            Job job = history.getJob(jobID);
            return job;
          }
        });
      } catch (InterruptedException e) {
        throw new IOException(e);
      }
      if (job != null) {
        JobACL operation = JobACL.VIEW_JOB;
        checkAccess(job, operation);
      }
      return job;
    }

    @Override
    public GetCountersResponse getCounters(GetCountersRequest request)
        throws IOException {
      JobId jobId = request.getJobId();
      Job job = verifyAndGetJob(jobId);
      GetCountersResponse response = recordFactory.newRecordInstance(GetCountersResponse.class);
      response.setCounters(TypeConverter.toYarn(job.getAllCounters()));
      return response;
    }

    @Override
    public GetJobReportResponse getJobReport(GetJobReportRequest request)
        throws IOException {
      JobId jobId = request.getJobId();
      Job job = verifyAndGetJob(jobId);
      GetJobReportResponse response = recordFactory.newRecordInstance(GetJobReportResponse.class);
      if (job != null) {
        response.setJobReport(job.getReport());
      }
      else {
        response.setJobReport(null);
      }
      return response;
    }

    @Override
    public GetTaskAttemptReportResponse getTaskAttemptReport(
        GetTaskAttemptReportRequest request) throws IOException {
      TaskAttemptId taskAttemptId = request.getTaskAttemptId();
      Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());
      GetTaskAttemptReportResponse response = recordFactory.newRecordInstance(GetTaskAttemptReportResponse.class);
      response.setTaskAttemptReport(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getReport());
      return response;
    }

    @Override
    public GetTaskReportResponse getTaskReport(GetTaskReportRequest request)
        throws IOException {
      TaskId taskId = request.getTaskId();
      Job job = verifyAndGetJob(taskId.getJobId());
      GetTaskReportResponse response = recordFactory.newRecordInstance(GetTaskReportResponse.class);
      response.setTaskReport(job.getTask(taskId).getReport());
      return response;
    }

    @Override
    public GetTaskAttemptCompletionEventsResponse
        getTaskAttemptCompletionEvents(
            GetTaskAttemptCompletionEventsRequest request) throws IOException {
      JobId jobId = request.getJobId();
      int fromEventId = request.getFromEventId();
      int maxEvents = request.getMaxEvents();

      Job job = verifyAndGetJob(jobId);
      GetTaskAttemptCompletionEventsResponse response = recordFactory.newRecordInstance(GetTaskAttemptCompletionEventsResponse.class);
      response.addAllCompletionEvents(Arrays.asList(job.getTaskAttemptCompletionEvents(fromEventId, maxEvents)));
      return response;
    }

    @Override
    public KillJobResponse killJob(KillJobRequest request) throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public KillTaskResponse killTask(KillTaskRequest request)
        throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public KillTaskAttemptResponse killTaskAttempt(
        KillTaskAttemptRequest request) throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public GetDiagnosticsResponse getDiagnostics(GetDiagnosticsRequest request)
        throws IOException {
      TaskAttemptId taskAttemptId = request.getTaskAttemptId();

      Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());

      GetDiagnosticsResponse response = recordFactory.newRecordInstance(GetDiagnosticsResponse.class);
      response.addAllDiagnostics(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getDiagnostics());
      return response;
    }

    @Override
    public FailTaskAttemptResponse failTaskAttempt(
        FailTaskAttemptRequest request) throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public GetTaskReportsResponse getTaskReports(GetTaskReportsRequest request)
        throws IOException {
      JobId jobId = request.getJobId();
      TaskType taskType = request.getTaskType();

      GetTaskReportsResponse response = recordFactory.newRecordInstance(GetTaskReportsResponse.class);
      Job job = verifyAndGetJob(jobId);
      Collection<Task> tasks = job.getTasks(taskType).values();
      for (Task task : tasks) {
        response.addTaskReport(task.getReport());
      }
      return response;
    }
    
    @Override
    public GetDelegationTokenResponse getDelegationToken(
        GetDelegationTokenRequest request) throws IOException {

      UserGroupInformation ugi = UserGroupInformation.getCurrentUser();

      // Verify that the connection is kerberos authenticated
        if (!isAllowedDelegationTokenOp()) {
          throw new IOException(
              ""Delegation Token can be issued only with kerberos authentication"");
        }

      GetDelegationTokenResponse response = recordFactory.newRecordInstance(
          GetDelegationTokenResponse.class);

      String user = ugi.getUserName();
      Text owner = new Text(user);
      Text realUser = null;
      if (ugi.getRealUser() != null) {
        realUser = new Text(ugi.getRealUser().getUserName());
      }
      MRDelegationTokenIdentifier tokenIdentifier =
          new MRDelegationTokenIdentifier(owner, new Text(
            request.getRenewer()), realUser);
      Token<MRDelegationTokenIdentifier> realJHSToken =
          new Token<MRDelegationTokenIdentifier>(tokenIdentifier,
              jhsDTSecretManager);
      org.apache.hadoop.yarn.api.records.Token mrDToken =
          org.apache.hadoop.yarn.api.records.Token.newInstance(
            realJHSToken.getIdentifier(), realJHSToken.getKind().toString(),
            realJHSToken.getPassword(), realJHSToken.getService().toString());
      response.setDelegationToken(mrDToken);
      return response;
    }

    @Override
    public RenewDelegationTokenResponse renewDelegationToken(
        RenewDelegationTokenRequest request) throws IOException {
        if (!isAllowedDelegationTokenOp()) {
          throw new IOException(
              ""Delegation Token can be renewed only with kerberos authentication"");
        }

        org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();
        Token<MRDelegationTokenIdentifier> token =
            new Token<MRDelegationTokenIdentifier>(
                protoToken.getIdentifier().array(), protoToken.getPassword()
                    .array(), new Text(protoToken.getKind()), new Text(
                    protoToken.getService()));

        String user = UserGroupInformation.getCurrentUser().getShortUserName();
        long nextExpTime = jhsDTSecretManager.renewToken(token, user);
        RenewDelegationTokenResponse renewResponse = Records
            .newRecord(RenewDelegationTokenResponse.class);
        renewResponse.setNextExpirationTime(nextExpTime);
        return renewResponse;
    }

    @Override
    public CancelDelegationTokenResponse cancelDelegationToken(
        CancelDelegationTokenRequest request) throws IOException {
        if (!isAllowedDelegationTokenOp()) {
          throw new IOException(
              ""Delegation Token can be cancelled only with kerberos authentication"");
        }

        org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();
        Token<MRDelegationTokenIdentifier> token =
            new Token<MRDelegationTokenIdentifier>(
                protoToken.getIdentifier().array(), protoToken.getPassword()
                    .array(), new Text(protoToken.getKind()), new Text(
                    protoToken.getService()));

        String user = UserGroupInformation.getCurrentUser().getUserName();
        jhsDTSecretManager.cancelToken(token, user);
        return Records.newRecord(CancelDelegationTokenResponse.class);
    }

    private void checkAccess(Job job, JobACL jobOperation)
        throws IOException {

      UserGroupInformation callerUGI;
      callerUGI = UserGroupInformation.getCurrentUser();

      if (!job.checkAccess(callerUGI, jobOperation)) {
        throw new IOException(new AccessControlException(""User ""
            + callerUGI.getShortUserName() + "" cannot perform operation ""
            + jobOperation.name() + "" on "" + job.getID()));
      }
    }

    private boolean isAllowedDelegationTokenOp() throws IOException {
      if (UserGroupInformation.isSecurityEnabled()) {
        return EnumSet.of(AuthenticationMethod.KERBEROS,
                          AuthenticationMethod.KERBEROS_SSL,
                          AuthenticationMethod.CERTIFICATE)
            .contains(UserGroupInformation.getCurrentUser()
                    .getRealAuthenticationMethod());
      } else {
        return true;
      }
    }

  }
}"
974;12;6159926;blob;none;2019-03-29 13:24:00.488874;class;org.eclipse.che.selenium.core.constant.TestMenuCommandsConstants.Assistant.ToolWindows;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/selenium/che-selenium-test/src/main/java/org/eclipse/che/selenium/core/constant/TestMenuCommandsConstants.java;95;99;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/selenium/che-selenium-test/src/main/java/org/eclipse/che/selenium/core/constant/TestMenuCommandsConstants.java/#L95-L99;1;"    interface ToolWindows {
      String TOOL_WINDOWS = ASSISTANT_MENU_PREFIX + ""toolWindows"";
      String CONTRIBUTE_TOOL_WIDOWS =
          ASSISTANT_MENU_PREFIX + ""Tool Windows/contributePartDisplayingMode"";
    }"
4369;5;6613457;long method;major;2019-04-12 12:12:03.131735;function;com.esri.arcgisruntime.sample.sketcheditor.MainActivity#onCreate Bundle;git@github.com:Esri/arcgis-runtime-samples-android.git;22b9a4c99c82a75a128b64703c0c1ffb2f9f5293;/java/sketch-editor/src/main/java/com/esri/arcgisruntime/sample/sketcheditor/MainActivity.java;44;83;https://github.com/Esri/arcgis-runtime-samples-android/blob/22b9a4c99c82a75a128b64703c0c1ffb2f9f5293/java/sketch-editor/src/main/java/com/esri/arcgisruntime/sample/sketcheditor/MainActivity.java/#L44-L83;0;"  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    // define symbols
    mPointSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.Style.SQUARE, 0xFFFF0000, 20);
    mLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.Style.SOLID, 0xFFFF8800, 4);
    mFillSymbol = new SimpleFillSymbol(SimpleFillSymbol.Style.CROSS, 0x40FFA9A9, mLineSymbol);

    // inflate map view from layout
    mMapView = findViewById(R.id.mapView);
    // create a map with the Basemap Type topographic
    ArcGISMap map = new ArcGISMap(Basemap.Type.LIGHT_GRAY_CANVAS, 34.056295, -117.195800, 16);
    // set the map to be displayed in this view
    mMapView.setMap(map);

    mGraphicsOverlay = new GraphicsOverlay();
    mMapView.getGraphicsOverlays().add(mGraphicsOverlay);

    // create a new sketch editor and add it to the map view
    mSketchEditor = new SketchEditor();
    mMapView.setSketchEditor(mSketchEditor);

    // get buttons from layouts
    mPointButton = findViewById(R.id.pointButton);
    mMultiPointButton = findViewById(R.id.pointsButton);
    mPolylineButton = findViewById(R.id.polylineButton);
    mPolygonButton = findViewById(R.id.polygonButton);
    mFreehandLineButton = findViewById(R.id.freehandLineButton);
    mFreehandPolygonButton = findViewById(R.id.freehandPolygonButton);

    // add click listeners
    mPointButton.setOnClickListener(view -> createModePoint());
    mMultiPointButton.setOnClickListener(view -> createModeMultipoint());
    mPolylineButton.setOnClickListener(view -> createModePolyline());
    mPolygonButton.setOnClickListener(view -> createModePolygon());
    mFreehandLineButton.setOnClickListener(view -> createModeFreehandLine());
    mFreehandPolygonButton.setOnClickListener(view -> createModeFreehandPolygon());
  }"
12647;3;7986025;blob;major;2019-08-06 20:07:06.586448;class;org.eclipse.xtext.xtype.XtypePackage;git@github.com:eclipse/xtext-extras.git;5634c291880cd46fe2f8e9a47e48ef88b85e8bda;/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xtype/XtypePackage.java;38;639;https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xtype/XtypePackage.java/#L38-L639;0;"public interface XtypePackage extends EPackage
{
	/**
	 * The package name.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	String eNAME = ""xtype"";

	/**
	 * The package namespace URI.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	String eNS_URI = ""http://www.eclipse.org/xtext/xbase/Xtype"";

	/**
	 * The package namespace name.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	String eNS_PREFIX = ""xtype"";

	/**
	 * The singleton instance of the package.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	XtypePackage eINSTANCE = org.eclipse.xtext.xtype.impl.XtypePackageImpl.init();

	/**
	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl <em>XFunction Type Ref</em>}' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl
	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXFunctionTypeRef()
	 * @generated
	 */
	int XFUNCTION_TYPE_REF = 0;

	/**
	 * The feature id for the '<em><b>Equivalent</b></em>' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XFUNCTION_TYPE_REF__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;

	/**
	 * The feature id for the '<em><b>Param Types</b></em>' containment reference list.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XFUNCTION_TYPE_REF__PARAM_TYPES = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;

	/**
	 * The feature id for the '<em><b>Return Type</b></em>' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XFUNCTION_TYPE_REF__RETURN_TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;

	/**
	 * The feature id for the '<em><b>Type</b></em>' reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XFUNCTION_TYPE_REF__TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 2;

	/**
	 * The feature id for the '<em><b>Instance Context</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 3;

	/**
	 * The number of structural features of the '<em>XFunction Type Ref</em>' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XFUNCTION_TYPE_REF_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 4;

	/**
	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl <em>XComputed Type Reference</em>}' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl
	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXComputedTypeReference()
	 * @generated
	 */
	int XCOMPUTED_TYPE_REFERENCE = 1;

	/**
	 * The feature id for the '<em><b>Equivalent</b></em>' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XCOMPUTED_TYPE_REFERENCE__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;

	/**
	 * The feature id for the '<em><b>Type Provider</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;

	/**
	 * The number of structural features of the '<em>XComputed Type Reference</em>' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XCOMPUTED_TYPE_REFERENCE_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;

	/**
	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XImportSectionImpl <em>XImport Section</em>}' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see org.eclipse.xtext.xtype.impl.XImportSectionImpl
	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportSection()
	 * @generated
	 */
	int XIMPORT_SECTION = 2;

	/**
	 * The feature id for the '<em><b>Import Declarations</b></em>' containment reference list.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_SECTION__IMPORT_DECLARATIONS = 0;

	/**
	 * The number of structural features of the '<em>XImport Section</em>' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_SECTION_FEATURE_COUNT = 1;

	/**
	 * The meta object id for the '{@link org.eclipse.xtext.xtype.impl.XImportDeclarationImpl <em>XImport Declaration</em>}' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see org.eclipse.xtext.xtype.impl.XImportDeclarationImpl
	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportDeclaration()
	 * @generated
	 */
	int XIMPORT_DECLARATION = 3;

	/**
	 * The feature id for the '<em><b>Wildcard</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION__WILDCARD = 0;

	/**
	 * The feature id for the '<em><b>Extension</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION__EXTENSION = 1;

	/**
	 * The feature id for the '<em><b>Static</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION__STATIC = 2;

	/**
	 * The feature id for the '<em><b>Imported Type</b></em>' reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION__IMPORTED_TYPE = 3;

	/**
	 * The feature id for the '<em><b>Member Name</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION__MEMBER_NAME = 4;

	/**
	 * The feature id for the '<em><b>Imported Namespace</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION__IMPORTED_NAMESPACE = 5;

	/**
	 * The number of structural features of the '<em>XImport Declaration</em>' class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	int XIMPORT_DECLARATION_FEATURE_COUNT = 6;

	/**
	 * The meta object id for the '<em>IJvm Type Reference Provider</em>' data type.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider
	 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getIJvmTypeReferenceProvider()
	 * @generated
	 */
	int IJVM_TYPE_REFERENCE_PROVIDER = 4;


	/**
	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XFunctionTypeRef <em>XFunction Type Ref</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for class '<em>XFunction Type Ref</em>'.
	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef
	 * @generated
	 */
	EClass getXFunctionTypeRef();

	/**
	 * Returns the meta object for the containment reference list '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getParamTypes <em>Param Types</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the containment reference list '<em>Param Types</em>'.
	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getParamTypes()
	 * @see #getXFunctionTypeRef()
	 * @generated
	 */
	EReference getXFunctionTypeRef_ParamTypes();

	/**
	 * Returns the meta object for the containment reference '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getReturnType <em>Return Type</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the containment reference '<em>Return Type</em>'.
	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getReturnType()
	 * @see #getXFunctionTypeRef()
	 * @generated
	 */
	EReference getXFunctionTypeRef_ReturnType();

	/**
	 * Returns the meta object for the reference '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#getType <em>Type</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the reference '<em>Type</em>'.
	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#getType()
	 * @see #getXFunctionTypeRef()
	 * @generated
	 */
	EReference getXFunctionTypeRef_Type();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XFunctionTypeRef#isInstanceContext <em>Instance Context</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Instance Context</em>'.
	 * @see org.eclipse.xtext.xtype.XFunctionTypeRef#isInstanceContext()
	 * @see #getXFunctionTypeRef()
	 * @generated
	 */
	EAttribute getXFunctionTypeRef_InstanceContext();

	/**
	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XComputedTypeReference <em>XComputed Type Reference</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for class '<em>XComputed Type Reference</em>'.
	 * @see org.eclipse.xtext.xtype.XComputedTypeReference
	 * @generated
	 */
	EClass getXComputedTypeReference();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XComputedTypeReference#getTypeProvider <em>Type Provider</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Type Provider</em>'.
	 * @see org.eclipse.xtext.xtype.XComputedTypeReference#getTypeProvider()
	 * @see #getXComputedTypeReference()
	 * @generated
	 */
	EAttribute getXComputedTypeReference_TypeProvider();

	/**
	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XImportSection <em>XImport Section</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for class '<em>XImport Section</em>'.
	 * @see org.eclipse.xtext.xtype.XImportSection
	 * @generated
	 */
	EClass getXImportSection();

	/**
	 * Returns the meta object for the containment reference list '{@link org.eclipse.xtext.xtype.XImportSection#getImportDeclarations <em>Import Declarations</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the containment reference list '<em>Import Declarations</em>'.
	 * @see org.eclipse.xtext.xtype.XImportSection#getImportDeclarations()
	 * @see #getXImportSection()
	 * @generated
	 */
	EReference getXImportSection_ImportDeclarations();

	/**
	 * Returns the meta object for class '{@link org.eclipse.xtext.xtype.XImportDeclaration <em>XImport Declaration</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for class '<em>XImport Declaration</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration
	 * @generated
	 */
	EClass getXImportDeclaration();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isWildcard <em>Wildcard</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Wildcard</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isWildcard()
	 * @see #getXImportDeclaration()
	 * @generated
	 */
	EAttribute getXImportDeclaration_Wildcard();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isExtension <em>Extension</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Extension</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isExtension()
	 * @see #getXImportDeclaration()
	 * @generated
	 */
	EAttribute getXImportDeclaration_Extension();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#isStatic <em>Static</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Static</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration#isStatic()
	 * @see #getXImportDeclaration()
	 * @generated
	 */
	EAttribute getXImportDeclaration_Static();

	/**
	 * Returns the meta object for the reference '{@link org.eclipse.xtext.xtype.XImportDeclaration#getImportedType <em>Imported Type</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the reference '<em>Imported Type</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getImportedType()
	 * @see #getXImportDeclaration()
	 * @generated
	 */
	EReference getXImportDeclaration_ImportedType();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#getMemberName <em>Member Name</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Member Name</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getMemberName()
	 * @see #getXImportDeclaration()
	 * @generated
	 */
	EAttribute getXImportDeclaration_MemberName();

	/**
	 * Returns the meta object for the attribute '{@link org.eclipse.xtext.xtype.XImportDeclaration#getImportedNamespace <em>Imported Namespace</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for the attribute '<em>Imported Namespace</em>'.
	 * @see org.eclipse.xtext.xtype.XImportDeclaration#getImportedNamespace()
	 * @see #getXImportDeclaration()
	 * @generated
	 */
	EAttribute getXImportDeclaration_ImportedNamespace();

	/**
	 * Returns the meta object for data type '{@link org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider <em>IJvm Type Reference Provider</em>}'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the meta object for data type '<em>IJvm Type Reference Provider</em>'.
	 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider
	 * @model instanceClass=""org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider"" serializeable=""false""
	 * @generated
	 */
	EDataType getIJvmTypeReferenceProvider();

	/**
	 * Returns the factory that creates the instances of the model.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return the factory that creates the instances of the model.
	 * @generated
	 */
	XtypeFactory getXtypeFactory();

	/**
	 * <!-- begin-user-doc -->
	 * Defines literals for the meta objects that represent
	 * <ul>
	 *   <li>each class,</li>
	 *   <li>each feature of each class,</li>
	 *   <li>each enum,</li>
	 *   <li>and each data type</li>
	 * </ul>
	 * <!-- end-user-doc -->
	 * @generated
	 */
	interface Literals
	{
		/**
		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl <em>XFunction Type Ref</em>}' class.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @see org.eclipse.xtext.xtype.impl.XFunctionTypeRefImpl
		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXFunctionTypeRef()
		 * @generated
		 */
		EClass XFUNCTION_TYPE_REF = eINSTANCE.getXFunctionTypeRef();

		/**
		 * The meta object literal for the '<em><b>Param Types</b></em>' containment reference list feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EReference XFUNCTION_TYPE_REF__PARAM_TYPES = eINSTANCE.getXFunctionTypeRef_ParamTypes();

		/**
		 * The meta object literal for the '<em><b>Return Type</b></em>' containment reference feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EReference XFUNCTION_TYPE_REF__RETURN_TYPE = eINSTANCE.getXFunctionTypeRef_ReturnType();

		/**
		 * The meta object literal for the '<em><b>Type</b></em>' reference feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EReference XFUNCTION_TYPE_REF__TYPE = eINSTANCE.getXFunctionTypeRef_Type();

		/**
		 * The meta object literal for the '<em><b>Instance Context</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = eINSTANCE.getXFunctionTypeRef_InstanceContext();

		/**
		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl <em>XComputed Type Reference</em>}' class.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @see org.eclipse.xtext.xtype.impl.XComputedTypeReferenceImpl
		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXComputedTypeReference()
		 * @generated
		 */
		EClass XCOMPUTED_TYPE_REFERENCE = eINSTANCE.getXComputedTypeReference();

		/**
		 * The meta object literal for the '<em><b>Type Provider</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = eINSTANCE.getXComputedTypeReference_TypeProvider();

		/**
		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XImportSectionImpl <em>XImport Section</em>}' class.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @see org.eclipse.xtext.xtype.impl.XImportSectionImpl
		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportSection()
		 * @generated
		 */
		EClass XIMPORT_SECTION = eINSTANCE.getXImportSection();

		/**
		 * The meta object literal for the '<em><b>Import Declarations</b></em>' containment reference list feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EReference XIMPORT_SECTION__IMPORT_DECLARATIONS = eINSTANCE.getXImportSection_ImportDeclarations();

		/**
		 * The meta object literal for the '{@link org.eclipse.xtext.xtype.impl.XImportDeclarationImpl <em>XImport Declaration</em>}' class.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @see org.eclipse.xtext.xtype.impl.XImportDeclarationImpl
		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getXImportDeclaration()
		 * @generated
		 */
		EClass XIMPORT_DECLARATION = eINSTANCE.getXImportDeclaration();

		/**
		 * The meta object literal for the '<em><b>Wildcard</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XIMPORT_DECLARATION__WILDCARD = eINSTANCE.getXImportDeclaration_Wildcard();

		/**
		 * The meta object literal for the '<em><b>Extension</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XIMPORT_DECLARATION__EXTENSION = eINSTANCE.getXImportDeclaration_Extension();

		/**
		 * The meta object literal for the '<em><b>Static</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XIMPORT_DECLARATION__STATIC = eINSTANCE.getXImportDeclaration_Static();

		/**
		 * The meta object literal for the '<em><b>Imported Type</b></em>' reference feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EReference XIMPORT_DECLARATION__IMPORTED_TYPE = eINSTANCE.getXImportDeclaration_ImportedType();

		/**
		 * The meta object literal for the '<em><b>Member Name</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XIMPORT_DECLARATION__MEMBER_NAME = eINSTANCE.getXImportDeclaration_MemberName();

		/**
		 * The meta object literal for the '<em><b>Imported Namespace</b></em>' attribute feature.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated
		 */
		EAttribute XIMPORT_DECLARATION__IMPORTED_NAMESPACE = eINSTANCE.getXImportDeclaration_ImportedNamespace();

		/**
		 * The meta object literal for the '<em>IJvm Type Reference Provider</em>' data type.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @see org.eclipse.xtext.xbase.typing.IJvmTypeReferenceProvider
		 * @see org.eclipse.xtext.xtype.impl.XtypePackageImpl#getIJvmTypeReferenceProvider()
		 * @generated
		 */
		EDataType IJVM_TYPE_REFERENCE_PROVIDER = eINSTANCE.getIJvmTypeReferenceProvider();

	}

} //XtypePackage"
1067;17;7030257;feature envy;major;2019-03-29 13:28:49.995359;function;com.github.ambry.network.SocketServer.SocketServer NetworkConfig|SSLConfig|MetricRegistry|ArrayList<Port>;git@github.com:linkedin/ambry.git;1d2e455556058b83f5145740b7f2c5772fa37e1b;/ambry-network/src/main/java/com.github.ambry.network/SocketServer.java;67;82;https://github.com/linkedin/ambry/blob/1d2e455556058b83f5145740b7f2c5772fa37e1b/ambry-network/src/main/java/com.github.ambry.network/SocketServer.java/#L67-L82;1;"  public SocketServer(NetworkConfig config, SSLConfig sslConfig, MetricRegistry registry, ArrayList<Port> portList) {
    this.host = config.hostName;
    this.port = config.port;
    this.numProcessorThreads = config.numIoThreads;
    this.maxQueuedRequests = config.queuedMaxRequests;
    this.sendBufferSize = config.socketSendBufferBytes;
    this.recvBufferSize = config.socketReceiveBufferBytes;
    this.maxRequestSize = config.socketRequestMaxBytes;
    processors = new ArrayList<Processor>(numProcessorThreads);
    requestResponseChannel = new SocketRequestResponseChannel(numProcessorThreads, maxQueuedRequests);
    metrics = new ServerNetworkMetrics(requestResponseChannel, registry, processors);
    this.acceptors = new ArrayList<Acceptor>();
    this.ports = new HashMap<PortType, Port>();
    this.validatePorts(portList);
    this.initializeSSLFactory(sslConfig);
  }"
1837;1;8334400;long method;none;2019-03-29 14:24:41.452819;function;main.Main.main String[];git@github.com:eclipse/org.aspectj.git;370f291c359cd159c5f3f0abd6e9e53e81234a07;/tests/incrementalju/initialTests/sourceAdded/src/main/Main.java;5;6;https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/tests/incrementalju/initialTests/sourceAdded/src/main/Main.java/#L5-L6;1;"    public static void main (String[] args) {
    }"
9728;10;7888064;feature envy;major;2019-07-24 11:07:34.673300;function;com.facebook.buck.core.model.impl.InMemoryBuildFileTree.collectBasePaths Iterable<? extends BuildTarget>;git@github.com:facebook/buck.git;1bc8d383ea5cb153ca9bf4f2807e6be498648523;/src/com/facebook/buck/core/model/impl/InMemoryBuildFileTree.java;71;75;https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/src/com/facebook/buck/core/model/impl/InMemoryBuildFileTree.java/#L71-L75;1;"  private static Collection<Path> collectBasePaths(Iterable<? extends BuildTarget> targets) {
    return StreamSupport.stream(targets.spliterator(), false)
        .map(BuildTarget::getBasePath)
        .collect(ImmutableSet.toImmutableSet());
  }"
2491;3;4218342;blob;none;2019-04-01 19:09:13.563520;class;org.apache.cassandra.cache.IRowCacheEntry;git@github.com:apache/cassandra.git;e191aff385053bdb5325f15bc6d16d2dc0ee0589;/src/java/org/apache/cassandra/cache/IRowCacheEntry.java;20;22;https://github.com/apache/cassandra/blob/e191aff385053bdb5325f15bc6d16d2dc0ee0589/src/java/org/apache/cassandra/cache/IRowCacheEntry.java/#L20-L22;1;"public interface IRowCacheEntry
{
}"
11874;3;6165484;long method;none;2019-08-05 20:41:23.482461;function;org.eclipse.che.ide.ui.smartTree.NodeStorage#hasMatchingKey Node|Node;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/NodeStorage.java;626;628;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/NodeStorage.java/#L626-L628;1;"  public boolean hasMatchingKey(Node model1, Node model2) {
    return keyProvider.getKey(model1).equals(keyProvider.getKey(model2));
  }"
4144;23;6446899;feature envy;major;2019-04-07 09:20:41.212514;function;org.eclipse.orion.internal.server.hosting.SiteInfo#delete UserInfo;git@github.com:eclipse/orion.server.git;24624b85e0d543e8f3cea2bc30f3f589b37de4f0;/bundles/org.eclipse.orion.server.hosting/src/org/eclipse/orion/internal/server/hosting/SiteInfo.java;150;159;https://github.com/eclipse/orion.server/blob/24624b85e0d543e8f3cea2bc30f3f589b37de4f0/bundles/org.eclipse.orion.server.hosting/src/org/eclipse/orion/internal/server/hosting/SiteInfo.java/#L150-L159;1;"	public void delete(UserInfo user) throws CoreException {
		JSONObject sites = getSites(user);
		if (!sites.has(getId())) {
			//nothing to do, site does not exist
			return;
		}
		sites.remove(getId());
		user.setProperty(SiteConfigurationConstants.KEY_SITE_CONFIGURATIONS, sites.toString());
		OrionConfiguration.getMetaStore().updateUser(user);
	}"
10632;13;9483594;data class;critical;2019-07-26 12:54:39.067524;class;org.apache.hadoop.mapreduce.task.ReduceContextImpl.ValueIterable;git@github.com:apache/hadoop.git;128dd91e10080bdcbcd7d555fa3c4105e55a6b51;/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java;350;356;https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java/#L350-L356;1;"  protected class ValueIterable implements Iterable<VALUEIN> {
    private ValueIterator iterator = new ValueIterator();
    @Override
    public Iterator<VALUEIN> iterator() {
      return iterator;
    } 
  }"
14192;20;5384197;long method;major;2019-09-04 10:20:21.824273;function;org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MultiQueryOptimizer#removeAndReconnect MapReduceOper|MapReduceOper;git@github.com:apache/pig.git;17a4d1795ead1f2b4c62043eaf4739ed39ec2f3f;/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java;1096;1141;https://github.com/apache/pig/blob/17a4d1795ead1f2b4c62043eaf4739ed39ec2f3f/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java/#L1096-L1141;1;"    private void removeAndReconnect(MapReduceOper mr, MapReduceOper newMR) throws VisitorException {
        List<MapReduceOper> mapperSuccs = getPlan().getSuccessors(mr);
        List<MapReduceOper> mapperPreds = getPlan().getPredecessors(mr);

        // make a copy before removing operator
        ArrayList<MapReduceOper> succsCopy = null;
        ArrayList<MapReduceOper> predsCopy = null;
        if (mapperSuccs != null) {
            succsCopy = new ArrayList<MapReduceOper>(mapperSuccs);
        }
        if (mapperPreds != null) {
            predsCopy = new ArrayList<MapReduceOper>(mapperPreds);
        }
        getPlan().remove(mr);

        // reconnect the mapper's successors
        if (succsCopy != null) {
            for (MapReduceOper succ : succsCopy) {
                try {
                    getPlan().connect(newMR, succ);
                } catch (PlanException e) {
                    int errCode = 2133;
                    String msg = ""Internal Error. Unable to connect map plan with successors for optimization."";
                    throw new OptimizerException(msg, errCode, PigException.BUG, e);
                }
            }
        }

        // reconnect the mapper's predecessors
        if (predsCopy != null) {
            for (MapReduceOper pred : predsCopy) {
                if (newMR.getOperatorKey().equals(pred.getOperatorKey())) {
                    continue;
                }
                try {
                    getPlan().connect(pred, newMR);
                } catch (PlanException e) {
                    int errCode = 2134;
                    String msg = ""Internal Error. Unable to connect map plan with predecessors for optimization."";
                    throw new OptimizerException(msg, errCode, PigException.BUG, e);
                }
            }
        }

        mergeMROperProperties(mr, newMR);
    }"
14033;20;7148614;blob;none;2019-09-02 06:40:46.459479;class;com.microsoft.intellij.ApplicationSettings.State;git@github.com:Microsoft/azure-tools-for-java.git;d121e8ac9cc3ab400e5b49c8b372280ae332f3fb;/PluginsAndFeatures/azure-toolkit-for-intellij/src/com/microsoft/intellij/ApplicationSettings.java;58;61;https://github.com/Microsoft/azure-tools-for-java/blob/d121e8ac9cc3ab400e5b49c8b372280ae332f3fb/PluginsAndFeatures/azure-toolkit-for-intellij/src/com/microsoft/intellij/ApplicationSettings.java/#L58-L61;1;"    public static class State {
        public Map<String, String> properties = new HashMap<String, String>();
        public Map<String, String[]> array_properties = new HashMap<String, String[]>();
    }"
590;6;5875574;feature envy;none;2019-03-27 10:49:44.041350;function;org.apache.usergrid.rest.management.users.UserResource#getToken;git@github.com:apache/usergrid.git;ac1e6e4035f9307b871478ed47246cf92cfd5f7f;/stack/rest/src/main/java/org/apache/usergrid/rest/management/users/UserResource.java;362;364;https://github.com/apache/usergrid/blob/ac1e6e4035f9307b871478ed47246cf92cfd5f7f/stack/rest/src/main/java/org/apache/usergrid/rest/management/users/UserResource.java/#L362-L364;1;"    public String getToken() {
        return token;
    }"
2343;3;3986717;long method;major;2019-04-01 14:09:34.238992;function;org.apache.polygene.api.util.Classes.simpleGenericNameOf StringBuilder|Type;git@github.com:apache/attic-polygene-java.git;031beef870302a0bd01bd5895ce849e00f2d5d5b;/core/api/src/main/java/org/apache/polygene/api/util/Classes.java;288;342;https://github.com/apache/attic-polygene-java/blob/031beef870302a0bd01bd5895ce849e00f2d5d5b/core/api/src/main/java/org/apache/polygene/api/util/Classes.java/#L288-L342;0;"    @SuppressWarnings( ""raw"" )
    private static void simpleGenericNameOf( StringBuilder sb, Type type )
    {
        if( type instanceof Class )
        {
            sb.append( ( (Class) type ).getSimpleName() );
        }
        else if( type instanceof ParameterizedType )
        {
            ParameterizedType pt = (ParameterizedType) type;
            simpleGenericNameOf( sb, pt.getRawType() );
            sb.append( ""<"" );
            boolean atLeastOne = false;
            for( Type typeArgument : pt.getActualTypeArguments() )
            {
                if( atLeastOne )
                {
                    sb.append( "", "" );
                }
                simpleGenericNameOf( sb, typeArgument );
                atLeastOne = true;
            }
            sb.append( "">"" );
        }
        else if( type instanceof GenericArrayType )
        {
            GenericArrayType gat = (GenericArrayType) type;
            simpleGenericNameOf( sb, gat.getGenericComponentType() );
            sb.append( ""[]"" );
        }
        else if( type instanceof TypeVariable )
        {
            TypeVariable tv = (TypeVariable) type;
            sb.append( tv.getName() );
        }
        else if( type instanceof WildcardType )
        {
            WildcardType wt = (WildcardType) type;
            sb.append( ""? extends "" );
            boolean atLeastOne = false;
            for( Type typeArgument : wt.getUpperBounds() )
            {
                if( atLeastOne )
                {
                    sb.append( "", "" );
                }
                simpleGenericNameOf( sb, typeArgument );
                atLeastOne = true;
            }
        }
        else
        {
            throw new IllegalArgumentException( ""Don't know how to deal with type:"" + type );
        }
    }"
14230;13;7481501;data class;critical;2019-09-04 12:05:53.926444;class;example.model.Customer1953;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/model/Customer1953.java;8;27;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1953.java/#L8-L27;0;"@Entity
public class Customer1953 {

	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id;
	private String firstName;
	private String lastName;

	protected Customer1953() {}

	public Customer1953(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	@Override
	public String toString() {
		return String.format(""Customer1953[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}

}"
14269;5;6165484;feature envy;none;2019-09-04 13:35:32.823188;function;org.eclipse.che.ide.ui.smartTree.NodeStorage#hasMatchingKey Node|Node;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/NodeStorage.java;626;628;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/ide/che-core-ide-ui/src/main/java/org/eclipse/che/ide/ui/smartTree/NodeStorage.java/#L626-L628;1;"  public boolean hasMatchingKey(Node model1, Node model2) {
    return keyProvider.getKey(model1).equals(keyProvider.getKey(model2));
  }"
3946;13;7726353;blob;none;2019-04-05 14:39:27.196100;class;com.vmware.admiral.request.ClusteringTaskService.CallbackCompleteResponse;git@github.com:vmware/admiral.git;e02d0e77f65d0ee3541a378110ecd4233bdb6664;/request/src/main/java/com/vmware/admiral/request/ClusteringTaskService.java;164;166;https://github.com/vmware/admiral/blob/e02d0e77f65d0ee3541a378110ecd4233bdb6664/request/src/main/java/com/vmware/admiral/request/ClusteringTaskService.java/#L164-L166;1;"    protected static class CallbackCompleteResponse extends ServiceTaskCallbackResponse {
        Set<String> resourceLinks;
    }"
4244;7;4327219;long method;none;2019-04-10 09:39:33.431794;function;org.apache.derbyTesting.functionTests.tests.lang.AnsiSignatures.double_double_double Blob;git@github.com:apache/derby.git;bd246fc89d4fce3f82f8344074ecb8a4713418df;/java/org.apache.derby.tests/org/apache/derbyTesting/functionTests/tests/lang/AnsiSignatures.java;818;818;https://github.com/apache/derby/blob/bd246fc89d4fce3f82f8344074ecb8a4713418df/java/org.apache.derby.tests/org/apache/derbyTesting/functionTests/tests/lang/AnsiSignatures.java/#L818-L818;1;"    public  static  double   double_double_double( Blob a ) { return -1.0; }"
13553;1;5499603;long method;major;2019-08-30 08:07:33.974469;function;org.apache.rocketmq.console.service.impl.ConsumerServiceImpl#resetOffset ResetOffsetRequest;git@github.com:apache/rocketmq-externals.git;dba6eb0c997d5c325f26b3d1da9d739d927228dc;/rocketmq-console/src/main/java/org/apache/rocketmq/console/service/impl/ConsumerServiceImpl.java;208;251;https://github.com/apache/rocketmq-externals/blob/dba6eb0c997d5c325f26b3d1da9d739d927228dc/rocketmq-console/src/main/java/org/apache/rocketmq/console/service/impl/ConsumerServiceImpl.java/#L208-L251;1;"    @Override
    @MultiMQAdminCmdMethod
    public Map<String, ConsumerGroupRollBackStat> resetOffset(ResetOffsetRequest resetOffsetRequest) {
        Map<String, ConsumerGroupRollBackStat> groupRollbackStats = Maps.newHashMap();
        for (String consumerGroup : resetOffsetRequest.getConsumerGroupList()) {
            try {
                Map<MessageQueue, Long> rollbackStatsMap =
                    mqAdminExt.resetOffsetByTimestamp(resetOffsetRequest.getTopic(), consumerGroup, resetOffsetRequest.getResetTime(), resetOffsetRequest.isForce());
                ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
                List<RollbackStats> rollbackStatsList = consumerGroupRollBackStat.getRollbackStatsList();
                for (Map.Entry<MessageQueue, Long> rollbackStatsEntty : rollbackStatsMap.entrySet()) {
                    RollbackStats rollbackStats = new RollbackStats();
                    rollbackStats.setRollbackOffset(rollbackStatsEntty.getValue());
                    rollbackStats.setQueueId(rollbackStatsEntty.getKey().getQueueId());
                    rollbackStats.setBrokerName(rollbackStatsEntty.getKey().getBrokerName());
                    rollbackStatsList.add(rollbackStats);
                }
                groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
            }
            catch (MQClientException e) {
                if (ResponseCode.CONSUMER_NOT_ONLINE == e.getResponseCode()) {
                    try {
                        ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
                        List<RollbackStats> rollbackStatsList = mqAdminExt.resetOffsetByTimestampOld(consumerGroup, resetOffsetRequest.getTopic(), resetOffsetRequest.getResetTime(), true);
                        consumerGroupRollBackStat.setRollbackStatsList(rollbackStatsList);
                        groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
                        continue;
                    }
                    catch (Exception err) {
                        logger.error(""op=resetOffset_which_not_online_error"", err);
                    }
                }
                else {
                    logger.error(""op=resetOffset_error"", e);
                }
                groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
            }
            catch (Exception e) {
                logger.error(""op=resetOffset_error"", e);
                groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
            }
        }
        return groupRollbackStats;
    }"
11201;3;7432284;long method;major;2019-08-04 19:38:38.219575;function;org.springframework.data.jdbc.config.oracle.PoolingDataSourceBeanDefinitionParser#setOptionalAttribute BeanDefinitionBuilder|Map<String, Object>|String|String|String;git@github.com:spring-projects/spring-data-jdbc-ext.git;9f19335f6f776ad36158cfaa0f5aad64333ce988;/spring-data-oracle/src/main/java/org/springframework/data/jdbc/config/oracle/PoolingDataSourceBeanDefinitionParser.java;341;388;https://github.com/spring-projects/spring-data-jdbc-ext/blob/9f19335f6f776ad36158cfaa0f5aad64333ce988/spring-data-oracle/src/main/java/org/springframework/data/jdbc/config/oracle/PoolingDataSourceBeanDefinitionParser.java/#L341-L388;0;"	private void setOptionalAttribute(BeanDefinitionBuilder builder,
				Map<String, Object> providedProperties,
				String propertyPrefix,
				String attributeValue,
				String attributeName) {
		String propertyKey;
		if (""username"".equals(attributeName)) {
			String userKey = (propertyPrefix != null ?
					propertyPrefix + ""user"" :
					""user"");
			if (providedProperties.containsKey(userKey)) {
				propertyKey = userKey;
			}
			else {
				propertyKey = (propertyPrefix != null ?
						propertyPrefix + attributeName :
						attributeName);
			}
		}
		else {
			propertyKey = (propertyPrefix != null ?
					propertyPrefix + attributeToPropertyMap.get(attributeName) :
					attributeToPropertyMap.get(attributeName));
		}

		if (StringUtils.hasText(attributeValue)) {
			if (logger.isDebugEnabled()) {
				if (""password"".equals(attributeName)) {
					logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +
							"" with attribute value ******"");
				}
				else {
					logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +
							"" with attribute value "" + attributeValue);
				}
			}
			builder.addPropertyValue(attributeToPropertyMap.get(attributeName), attributeValue);
		}
		else if (providedProperties.containsKey(propertyKey)) {
			if (logger.isDebugEnabled()) {
				logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +
						"" with property value "" +
						(""password"".equals(attributeName) ? ""******"" : providedProperties.get(propertyKey)));
			}
			builder.addPropertyValue(attributeToPropertyMap.get(attributeName), providedProperties.get(propertyKey));
		}
		removeProvidedProperty(providedProperties, propertyKey);
	}"
10760;4;3786480;blob;major;2019-07-26 20:04:52.642808;class;com.google.android.exoplayer2.ext.okhttp.OkHttpDataSource;git@github.com:amzn/exoplayer-amazon-port.git;90cf56092dca07e8752f8f7e063a0b3b98313942;/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java;48;389;https://github.com/amzn/exoplayer-amazon-port/blob/90cf56092dca07e8752f8f7e063a0b3b98313942/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java/#L48-L389;0,5;"public class OkHttpDataSource extends BaseDataSource implements HttpDataSource {

  static {
    ExoPlayerLibraryInfo.registerModule(""goog.exo.okhttp"");
  }

  private static final byte[] SKIP_BUFFER = new byte[4096];

  private final Call.Factory callFactory;
  private final RequestProperties requestProperties;

  private final @Nullable String userAgent;
  private final @Nullable Predicate<String> contentTypePredicate;
  private final @Nullable CacheControl cacheControl;
  private final @Nullable RequestProperties defaultRequestProperties;

  private @Nullable DataSpec dataSpec;
  private @Nullable Response response;
  private @Nullable InputStream responseByteStream;
  private boolean opened;

  private long bytesToSkip;
  private long bytesToRead;

  private long bytesSkipped;
  private long bytesRead;

  /**
   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
   *     by the source.
   * @param userAgent An optional User-Agent string.
   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
   *     predicate then a {@link InvalidContentTypeException} is thrown from {@link
   *     #open(DataSpec)}.
   */
  public OkHttpDataSource(
      Call.Factory callFactory,
      @Nullable String userAgent,
      @Nullable Predicate<String> contentTypePredicate) {
    this(
        callFactory,
        userAgent,
        contentTypePredicate,
        /* cacheControl= */ null,
        /* defaultRequestProperties= */ null);
  }

  /**
   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
   *     by the source.
   * @param userAgent An optional User-Agent string.
   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
   *     predicate then a {@link InvalidContentTypeException} is thrown from {@link
   *     #open(DataSpec)}.
   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
   * @param defaultRequestProperties The optional default {@link RequestProperties} to be sent to
   *     the server as HTTP headers on every request.
   */
  public OkHttpDataSource(
      Call.Factory callFactory,
      @Nullable String userAgent,
      @Nullable Predicate<String> contentTypePredicate,
      @Nullable CacheControl cacheControl,
      @Nullable RequestProperties defaultRequestProperties) {
    super(/* isNetwork= */ true);
    this.callFactory = Assertions.checkNotNull(callFactory);
    this.userAgent = userAgent;
    this.contentTypePredicate = contentTypePredicate;
    this.cacheControl = cacheControl;
    this.defaultRequestProperties = defaultRequestProperties;
    this.requestProperties = new RequestProperties();
  }

  @Override
  public @Nullable Uri getUri() {
    return response == null ? null : Uri.parse(response.request().url().toString());
  }

  @Override
  public Map<String, List<String>> getResponseHeaders() {
    return response == null ? Collections.emptyMap() : response.headers().toMultimap();
  }

  @Override
  public void setRequestProperty(String name, String value) {
    Assertions.checkNotNull(name);
    Assertions.checkNotNull(value);
    requestProperties.set(name, value);
  }

  @Override
  public void clearRequestProperty(String name) {
    Assertions.checkNotNull(name);
    requestProperties.remove(name);
  }

  @Override
  public void clearAllRequestProperties() {
    requestProperties.clear();
  }

  @Override
  public long open(DataSpec dataSpec) throws HttpDataSourceException {
    this.dataSpec = dataSpec;
    this.bytesRead = 0;
    this.bytesSkipped = 0;
    transferInitializing(dataSpec);

    Request request = makeRequest(dataSpec);
    Response response;
    ResponseBody responseBody;
    try {
      this.response = callFactory.newCall(request).execute();
      response = this.response;
      responseBody = Assertions.checkNotNull(response.body());
      responseByteStream = responseBody.byteStream();
    } catch (IOException e) {
      throw new HttpDataSourceException(
          ""Unable to connect to "" + dataSpec.uri, e, dataSpec, HttpDataSourceException.TYPE_OPEN);
    }

    int responseCode = response.code();

    // Check for a valid response code.
    if (!response.isSuccessful()) {
      Map<String, List<String>> headers = response.headers().toMultimap();
      closeConnectionQuietly();
      InvalidResponseCodeException exception =
          new InvalidResponseCodeException(responseCode, response.message(), headers, dataSpec);
      if (responseCode == 416) {
        exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
      }
      throw exception;
    }

    // Check for a valid content type.
    MediaType mediaType = responseBody.contentType();
    String contentType = mediaType != null ? mediaType.toString() : """";
    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
      closeConnectionQuietly();
      throw new InvalidContentTypeException(contentType, dataSpec);
    }

    // If we requested a range starting from a non-zero position and received a 200 rather than a
    // 206, then the server does not support partial requests. We'll need to manually skip to the
    // requested position.
    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;

    // Determine the length of the data to be read, after skipping.
    if (dataSpec.length != C.LENGTH_UNSET) {
      bytesToRead = dataSpec.length;
    } else {
      long contentLength = responseBody.contentLength();
      bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
    }

    opened = true;
    transferStarted(dataSpec);

    return bytesToRead;
  }

  @Override
  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
    try {
      skipInternal();
      return readInternal(buffer, offset, readLength);
    } catch (IOException e) {
      throw new HttpDataSourceException(
          e, Assertions.checkNotNull(dataSpec), HttpDataSourceException.TYPE_READ);
    }
  }

  @Override
  public void close() throws HttpDataSourceException {
    if (opened) {
      opened = false;
      transferEnded();
      closeConnectionQuietly();
    }
  }

  /**
   * Returns the number of bytes that have been skipped since the most recent call to
   * {@link #open(DataSpec)}.
   *
   * @return The number of bytes skipped.
   */
  protected final long bytesSkipped() {
    return bytesSkipped;
  }

  /**
   * Returns the number of bytes that have been read since the most recent call to
   * {@link #open(DataSpec)}.
   *
   * @return The number of bytes read.
   */
  protected final long bytesRead() {
    return bytesRead;
  }

  /**
   * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
   * <p>
   * If the total length of the data being read is known, then this length minus {@code bytesRead()}
   * is returned. If the total length is unknown, {@link C#LENGTH_UNSET} is returned.
   *
   * @return The remaining length, or {@link C#LENGTH_UNSET}.
   */
  protected final long bytesRemaining() {
    return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
  }

  /** Establishes a connection. */
  private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {
    long position = dataSpec.position;
    long length = dataSpec.length;
    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);

    HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
    if (url == null) {
      throw new HttpDataSourceException(
          ""Malformed URL"", dataSpec, HttpDataSourceException.TYPE_OPEN);
    }

    Request.Builder builder = new Request.Builder().url(url);
    if (cacheControl != null) {
      builder.cacheControl(cacheControl);
    }
    if (defaultRequestProperties != null) {
      for (Map.Entry<String, String> property : defaultRequestProperties.getSnapshot().entrySet()) {
        builder.header(property.getKey(), property.getValue());
      }
    }
    for (Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {
      builder.header(property.getKey(), property.getValue());
    }
    if (!(position == 0 && length == C.LENGTH_UNSET)) {
      String rangeRequest = ""bytes="" + position + ""-"";
      if (length != C.LENGTH_UNSET) {
        rangeRequest += (position + length - 1);
      }
      builder.addHeader(""Range"", rangeRequest);
    }
    if (userAgent != null) {
      builder.addHeader(""User-Agent"", userAgent);
    }

    if (!allowGzip) {
      builder.addHeader(""Accept-Encoding"", ""identity"");
    }
    RequestBody requestBody = null;
    if (dataSpec.httpBody != null) {
      requestBody = RequestBody.create(null, dataSpec.httpBody);
    } else if (dataSpec.httpMethod == DataSpec.HTTP_METHOD_POST) {
      // OkHttp requires a non-null body for POST requests.
      requestBody = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
    }
    builder.method(dataSpec.getHttpMethodString(), requestBody);
    return builder.build();
  }

  /**
   * Skips any bytes that need skipping. Else does nothing.
   * <p>
   * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
   *
   * @throws InterruptedIOException If the thread is interrupted during the operation.
   * @throws EOFException If the end of the input stream is reached before the bytes are skipped.
   */
  private void skipInternal() throws IOException {
    if (bytesSkipped == bytesToSkip) {
      return;
    }

    while (bytesSkipped != bytesToSkip) {
      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, SKIP_BUFFER.length);
      int read = castNonNull(responseByteStream).read(SKIP_BUFFER, 0, readLength);
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedIOException();
      }
      if (read == -1) {
        throw new EOFException();
      }
      bytesSkipped += read;
      bytesTransferred(read);
    }
  }

  /**
   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
   * index {@code offset}.
   * <p>
   * This method blocks until at least one byte of data can be read, the end of the opened range is
   * detected, or an exception is thrown.
   *
   * @param buffer The buffer into which the read data should be stored.
   * @param offset The start offset into {@code buffer} at which data should be written.
   * @param readLength The maximum number of bytes to read.
   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
   *     range is reached.
   * @throws IOException If an error occurs reading from the source.
   */
  private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
    if (readLength == 0) {
      return 0;
    }
    if (bytesToRead != C.LENGTH_UNSET) {
      long bytesRemaining = bytesToRead - bytesRead;
      if (bytesRemaining == 0) {
        return C.RESULT_END_OF_INPUT;
      }
      readLength = (int) Math.min(readLength, bytesRemaining);
    }

    int read = castNonNull(responseByteStream).read(buffer, offset, readLength);
    if (read == -1) {
      if (bytesToRead != C.LENGTH_UNSET) {
        // End of stream reached having not read sufficient data.
        throw new EOFException();
      }
      return C.RESULT_END_OF_INPUT;
    }

    bytesRead += read;
    bytesTransferred(read);
    return read;
  }

  /**
   * Closes the current connection quietly, if there is one.
   */
  private void closeConnectionQuietly() {
    if (response != null) {
      Assertions.checkNotNull(response.body()).close();
      response = null;
    }
    responseByteStream = null;
  }

}"
3910;13;5547100;blob;none;2019-04-05 14:25:05.191712;class;org.apache.sentry.api.service.thrift.TAlterSentryRoleDeleteUsersResponse.TAlterSentryRoleDeleteUsersResponseStandardSchemeFactory;git@github.com:apache/sentry.git;f859446b65bbc274bc4899464892151eec8217c6;/sentry-service/sentry-service-api/src/gen/thrift/gen-javabean/org/apache/sentry/api/service/thrift/TAlterSentryRoleDeleteUsersResponse.java;319;323;https://github.com/apache/sentry/blob/f859446b65bbc274bc4899464892151eec8217c6/sentry-service/sentry-service-api/src/gen/thrift/gen-javabean/org/apache/sentry/api/service/thrift/TAlterSentryRoleDeleteUsersResponse.java/#L319-L323;1;"  private static class TAlterSentryRoleDeleteUsersResponseStandardSchemeFactory implements SchemeFactory {
    public TAlterSentryRoleDeleteUsersResponseStandardScheme getScheme() {
      return new TAlterSentryRoleDeleteUsersResponseStandardScheme();
    }
  }"
710;7;6236496;long method;major;2019-03-27 11:17:30.896732;function;org.eclipse.elk.core.meta.ide.contentassist.antlr.internal.InternalMetaDataParser#rule__XWhileExpression__Group__0__Impl;git@github.com:eclipse/elk.git;9a87764f00d863463b1be6de1920d8aa3c3ade70;/plugins/org.eclipse.elk.core.meta.ui/src-gen/org/eclipse/elk/core/meta/ide/contentassist/antlr/internal/InternalMetaDataParser.java;45156;45191;https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.core.meta.ui/src-gen/org/eclipse/elk/core/meta/ide/contentassist/antlr/internal/InternalMetaDataParser.java/#L45156-L45191;1;"    public final void rule__XWhileExpression__Group__0__Impl() throws RecognitionException {

        		int stackSize = keepStackSize();
        	
        try {
            // InternalMetaData.g:13570:1: ( ( () ) )
            // InternalMetaData.g:13571:1: ( () )
            {
            // InternalMetaData.g:13571:1: ( () )
            // InternalMetaData.g:13572:2: ()
            {
            if ( state.backtracking==0 ) {
               before(grammarAccess.getXWhileExpressionAccess().getXWhileExpressionAction_0()); 
            }
            // InternalMetaData.g:13573:2: ()
            // InternalMetaData.g:13573:3: 
            {
            }

            if ( state.backtracking==0 ) {
               after(grammarAccess.getXWhileExpressionAccess().getXWhileExpressionAction_0()); 
            }

            }


            }

        }
        finally {

            	restoreStackSize(stackSize);

        }
        return ;
    }"
13576;1;3812473;data class;major;2019-08-30 09:15:43.721298;class;org.apache.activemq.artemis.core.protocol.stomp.StompFrame.Header;git@github.com:apache/activemq-artemis.git;5bd5c610195d6f4a3dd1ac28170727003f8a5a54;/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java;158;175;https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175;1;"   public class Header {

      public String key;
      public String val;

      public Header(String key, String val) {
         this.key = key;
         this.val = val;
      }

      public String getEncodedKey() {
         return encode(key);
      }

      public String getEncodedValue() {
         return encode(val);
      }
   }"
3877;17;6795278;feature envy;major;2019-04-05 13:39:38.617982;function;com.google.javascript.rhino.jstype.AllType#recursionUnsafeHashCode;git@github.com:google/closure-compiler.git;0393c80ca01b6b861376dad7f91043a38bb37dc0;/src/com/google/javascript/rhino/jstype/AllType.java;112;115;https://github.com/google/closure-compiler/blob/0393c80ca01b6b861376dad7f91043a38bb37dc0/src/com/google/javascript/rhino/jstype/AllType.java/#L112-L115;1;"  @Override
  int recursionUnsafeHashCode() {
    return System.identityHashCode(this);
  }"
3174;5;5112767;blob;none;2019-04-05 12:42:00.496956;class;org.issue.user.User;git@github.com:apache/maven-compiler-plugin.git;3d6b27cc81c3dde2d537ca3be1117d470d0017f3;/src/it/MCOMPILER-224/annotation-user/src/main/java/org/issue/user/User.java;25;29;https://github.com/apache/maven-compiler-plugin/blob/3d6b27cc81c3dde2d537ca3be1117d470d0017f3/src/it/MCOMPILER-224/annotation-user/src/main/java/org/issue/user/User.java/#L25-L29;1;"@MCompiler224
public class User
{

}"
14025;20;8618517;long method;major;2019-09-02 06:39:48.130365;function;org.apache.ignite.internal.processors.cache.transactions.TxLocksResponse#readFrom ByteBuffer|MessageReader;git@github.com:apache/ignite.git;7a7c407ea41477aae8508bfe871b4e9a67e1b277;/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/TxLocksResponse.java;272;317;https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/TxLocksResponse.java/#L272-L317;1;"    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {
        reader.setBuffer(buf);

        if (!reader.beforeMessageRead())
            return false;

        if (!super.readFrom(buf, reader))
            return false;

        switch (reader.state()) {
            case 3:
                futId = reader.readLong(""futId"");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 4:
                locksArr = reader.readObjectArray(""locksArr"", MessageCollectionItemType.MSG, TxLockList.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 5:
                nearTxKeysArr = reader.readObjectArray(""nearTxKeysArr"", MessageCollectionItemType.MSG, IgniteTxKey.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 6:
                txKeysArr = reader.readObjectArray(""txKeysArr"", MessageCollectionItemType.MSG, IgniteTxKey.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

        }

        return reader.afterMessageRead(TxLocksResponse.class);
    }"
10618;13;8539645;data class;critical;2019-07-26 12:48:32.099226;class;org.apache.cloudstack.api.response.DeploymentPlannersResponse;git@github.com:apache/cloudstack.git;8d3feb100aab4a45b31a789f444038b892161eec;/api/src/main/java/org/apache/cloudstack/api/response/DeploymentPlannersResponse.java;26;38;https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/response/DeploymentPlannersResponse.java/#L26-L38;1;"public class DeploymentPlannersResponse extends BaseResponse {
    @SerializedName(ApiConstants.NAME)
    @Param(description = ""Deployment Planner name"")
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}"
3207;14;5923886;feature envy;critical;2019-04-05 12:45:02.573397;function;org.apache.zeppelin.jupyter.nbformat.Error#getTraceback;git@github.com:apache/zeppelin.git;4219d552349f8f7f3e6de34505b8a8ae9835f98b;/zeppelin-jupyter/src/main/java/org/apache/zeppelin/jupyter/nbformat/Error.java;48;50;https://github.com/apache/zeppelin/blob/4219d552349f8f7f3e6de34505b8a8ae9835f98b/zeppelin-jupyter/src/main/java/org/apache/zeppelin/jupyter/nbformat/Error.java/#L48-L50;1;"  public List<String> getTraceback() {
    return traceback;
  }"
794;11;6431408;long method;none;2019-03-29 13:11:30.384468;function;org.eclipse.milo.opcua.stack.core.types.structured.BrowseDescription#getNodeClassMask;git@github.com:eclipse/milo.git;e752e540d31eb3c226e6e79dd197c54d7d254685;/opc-ua-stack/stack-core/src/main/java/org/eclipse/milo/opcua/stack/core/types/structured/BrowseDescription.java;63;63;https://github.com/eclipse/milo/blob/e752e540d31eb3c226e6e79dd197c54d7d254685/opc-ua-stack/stack-core/src/main/java/org/eclipse/milo/opcua/stack/core/types/structured/BrowseDescription.java/#L63-L63;1;"    public UInteger getNodeClassMask() { return nodeClassMask; }"
1417;4;7482808;blob;none;2019-03-29 13:50:03.821476;class;example.service.Customer1142Service;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer1142Service.java;7;11;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer1142Service.java/#L7-L11;0;"@Service
public class Customer1142Service {
	public Customer1142Service(Customer1142Repository repo) {
	}
}"
13199;12;5907678;feature envy;major;2019-08-23 07:42:14.003394;function;org.apache.xpath.compiler.OpMap#setOp int|int;git@github.com:apache/xalan-j.git;cba6d7fe7e93defecb98d155e2a780f8a3f1fbaa;/src/org/apache/xpath/compiler/OpMap.java;185;188;https://github.com/apache/xalan-j/blob/cba6d7fe7e93defecb98d155e2a780f8a3f1fbaa/src/org/apache/xpath/compiler/OpMap.java/#L185-L188;0;"  public void setOp(int opPos, int value)
  {
     m_opMap.setElementAt(value,opPos);
  }"
9174;20;4095482;long method;major;2019-07-23 14:56:53.691673;function;org.apache.hyracks.dataflow.std.join.NestedLoopJoin.NestedLoopJoin IHyracksTaskContext|FrameTupleAccessor|FrameTupleAccessor|ITuplePairComparator|int|IPredicateEvaluator|boolean|IMissingWriter[];git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/hyracks-fullstack/hyracks/hyracks-dataflow-std/src/main/java/org/apache/hyracks/dataflow/std/join/NestedLoopJoin.java;60;97;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/hyracks-fullstack/hyracks/hyracks-dataflow-std/src/main/java/org/apache/hyracks/dataflow/std/join/NestedLoopJoin.java/#L60-L97;1;"    public NestedLoopJoin(IHyracksTaskContext ctx, FrameTupleAccessor accessorOuter, FrameTupleAccessor accessorInner,
            ITuplePairComparator comparatorsOuter2Inner, int memSize, IPredicateEvaluator predEval, boolean isLeftOuter,
            IMissingWriter[] missingWriters) throws HyracksDataException {
        this.accessorInner = accessorInner;
        this.accessorOuter = accessorOuter;
        this.appender = new FrameTupleAppender();
        this.tpComparator = comparatorsOuter2Inner;
        this.outBuffer = new VSizeFrame(ctx);
        this.innerBuffer = new VSizeFrame(ctx);
        this.appender.reset(outBuffer, true);
        if (memSize < 3) {
            throw new HyracksDataException(""Not enough memory is available for Nested Loop Join"");
        }
        this.outerBufferMngr =
                new VariableFrameMemoryManager(new VariableFramePool(ctx, ctx.getInitialFrameSize() * (memSize - 2)),
                        FrameFreeSlotPolicyFactory.createFreeSlotPolicy(EnumFreeSlotPolicy.LAST_FIT, memSize - 2));

        this.predEvaluator = predEval;
        this.isReversed = false;

        this.isLeftOuter = isLeftOuter;
        if (isLeftOuter) {
            int innerFieldCount = this.accessorInner.getFieldCount();
            missingTupleBuilder = new ArrayTupleBuilder(innerFieldCount);
            DataOutput out = missingTupleBuilder.getDataOutput();
            for (int i = 0; i < innerFieldCount; i++) {
                missingWriters[i].writeMissing(out);
                missingTupleBuilder.addFieldEndOffset();
            }
        } else {
            missingTupleBuilder = null;
        }

        FileReference file =
                ctx.getJobletContext().createManagedWorkspaceFile(this.getClass().getSimpleName() + this.toString());
        runFileWriter = new RunFileWriter(file, ctx.getIoManager());
        runFileWriter.open();
    }"
8527;12;9312894;feature envy;major;2019-07-19 12:30:10.361061;function;jdk.management.jfr.ConfigurationInfo.ConfigurationInfo CompositeData;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/jdk.management.jfr/share/classes/jdk/management/jfr/ConfigurationInfo.java;63;70;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/jdk.management.jfr/share/classes/jdk/management/jfr/ConfigurationInfo.java/#L63-L70;1;"    private ConfigurationInfo(CompositeData cd) {
        this.settings = createMap(cd.get(""settings""));
        this.name = (String) cd.get(""name"");
        this.label = (String) cd.get(""label"");
        this.description = (String) cd.get(""description"");
        this.provider = (String) cd.get(""provider"");
        this.contents = (String) cd.get(""contents"");
    }"
12470;3;5023689;long method;critical;2019-08-06 16:36:41.639051;function;org.apache.lens.cube.metadata.FactPartition#compareTo FactPartition;git@github.com:apache/lens.git;f64a0f5984216a61f0a2c5ef90510a88390acde0;/lens-cube/src/main/java/org/apache/lens/cube/metadata/FactPartition.java;148;195;https://github.com/apache/lens/blob/f64a0f5984216a61f0a2c5ef90510a88390acde0/lens-cube/src/main/java/org/apache/lens/cube/metadata/FactPartition.java/#L148-L195;0,5;"  public int compareTo(FactPartition o) {
    int colComp = this.partCol.compareTo(o.partCol);
    if (colComp == 0) {
      int partComp = 0;
      if (this.partSpec != null) {
        if (o.partSpec == null) {
          partComp = 1;
        } else {
          partComp = this.partSpec.compareTo(o.partSpec);
        }
      } else {
        if (o.partSpec != null) {
          partComp = -1;
        } else {
          partComp = 0;
        }
      }
      if (partComp == 0) {
        int upComp = 0;
        if (this.period != null && o.period != null) {
          upComp = this.period.compareTo(o.period);
        } else if (this.period == null && o.period == null) {
          upComp = 0;
        } else if (this.period == null) {
          upComp = -1;
        } else {
          upComp = 1;
        }
        if (upComp == 0) {
          if (this.containingPart != null) {
            if (o.containingPart == null) {
              return 1;
            }
            return this.containingPart.compareTo(o.containingPart);
          } else {
            if (o.containingPart != null) {
              return -1;
            } else {
              return 0;
            }
          }
        }
        return upComp;
      }
      return partComp;
    }
    return colComp;
  }"
844;4;6502815;feature envy;none;2019-03-29 13:15:48.934471;function;org.eclipse.rdf4j.http.client.QueueCursor.QueueCursor int;git@github.com:eclipse/rdf4j.git;6f63df540e30b28e0c8880bea72f85cb88424b03;/http/client/src/main/java/org/eclipse/rdf4j/http/client/QueueCursor.java;27;29;https://github.com/eclipse/rdf4j/blob/6f63df540e30b28e0c8880bea72f85cb88424b03/http/client/src/main/java/org/eclipse/rdf4j/http/client/QueueCursor.java/#L27-L29;1;"	public QueueCursor(int capacity) {
		this(capacity, false);
	}"
7457;4;8861277;long method;major;2019-05-28 20:54:24.199361;function;org.apache.airavata.registry.core.app.catalog.resources.ComputeHostPreferenceResource#isExists Object;git@github.com:apache/airavata.git;391843a00eefa7b6213e845f2f044b4e042894d5;/modules/registry/registry-core/src/main/java/org/apache/airavata/registry/core/app/catalog/resources/ComputeHostPreferenceResource.java;522;556;https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/registry/registry-core/src/main/java/org/apache/airavata/registry/core/app/catalog/resources/ComputeHostPreferenceResource.java/#L522-L556;1;"    @Override
    public boolean isExists(Object identifier) throws AppCatalogException {
        HashMap<String, String> ids;
        if (identifier instanceof Map) {
            ids = (HashMap) identifier;
        } else {
            logger.error(""Identifier should be a map with the field name and it's value"");
            throw new AppCatalogException(""Identifier should be a map with the field name and it's value"");
        }

        EntityManager em = null;
        try {
            em = AppCatalogJPAUtils.getEntityManager();
            ComputeResourcePreference existingPreference = em.find(ComputeResourcePreference.class,
                    new ComputeResourcePreferencePK(ids.get(ComputeResourcePreferenceConstants.GATEWAY_ID),
                            ids.get(ComputeResourcePreferenceConstants.RESOURCE_ID)));
            if (em.isOpen()) {
                if (em.getTransaction().isActive()){
                    em.getTransaction().rollback();
                }
                em.close();
            }
            return existingPreference != null;
        }catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new AppCatalogException(e);
        } finally {
            if (em != null && em.isOpen()) {
                if (em.getTransaction().isActive()) {
                    em.getTransaction().rollback();
                }
                em.close();
            }
        }
    }"
12411;3;5186444;blob;major;2019-08-06 16:28:54.226243;class;org.apache.metron.elasticsearch.client.ElasticsearchClientFactory;git@github.com:apache/metron.git;17b31b48f59627a9e768a5cbe0be7ac55b5b04f8;/metron-platform/metron-elasticsearch/src/main/java/org/apache/metron/elasticsearch/client/ElasticsearchClientFactory.java;57;189;https://github.com/apache/metron/blob/17b31b48f59627a9e768a5cbe0be7ac55b5b04f8/metron-platform/metron-elasticsearch/src/main/java/org/apache/metron/elasticsearch/client/ElasticsearchClientFactory.java/#L57-L189;1;"public class ElasticsearchClientFactory {

  private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
  private static final String ES_SETTINGS_KEY = ""es.client.settings""; // es config key in global config

  /**
   * Creates an Elasticsearch client from settings provided via the global config.
   *
   * @return new client
   */
  public static ElasticsearchClient create(Map<String, Object> globalConfig) {
    ElasticsearchClientConfig esClientConfig = new ElasticsearchClientConfig(
        getEsSettings(globalConfig));
    HttpHost[] httpHosts = getHttpHosts(globalConfig, esClientConfig.getConnectionScheme());
    RestClientBuilder builder = RestClient.builder(httpHosts);

    builder.setRequestConfigCallback(reqConfigBuilder -> {
      // Modifies request config builder with connection and socket timeouts.
      // https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_timeouts.html
      reqConfigBuilder.setConnectTimeout(esClientConfig.getConnectTimeoutMillis());
      reqConfigBuilder.setSocketTimeout(esClientConfig.getSocketTimeoutMillis());
      return reqConfigBuilder;
    });
    builder.setMaxRetryTimeoutMillis(esClientConfig.getMaxRetryTimeoutMillis());

    builder.setHttpClientConfigCallback(clientBuilder -> {
      clientBuilder.setDefaultIOReactorConfig(getIOReactorConfig(esClientConfig));
      clientBuilder.setDefaultCredentialsProvider(getCredentialsProvider(esClientConfig));
      clientBuilder.setSSLContext(getSSLContext(esClientConfig));
      return clientBuilder;
    });

    RestClient lowLevelClient = builder.build();
    RestHighLevelClient client = new RestHighLevelClient(lowLevelClient);
    return new ElasticsearchClient(lowLevelClient, client);
  }

  private static Map<String, Object> getEsSettings(Map<String, Object> globalConfig) {
    return (Map<String, Object>) globalConfig.getOrDefault(ES_SETTINGS_KEY, new HashMap<>());
  }

  private static HttpHost[] getHttpHosts(Map<String, Object> globalConfiguration, String scheme) {
    List<HostnamePort> hps = ElasticsearchUtils.getIps(globalConfiguration);
    HttpHost[] httpHosts = new HttpHost[hps.size()];
    int i = 0;
    for (HostnamePort hp : hps) {
      httpHosts[i++] = new HttpHost(hp.hostname, hp.port, scheme);
    }
    return httpHosts;
  }

  /**
   * Creates config with setting for num connection threads. Default is ES client default,
   * which is 1 to num processors per the documentation.
   * https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_number_of_threads.html
   */
  private static IOReactorConfig getIOReactorConfig(ElasticsearchClientConfig esClientConfig) {
    if (esClientConfig.getNumClientConnectionThreads().isPresent()) {
      Integer numThreads = esClientConfig.getNumClientConnectionThreads().get();
      LOG.info(""Setting number of client connection threads: {}"", numThreads);
      return IOReactorConfig.custom().setIoThreadCount(numThreads).build();
    } else {
      return IOReactorConfig.DEFAULT;
    }
  }

  private static CredentialsProvider getCredentialsProvider(
      ElasticsearchClientConfig esClientConfig) {
    Optional<Entry<String, String>> credentials = esClientConfig.getCredentials();
    if (credentials.isPresent()) {
      LOG.info(
          ""Found auth credentials - setting up user/pass authenticated client connection for ES."");
      final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
      UsernamePasswordCredentials upcredentials = new UsernamePasswordCredentials(
          credentials.get().getKey(), credentials.get().getValue());
      credentialsProvider.setCredentials(AuthScope.ANY, upcredentials);
      return credentialsProvider;
    } else {
      LOG.info(
          ""Elasticsearch client credentials not provided. Defaulting to non-authenticated client connection."");
      return null;
    }
  }

  /**
   * <p>Setup connection encryption details (SSL) if applicable.
   * If ssl.enabled=true, sets up SSL connection. If enabled, keystore.path is required. User can
   * also optionally set keystore.password and keystore.type.
   * https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_encrypted_communication.html
   * <p>
   * <p>Other guidance on the HTTP Component library and configuring SSL connections.
   * http://www.robinhowlett.com/blog/2016/01/05/everything-you-ever-wanted-to-know-about-ssl-but-were-afraid-to-ask.
   * <p>
   * <p>JSSE docs - https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html
   * <p>
   * <p>Additional guidance for configuring Elasticsearch for SSL can be found here - https://www.elastic.co/guide/en/x-pack/5.6/ssl-tls.html
   */
  private static SSLContext getSSLContext(ElasticsearchClientConfig esClientConfig) {
    if (esClientConfig.isSSLEnabled()) {
      LOG.info(""Configuring client for SSL connection."");
      if (!esClientConfig.getKeyStorePath().isPresent()) {
        throw new IllegalStateException(""KeyStore path must be provided for SSL connection."");
      }
      Optional<String> optKeyStorePass = esClientConfig.getKeyStorePassword();
      char[] keyStorePass = optKeyStorePass.map(String::toCharArray).orElse(null);
      KeyStore trustStore = getStore(esClientConfig.getKeyStoreType(),
          esClientConfig.getKeyStorePath().get(), keyStorePass);
      try {
        SSLContextBuilder sslBuilder = SSLContexts.custom().loadTrustMaterial(trustStore, null);
        return sslBuilder.build();
      } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
        throw new IllegalStateException(""Unable to load truststore."", e);
      }
    }
    return null;
  }

  private static KeyStore getStore(String type, Path path, char[] pass) {
    KeyStore store;
    try {
      store = KeyStore.getInstance(type);
    } catch (KeyStoreException e) {
      throw new IllegalStateException(""Unable to get keystore type '"" + type + ""'"", e);
    }
    try (InputStream is = Files.newInputStream(path)) {
      store.load(is, pass);
    } catch (IOException | NoSuchAlgorithmException | CertificateException e) {
      throw new IllegalStateException(""Unable to load keystore from path '"" + path + ""'"", e);
    }
    return store;
  }

}"
1643;10;7880048;blob;none;2019-03-29 14:08:05.510958;class;com.facebook.buck.log.thrift.rulekeys.BuildTarget.BuildTargetTupleSchemeFactory;git@github.com:facebook/buck.git;1bc8d383ea5cb153ca9bf4f2807e6be498648523;/src-gen/com/facebook/buck/log/thrift/rulekeys/BuildTarget.java;336;340;https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/src-gen/com/facebook/buck/log/thrift/rulekeys/BuildTarget.java/#L336-L340;1;"  private static class BuildTargetTupleSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
    public BuildTargetTupleScheme getScheme() {
      return new BuildTargetTupleScheme();
    }
  }"
11305;3;8285514;blob;major;2019-08-04 21:47:41.922112;class;org.apache.james.rrt.lib.AbstractRecipientRewriteTable;git@github.com:apache/james-project.git;fa24a096a5853459c3769a34ccc68feb91626bfa;/server/data/data-library/src/main/java/org/apache/james/rrt/lib/AbstractRecipientRewriteTable.java;47;351;https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/server/data/data-library/src/main/java/org/apache/james/rrt/lib/AbstractRecipientRewriteTable.java/#L47-L351;1;"public abstract class AbstractRecipientRewriteTable implements RecipientRewriteTable, Configurable {
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRecipientRewriteTable.class);

    // The maximum mappings which will process before throwing exception
    private int mappingLimit = 10;

    private boolean recursive = true;

    private DomainList domainList;

    @Inject
    public void setDomainList(DomainList domainList) {
        this.domainList = domainList;
    }

    @Override
    public void configure(HierarchicalConfiguration config) throws ConfigurationException {
        setRecursiveMapping(config.getBoolean(""recursiveMapping"", true));
        try {
            setMappingLimit(config.getInt(""mappingLimit"", 10));
        } catch (IllegalArgumentException e) {
            throw new ConfigurationException(e.getMessage());
        }
        doConfigure(config);
    }

    /**
     * Override to handle config
     */
    protected void doConfigure(HierarchicalConfiguration conf) throws ConfigurationException {
    }

    public void setRecursiveMapping(boolean recursive) {
        this.recursive = recursive;
    }

    /**
     * Set the mappingLimit
     * 
     * @param mappingLimit
     *            the mappingLimit
     * @throws IllegalArgumentException
     *             get thrown if mappingLimit smaller then 1 is used
     */
    public void setMappingLimit(int mappingLimit) throws IllegalArgumentException {
        if (mappingLimit < 1) {
            throw new IllegalArgumentException(""The minimum mappingLimit is 1"");
        }
        this.mappingLimit = mappingLimit;
    }

    @Override
    public Mappings getResolvedMappings(String user, Domain domain) throws ErrorMappingException, RecipientRewriteTableException {
        return getMappings(User.fromLocalPartWithDomain(user, domain), mappingLimit);
    }

    private Mappings getMappings(User user, int mappingLimit) throws ErrorMappingException, RecipientRewriteTableException {

        // We have to much mappings throw ErrorMappingException to avoid
        // infinity loop
        if (mappingLimit == 0) {
            throw new TooManyMappingException(""554 Too many mappings to process"");
        }

        Mappings targetMappings = mapAddress(user.getLocalPart(), user.getDomainPart().get());


        try {
            return MappingsImpl.fromMappings(
                targetMappings.asStream()
                    .flatMap(Throwing.function((Mapping target) -> convertAndRecurseMapping(user, target, mappingLimit)).sneakyThrow()));
        } catch (SkipMappingProcessingException e) {
            return MappingsImpl.empty();
        }
    }

    private Stream<Mapping> convertAndRecurseMapping(User originalUser, Mapping associatedMapping, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException, SkipMappingProcessingException, AddressException {

        Function<User, Stream<Mapping>> convertAndRecurseMapping =
            Throwing
                .function((User rewrittenUser) -> convertAndRecurseMapping(associatedMapping, originalUser, rewrittenUser, remainingLoops))
                .sneakyThrow();

        return associatedMapping.rewriteUser(originalUser)
            .map(rewrittenUser -> rewrittenUser.withDefaultDomainFromUser(originalUser))
            .map(convertAndRecurseMapping)
            .orElse(Stream.empty());
    }

    private Stream<Mapping> convertAndRecurseMapping(Mapping mapping, User originalUser, User rewrittenUser, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException {
        LOGGER.debug(""Valid virtual user mapping {} to {}"", originalUser.asString(), rewrittenUser.asString());

        Stream<Mapping> nonRecursiveResult = Stream.of(toMapping(rewrittenUser, mapping.getType()));
        if (!recursive) {
            return nonRecursiveResult;
        }

        // Check if the returned mapping is the same as the input. If so we need to handle identity to avoid loops.
        if (originalUser.equals(rewrittenUser)) {
            return mapping.handleIdentity(nonRecursiveResult);
        } else {
            return recurseMapping(nonRecursiveResult, rewrittenUser, remainingLoops);
        }
    }

    private Stream<Mapping> recurseMapping(Stream<Mapping> nonRecursiveResult, User targetUser, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException {
        Mappings childMappings = getMappings(targetUser, remainingLoops - 1);

        if (childMappings.isEmpty()) {
            return nonRecursiveResult;
        } else {
            return childMappings.asStream();
        }
    }

    private Mapping toMapping(User rewrittenUser, Type type) {
        switch (type) {
            case Forward:
            case Group:
            case Alias:
                return Mapping.of(type, rewrittenUser.asString());
            case Regex:
            case Domain:
            case Error:
            case Address:
                return Mapping.address(rewrittenUser.asString());
        }
        throw new IllegalArgumentException(""unhandled enum type"");
    }

    @Override
    public void addRegexMapping(MappingSource source, String regex) throws RecipientRewriteTableException {
        try {
            Pattern.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new RecipientRewriteTableException(""Invalid regex: "" + regex, e);
        }

        Mapping mapping = Mapping.regex(regex);
        checkDuplicateMapping(source, mapping);
        LOGGER.info(""Add regex mapping => {} for source {}"", regex, source.asString());
        addMapping(source, mapping);
    }

    @Override
    public void removeRegexMapping(MappingSource source, String regex) throws RecipientRewriteTableException {
        LOGGER.info(""Remove regex mapping => {} for source: {}"", regex, source.asString());
        removeMapping(source, Mapping.regex(regex));
    }

    @Override
    public void addAddressMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.address(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        checkHasValidAddress(mapping);
        checkDuplicateMapping(source, mapping);

        LOGGER.info(""Add address mapping => {} for source: {}"", mapping.asString(), source.asString());
        addMapping(source, mapping);
    }

    private Domain defaultDomain() throws RecipientRewriteTableException {
        try {
            return domainList.getDefaultDomain();
        } catch (DomainListException e) {
            throw new RecipientRewriteTableException(""Unable to retrieve default domain"", e);
        }
    }

    private void checkHasValidAddress(Mapping mapping) throws RecipientRewriteTableException {
        if (!mapping.asMailAddress().isPresent()) {
            throw new RecipientRewriteTableException(""Invalid emailAddress: "" + mapping.asString());
        }
    }

    @Override
    public void removeAddressMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.address(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        LOGGER.info(""Remove address mapping => {} for source: {}"", mapping.asString(), source.asString());
        removeMapping(source, mapping);
    }

    @Override
    public void addErrorMapping(MappingSource source, String error) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.error(error);

        checkDuplicateMapping(source, mapping);
        LOGGER.info(""Add error mapping => {} for source: {}"", error, source.asString());
        addMapping(source, mapping);

    }

    @Override
    public void removeErrorMapping(MappingSource source, String error) throws RecipientRewriteTableException {
        LOGGER.info(""Remove error mapping => {} for source: {}"", error, source.asString());
        removeMapping(source, Mapping.error(error));
    }

    @Override
    public void addAliasDomainMapping(MappingSource source, Domain realDomain) throws RecipientRewriteTableException {
        LOGGER.info(""Add domain mapping: {} => {}"", source.asDomain().map(Domain::asString).orElse(""null""), realDomain);
        addMapping(source, Mapping.domain(realDomain));
    }

    @Override
    public void removeAliasDomainMapping(MappingSource source, Domain realDomain) throws RecipientRewriteTableException {
        LOGGER.info(""Remove domain mapping: {} => {}"", source.asDomain().map(Domain::asString).orElse(""null""), realDomain);
        removeMapping(source, Mapping.domain(realDomain));
    }

    @Override
    public void addForwardMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.forward(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        checkHasValidAddress(mapping);
        checkDuplicateMapping(source, mapping);

        LOGGER.info(""Add forward mapping => {} for source: {}"", mapping.asString(), source.asString());
        addMapping(source, mapping);
    }

    @Override
    public void removeForwardMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.forward(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        LOGGER.info(""Remove forward mapping => {} for source: {}"", mapping.asString(), source.asString());
        removeMapping(source, mapping);
    }

    @Override
    public void addGroupMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.group(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        checkHasValidAddress(mapping);
        checkDuplicateMapping(source, mapping);

        LOGGER.info(""Add group mapping => {} for source: {}"", mapping.asString(), source.asString());
        addMapping(source, mapping);
    }

    @Override
    public void removeGroupMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.group(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        LOGGER.info(""Remove group mapping => {} for source: {}"", mapping.asString(), source.asString());
        removeMapping(source, mapping);
    }

    @Override
    public void addAliasMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.alias(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        checkHasValidAddress(mapping);
        checkDuplicateMapping(source, mapping);
        checkNotSameSourceAndDestination(source, address);

        LOGGER.info(""Add alias source => {} for destination mapping: {}"", source.asString(), mapping.asString());
        addMapping(source, mapping);
    }

    @Override
    public void removeAliasMapping(MappingSource source, String address) throws RecipientRewriteTableException {
        Mapping mapping = Mapping.alias(address)
            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);

        LOGGER.info(""Remove alias source => {} for destination mapping: {}"", source.asString(), mapping.asString());
        removeMapping(source, mapping);
    }

    /**
     * Return a Map which holds all Mappings
     * 
     * @return Map
     */
    public abstract Map<MappingSource, Mappings> getAllMappings() throws RecipientRewriteTableException;

    /**
     * This method must return stored Mappings for the given user.
     * It must never return null but throw RecipientRewriteTableException on errors and return an empty Mappings
     * object if no mapping is found.
     */
    protected abstract Mappings mapAddress(String user, Domain domain) throws RecipientRewriteTableException;

    private void checkDuplicateMapping(MappingSource source, Mapping mapping) throws RecipientRewriteTableException {
        Mappings mappings = getStoredMappings(source);
        if (mappings.contains(mapping)) {
            throw new MappingAlreadyExistsException(""Mapping "" + mapping.asString() + "" for "" + source.asString() + "" already exist!"");
        }
    }

    private void checkNotSameSourceAndDestination(MappingSource source, String address) throws RecipientRewriteTableException {
        if (source.asMailAddress().map(mailAddress -> mailAddress.asString().equals(address)).orElse(false)) {
            throw new SameSourceAndDestinationException(""Source and destination can't be the same!"");
        }
    }

}"
3747;20;3993481;long method;none;2019-04-05 13:22:58.181118;function;org.apache.batik.ext.awt.image.rendered.TileCache.setSize int;git@github.com:apache/batik.git;8b9b758641a11c43c4e9493386268fa0dc5c7efb;/batik-awt-util/src/main/java/org/apache/batik/ext/awt/image/rendered/TileCache.java;30;30;https://github.com/apache/batik/blob/8b9b758641a11c43c4e9493386268fa0dc5c7efb/batik-awt-util/src/main/java/org/apache/batik/ext/awt/image/rendered/TileCache.java/#L30-L30;1;"        public static void setSize(int sz) { cache.setSize(sz); }"
4523;20;8029682;long method;major;2019-04-12 13:04:14.507383;function;org.eclipse.xtext.xtext.ecoreInference.Xtext2EcoreTransformer#deriveTypeHierarchyFromOverridden ParserRule|Grammar;git@github.com:eclipse/xtext-core.git;e04964e4c2a3e0338c0079bd8333688835e77c31;/org.eclipse.xtext/src/org/eclipse/xtext/xtext/ecoreInference/Xtext2EcoreTransformer.java;720;764;https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext/src/org/eclipse/xtext/xtext/ecoreInference/Xtext2EcoreTransformer.java/#L720-L764;1;"	private boolean deriveTypeHierarchyFromOverridden(ParserRule rule, Grammar grammar) throws TransformationException {
		AbstractRule parentRule = GrammarUtil.findRuleForName(grammar, rule.getName());
		if (parentRule != null) {
			if (parentRule != rule && parentRule instanceof ParserRule) {
				ParserRule casted = (ParserRule) parentRule;
				if (casted.isFragment() != rule.isFragment()) {
					if (rule.isFragment()) {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""A fragment rule cannot override a production rule."", rule);
					} else {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""Only fragment rule can override other fragment rules."", rule);
					}
				}
				if (casted.isWildcard() != rule.isWildcard()) {
					if (rule.isWildcard()) {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""A wildcard fragment rule cannot override a typed fragment rule."", rule);
					} else {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""Only wildcard fragment rules can override other wildcard fragments."", rule);
					}
				}
				if (rule.isFragment() && !rule.isWildcard() && parentRule.getType() != null) {
					if (rule.getType().getClassifier() != parentRule.getType().getClassifier()) {
						throw new TransformationException(TransformationErrorCode.InvalidFragmentOverride,
								""Overriding fragment rules cannot redeclare their type."", rule.getType());
					}
				}
				checkParameterLists(rule, casted);
			}
			if (parentRule.getType() != null && parentRule != rule) {			
				if (parentRule.getType().getClassifier() instanceof EDataType)
					throw new TransformationException(TransformationErrorCode.InvalidSupertype,
							""Cannot inherit from datatype rule and return another type."", rule.getType());
				EClassifierInfo parentTypeInfo = eClassifierInfos.getInfoOrNull(parentRule.getType());
				if (parentTypeInfo == null)
					throw new TransformationException(TransformationErrorCode.InvalidSupertype,
							""Cannot determine return type of overridden rule."", rule.getType());
				addSuperType(rule, rule.getType(), parentTypeInfo);
				return true;
			}
		}
		return false;
	}"
1811;5;8212971;blob;none;2019-03-29 14:21:44.305504;class;org.springframework.bugs.autowiring.CandidateImpl;git@github.com:spring-projects/spring-framework-issues.git;ada8e40099454d41f4b83eb858462cc99ae29734;/SPR-7915/src/main/java/org/springframework/bugs/autowiring/CandidateImpl.java;5;8;https://github.com/spring-projects/spring-framework-issues/blob/ada8e40099454d41f4b83eb858462cc99ae29734/SPR-7915/src/main/java/org/springframework/bugs/autowiring/CandidateImpl.java/#L5-L8;0;"@SuppressWarnings(""rawtypes"")
public class CandidateImpl extends LinkedHashMap implements Candidate {
    private static final long serialVersionUID = 2617438257089193692L;
}"
3058;20;7017732;data class;none;2019-04-05 12:31:18.588667;class;com.android.volley.TimeoutError;git@github.com:google/volley.git;95a6796c40f570a723a73d9360dddbd0994ed1d4;/src/main/java/com/android/volley/TimeoutError.java;20;21;https://github.com/google/volley/blob/95a6796c40f570a723a73d9360dddbd0994ed1d4/src/main/java/com/android/volley/TimeoutError.java/#L20-L21;1;"@SuppressWarnings(""serial"")
public class TimeoutError extends VolleyError {}"
1222;5;7272514;feature envy;none;2019-03-29 13:38:06.038826;function;org.graalvm.visualvm.lib.profiler.heapwalk.OverviewController#showInThreads Instance;git@github.com:oracle/visualvm.git;d9b10575b53d535e10c6e8c41831ebe38483c65b;/visualvm/libs.profiler/profiler.heapwalker/src/org/graalvm/visualvm/lib/profiler/heapwalk/OverviewController.java;155;157;https://github.com/oracle/visualvm/blob/d9b10575b53d535e10c6e8c41831ebe38483c65b/visualvm/libs.profiler/profiler.heapwalker/src/org/graalvm/visualvm/lib/profiler/heapwalk/OverviewController.java/#L155-L157;1;"    void showInThreads(Instance instance) {
        ((OverviewControllerUI) getPanel()).showInThreads(instance);
    }"
13069;20;7468700;blob;none;2019-08-22 09:44:11.967479;class;example.repo.Customer583Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/repo/Customer583Repository.java;9;12;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer583Repository.java/#L9-L12;0;"public interface Customer583Repository extends CrudRepository<Customer583, Long> {

	List<Customer583> findByLastName(String lastName);
}"
1028;17;6985429;long method;none;2019-03-29 13:27:00.497561;function;com.google.j2cl.generator.ClosureTypesGenerator.ClosureType#toNonNullable;git@github.com:google/j2cl.git;f233ebf547cce390cf87ce346ed82e0512f4fbe1;/transpiler/java/com/google/j2cl/generator/ClosureTypesGenerator.java;345;347;https://github.com/google/j2cl/blob/f233ebf547cce390cf87ce346ed82e0512f4fbe1/transpiler/java/com/google/j2cl/generator/ClosureTypesGenerator.java/#L345-L347;1;"    ClosureType toNonNullable() {
      return isNullable() ? new ClosureBangDecoratedType(this) : this;
    }"
10805;4;8334291;blob;major;2019-07-26 20:29:42.368065;class;org.aspectj.apache.bcel.classfile.AttributeUtils;git@github.com:eclipse/org.aspectj.git;370f291c359cd159c5f3f0abd6e9e53e81234a07;/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/AttributeUtils.java;9;99;https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/AttributeUtils.java/#L9-L99;1;"public class AttributeUtils {

	public static Attribute[] readAttributes(DataInputStream dataInputstream, ConstantPool cpool) {
		try {
			int length = dataInputstream.readUnsignedShort();
			if (length == 0) {
				return Attribute.NoAttributes;
			}
			Attribute[] attrs = new Attribute[length];
			for (int i = 0; i < length; i++) {
				attrs[i] = Attribute.readAttribute(dataInputstream, cpool);
			}
			return attrs;
		} catch (IOException e) {
			throw new ClassFormatException(""IOException whilst reading set of attributes: "" + e.toString());
		}
	}

	/** Write (serialize) a set of attributes into a specified output stream */
	public static void writeAttributes(Attribute[] attributes, DataOutputStream file) throws IOException {
		if (attributes == null) {
			file.writeShort(0);
		} else {
			file.writeShort(attributes.length);
			for (int i = 0; i < attributes.length; i++) {
				attributes[i].dump(file);
			}
		}
	}

	public static Signature getSignatureAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SIGNATURE) {
				return (Signature) attributes[i];
			}
		}
		return null;
	}

	public static Code getCodeAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_CODE) {
				return (Code) attributes[i];
			}
		}
		return null;
	}

	public static ExceptionTable getExceptionTableAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_EXCEPTIONS) {
				return (ExceptionTable) attributes[i];
			}
		}
		return null;
	}

	public static ConstantValue getConstantValueAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].getTag() == Constants.ATTR_CONSTANT_VALUE) {
				return (ConstantValue) attributes[i];
			}
		}
		return null;
	}

	public static void accept(Attribute[] attributes, ClassVisitor visitor) {
		for (int i = 0; i < attributes.length; i++) {
			attributes[i].accept(visitor);
		}
	}

	public static boolean hasSyntheticAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SYNTHETIC) {
				return true;
			}
		}
		return false;
	}

	public static SourceFile getSourceFileAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SOURCE_FILE) {
				return (SourceFile) attributes[i];
			}
		}
		return null;
	}

}"
4428;16;7291517;long method;critical;2019-04-12 12:29:40.326623;function;org.grails.ide.eclipse.editor.actions.UrlMappingHyperlinkDetector#findLinkComponentsInClosure ClosureExpression|int;git@github.com:spring-projects/grails-ide.git;cb5162c5a7fc60a2847c39d2750003ada7e80ff7;/org.grails.ide.eclipse.editor.groovy/src/org/grails/ide/eclipse/editor/actions/UrlMappingHyperlinkDetector.java;319;360;https://github.com/spring-projects/grails-ide/blob/cb5162c5a7fc60a2847c39d2750003ada7e80ff7/org.grails.ide.eclipse.editor.groovy/src/org/grails/ide/eclipse/editor/actions/UrlMappingHyperlinkDetector.java/#L319-L360;0,5;"    private NameRegion[] findLinkComponentsInClosure(ClosureExpression firstArg,
            int offset) {
        if (! (firstArg.getCode() instanceof BlockStatement)) {
            return null;
        }
        
        BlockStatement code = (BlockStatement) firstArg.getCode();
        if (code.getStatements() == null) {
            return null;
        }
        NameRegion controllerName = null;
        NameRegion actionName = null;
        NameRegion viewName = null;

        for (Statement state : code.getStatements()) {
            if (state instanceof ExpressionStatement) {
                if (((ExpressionStatement) state).getExpression() instanceof BinaryExpression) {
                    BinaryExpression bexpr = (BinaryExpression) ((ExpressionStatement) state).getExpression();
                    Expression left = bexpr.getLeftExpression();
                    if (bexpr.getOperation().getText().equals(""="") && left instanceof VariableExpression) {
                        Expression right = bexpr.getRightExpression();
                        Region region;
                        if (right.getStart() <= offset && right.getEnd() >= offset) {
                            region = new Region(right.getStart(), right.getLength());
                        } else {
                            region = null;
                        }

                        String name = left.getText();
                        if (name.equals(""controller"")) {
                            controllerName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""action"")) {
                            actionName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""view"")) {
                            viewName = new NameRegion(right.getText(), region);
                        }
                    }
                }
            }
        }
        return new NameRegion[] { controllerName, actionName, viewName };
    }"
14422;4;5186444;blob;major;2019-09-08 21:36:42.873576;class;org.apache.metron.elasticsearch.client.ElasticsearchClientFactory;git@github.com:apache/metron.git;17b31b48f59627a9e768a5cbe0be7ac55b5b04f8;/metron-platform/metron-elasticsearch/src/main/java/org/apache/metron/elasticsearch/client/ElasticsearchClientFactory.java;57;189;https://github.com/apache/metron/blob/17b31b48f59627a9e768a5cbe0be7ac55b5b04f8/metron-platform/metron-elasticsearch/src/main/java/org/apache/metron/elasticsearch/client/ElasticsearchClientFactory.java/#L57-L189;1;"public class ElasticsearchClientFactory {

  private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
  private static final String ES_SETTINGS_KEY = ""es.client.settings""; // es config key in global config

  /**
   * Creates an Elasticsearch client from settings provided via the global config.
   *
   * @return new client
   */
  public static ElasticsearchClient create(Map<String, Object> globalConfig) {
    ElasticsearchClientConfig esClientConfig = new ElasticsearchClientConfig(
        getEsSettings(globalConfig));
    HttpHost[] httpHosts = getHttpHosts(globalConfig, esClientConfig.getConnectionScheme());
    RestClientBuilder builder = RestClient.builder(httpHosts);

    builder.setRequestConfigCallback(reqConfigBuilder -> {
      // Modifies request config builder with connection and socket timeouts.
      // https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_timeouts.html
      reqConfigBuilder.setConnectTimeout(esClientConfig.getConnectTimeoutMillis());
      reqConfigBuilder.setSocketTimeout(esClientConfig.getSocketTimeoutMillis());
      return reqConfigBuilder;
    });
    builder.setMaxRetryTimeoutMillis(esClientConfig.getMaxRetryTimeoutMillis());

    builder.setHttpClientConfigCallback(clientBuilder -> {
      clientBuilder.setDefaultIOReactorConfig(getIOReactorConfig(esClientConfig));
      clientBuilder.setDefaultCredentialsProvider(getCredentialsProvider(esClientConfig));
      clientBuilder.setSSLContext(getSSLContext(esClientConfig));
      return clientBuilder;
    });

    RestClient lowLevelClient = builder.build();
    RestHighLevelClient client = new RestHighLevelClient(lowLevelClient);
    return new ElasticsearchClient(lowLevelClient, client);
  }

  private static Map<String, Object> getEsSettings(Map<String, Object> globalConfig) {
    return (Map<String, Object>) globalConfig.getOrDefault(ES_SETTINGS_KEY, new HashMap<>());
  }

  private static HttpHost[] getHttpHosts(Map<String, Object> globalConfiguration, String scheme) {
    List<HostnamePort> hps = ElasticsearchUtils.getIps(globalConfiguration);
    HttpHost[] httpHosts = new HttpHost[hps.size()];
    int i = 0;
    for (HostnamePort hp : hps) {
      httpHosts[i++] = new HttpHost(hp.hostname, hp.port, scheme);
    }
    return httpHosts;
  }

  /**
   * Creates config with setting for num connection threads. Default is ES client default,
   * which is 1 to num processors per the documentation.
   * https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_number_of_threads.html
   */
  private static IOReactorConfig getIOReactorConfig(ElasticsearchClientConfig esClientConfig) {
    if (esClientConfig.getNumClientConnectionThreads().isPresent()) {
      Integer numThreads = esClientConfig.getNumClientConnectionThreads().get();
      LOG.info(""Setting number of client connection threads: {}"", numThreads);
      return IOReactorConfig.custom().setIoThreadCount(numThreads).build();
    } else {
      return IOReactorConfig.DEFAULT;
    }
  }

  private static CredentialsProvider getCredentialsProvider(
      ElasticsearchClientConfig esClientConfig) {
    Optional<Entry<String, String>> credentials = esClientConfig.getCredentials();
    if (credentials.isPresent()) {
      LOG.info(
          ""Found auth credentials - setting up user/pass authenticated client connection for ES."");
      final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
      UsernamePasswordCredentials upcredentials = new UsernamePasswordCredentials(
          credentials.get().getKey(), credentials.get().getValue());
      credentialsProvider.setCredentials(AuthScope.ANY, upcredentials);
      return credentialsProvider;
    } else {
      LOG.info(
          ""Elasticsearch client credentials not provided. Defaulting to non-authenticated client connection."");
      return null;
    }
  }

  /**
   * <p>Setup connection encryption details (SSL) if applicable.
   * If ssl.enabled=true, sets up SSL connection. If enabled, keystore.path is required. User can
   * also optionally set keystore.password and keystore.type.
   * https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_encrypted_communication.html
   * <p>
   * <p>Other guidance on the HTTP Component library and configuring SSL connections.
   * http://www.robinhowlett.com/blog/2016/01/05/everything-you-ever-wanted-to-know-about-ssl-but-were-afraid-to-ask.
   * <p>
   * <p>JSSE docs - https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html
   * <p>
   * <p>Additional guidance for configuring Elasticsearch for SSL can be found here - https://www.elastic.co/guide/en/x-pack/5.6/ssl-tls.html
   */
  private static SSLContext getSSLContext(ElasticsearchClientConfig esClientConfig) {
    if (esClientConfig.isSSLEnabled()) {
      LOG.info(""Configuring client for SSL connection."");
      if (!esClientConfig.getKeyStorePath().isPresent()) {
        throw new IllegalStateException(""KeyStore path must be provided for SSL connection."");
      }
      Optional<String> optKeyStorePass = esClientConfig.getKeyStorePassword();
      char[] keyStorePass = optKeyStorePass.map(String::toCharArray).orElse(null);
      KeyStore trustStore = getStore(esClientConfig.getKeyStoreType(),
          esClientConfig.getKeyStorePath().get(), keyStorePass);
      try {
        SSLContextBuilder sslBuilder = SSLContexts.custom().loadTrustMaterial(trustStore, null);
        return sslBuilder.build();
      } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
        throw new IllegalStateException(""Unable to load truststore."", e);
      }
    }
    return null;
  }

  private static KeyStore getStore(String type, Path path, char[] pass) {
    KeyStore store;
    try {
      store = KeyStore.getInstance(type);
    } catch (KeyStoreException e) {
      throw new IllegalStateException(""Unable to get keystore type '"" + type + ""'"", e);
    }
    try (InputStream is = Files.newInputStream(path)) {
      store.load(is, pass);
    } catch (IOException | NoSuchAlgorithmException | CertificateException e) {
      throw new IllegalStateException(""Unable to load keystore from path '"" + path + ""'"", e);
    }
    return store;
  }

}"
1955;16;3875268;feature envy;none;2019-03-29 18:02:55.571398;function;org.apache.accumulo.core.master.thrift.TableInfo.TableInfo;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/core/src/main/java/org/apache/accumulo/core/master/thrift/TableInfo.java;194;195;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/core/src/main/java/org/apache/accumulo/core/master/thrift/TableInfo.java/#L194-L195;1;"  public TableInfo() {
  }"
3826;1;8845696;blob;none;2019-04-05 13:27:05.376686;class;org.apache.airavata.api.Airavata.registerApplicationInterface_result.registerApplicationInterface_resultTupleSchemeFactory;git@github.com:apache/airavata.git;391843a00eefa7b6213e845f2f044b4e042894d5;/airavata-api/airavata-api-stubs/src/main/java/org/apache/airavata/api/Airavata.java;119697;119701;https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/airavata-api/airavata-api-stubs/src/main/java/org/apache/airavata/api/Airavata.java/#L119697-L119701;1;"    private static class registerApplicationInterface_resultTupleSchemeFactory implements SchemeFactory {
      public registerApplicationInterface_resultTupleScheme getScheme() {
        return new registerApplicationInterface_resultTupleScheme();
      }
    }"
6714;3;9484836;blob;major;2019-05-20 09:11:31.187615;class;org.apache.hadoop.hdfs.server.namenode.INodeReference.WithName;git@github.com:apache/hadoop.git;128dd91e10080bdcbcd7d555fa3c4105e55a6b51;/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeReference.java;466;619;https://github.com/apache/hadoop/blob/128dd91e10080bdcbcd7d555fa3c4105e55a6b51/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeReference.java/#L466-L619;1;"  public static class WithName extends INodeReference {

    private final byte[] name;

    /**
     * The id of the last snapshot in the src tree when this WithName node was 
     * generated. When calculating the quota usage of the referred node, only 
     * the files/dirs existing when this snapshot was taken will be counted for 
     * this WithName node and propagated along its ancestor path.
     */
    private final int lastSnapshotId;
    
    public WithName(INodeDirectory parent, WithCount referred, byte[] name,
        int lastSnapshotId) {
      super(parent, referred);
      this.name = name;
      this.lastSnapshotId = lastSnapshotId;
      referred.addReference(this);
    }

    @Override
    public final byte[] getLocalNameBytes() {
      return name;
    }

    @Override
    public final void setLocalName(byte[] name) {
      throw new UnsupportedOperationException(""Cannot set name: "" + getClass()
          + "" is immutable."");
    }
    
    public int getLastSnapshotId() {
      return lastSnapshotId;
    }
    
    @Override
    public final ContentSummaryComputationContext computeContentSummary(
        int snapshotId, ContentSummaryComputationContext summary) {
      final int s = snapshotId < lastSnapshotId ? snapshotId : lastSnapshotId;
      // only count storagespace for WithName
      final QuotaCounts q = computeQuotaUsage(
          summary.getBlockStoragePolicySuite(), getStoragePolicyID(), false, s);
      summary.getCounts().addContent(Content.DISKSPACE, q.getStorageSpace());
      summary.getCounts().addTypeSpaces(q.getTypeSpaces());
      return summary;
    }

    @Override
    public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,
        byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {
      // if this.lastSnapshotId < lastSnapshotId, the rename of the referred
      // node happened before the rename of its ancestor. This should be
      // impossible since for WithName node we only count its children at the
      // time of the rename.
      Preconditions.checkState(lastSnapshotId == Snapshot.CURRENT_STATE_ID
          || this.lastSnapshotId >= lastSnapshotId);
      final INode referred = this.getReferredINode().asReference()
          .getReferredINode();
      // We will continue the quota usage computation using the same snapshot id
      // as time line (if the given snapshot id is valid). Also, we cannot use 
      // cache for the referred node since its cached quota may have already 
      // been updated by changes in the current tree.
      int id = lastSnapshotId != Snapshot.CURRENT_STATE_ID ? 
          lastSnapshotId : this.lastSnapshotId;
      return referred.computeQuotaUsage(bsps, blockStoragePolicyId, false, id);
    }
    
    @Override
    public void cleanSubtree(ReclaimContext reclaimContext, final int snapshot,
        int prior) {
      // since WithName node resides in deleted list acting as a snapshot copy,
      // the parameter snapshot must be non-null
      Preconditions.checkArgument(snapshot != Snapshot.CURRENT_STATE_ID);
      // if prior is NO_SNAPSHOT_ID, we need to check snapshot belonging to the
      // previous WithName instance
      if (prior == Snapshot.NO_SNAPSHOT_ID) {
        prior = getPriorSnapshot(this);
      }
      
      if (prior != Snapshot.NO_SNAPSHOT_ID
          && Snapshot.ID_INTEGER_COMPARATOR.compare(snapshot, prior) <= 0) {
        return;
      }

      // record the old quota delta
      QuotaCounts old = reclaimContext.quotaDelta().getCountsCopy();
      getReferredINode().cleanSubtree(reclaimContext, snapshot, prior);
      INodeReference ref = getReferredINode().getParentReference();
      if (ref != null) {
        QuotaCounts current = reclaimContext.quotaDelta().getCountsCopy();
        current.subtract(old);
        // we need to update the quota usage along the parent path from ref
        reclaimContext.quotaDelta().addUpdatePath(ref, current);
      }
      
      if (snapshot < lastSnapshotId) {
        // for a WithName node, when we compute its quota usage, we only count
        // in all the nodes existing at the time of the corresponding rename op.
        // Thus if we are deleting a snapshot before/at the snapshot associated 
        // with lastSnapshotId, we do not need to update the quota upwards.
        reclaimContext.quotaDelta().setCounts(old);
      }
    }
    
    @Override
    public void destroyAndCollectBlocks(ReclaimContext reclaimContext) {
      int snapshot = getSelfSnapshot();
      reclaimContext.quotaDelta().add(computeQuotaUsage(reclaimContext.bsps));
      if (removeReference(this) <= 0) {
        getReferredINode().destroyAndCollectBlocks(reclaimContext.getCopy());
      } else {
        int prior = getPriorSnapshot(this);
        INode referred = getReferredINode().asReference().getReferredINode();

        if (snapshot != Snapshot.NO_SNAPSHOT_ID) {
          if (prior != Snapshot.NO_SNAPSHOT_ID && snapshot <= prior) {
            // the snapshot to be deleted has been deleted while traversing 
            // the src tree of the previous rename operation. This usually 
            // happens when rename's src and dst are under the same 
            // snapshottable directory. E.g., the following operation sequence:
            // 1. create snapshot s1 on /test
            // 2. rename /test/foo/bar to /test/foo2/bar
            // 3. create snapshot s2 on /test
            // 4. rename foo2 again
            // 5. delete snapshot s2
            return;
          }
          ReclaimContext newCtx = reclaimContext.getCopy();
          referred.cleanSubtree(newCtx, snapshot, prior);
          INodeReference ref = getReferredINode().getParentReference();
          if (ref != null) {
            // we need to update the quota usage along the parent path from ref
            reclaimContext.quotaDelta().addUpdatePath(ref,
                newCtx.quotaDelta().getCountsCopy());
          }
        }
      }
    }
    
    private int getSelfSnapshot() {
      INode referred = getReferredINode().asReference().getReferredINode();
      int snapshot = Snapshot.NO_SNAPSHOT_ID;
      if (referred.isFile() && referred.asFile().isWithSnapshot()) {
        snapshot = referred.asFile().getDiffs().getPrior(lastSnapshotId);
      } else if (referred.isDirectory()) {
        DirectoryWithSnapshotFeature sf = referred.asDirectory()
            .getDirectoryWithSnapshotFeature();
        if (sf != null) {
          snapshot = sf.getDiffs().getPrior(lastSnapshotId);
        }
      }
      return snapshot;
    }
  }"
3039;14;5473710;data class;major;2019-04-05 12:29:57.905725;class;org.apache.qpid.server.security.access.plugins.AclRule;git@github.com:apache/qpid-broker-j.git;4c4400b98a5a8493cfb9e5dbb21c97175f433a62;/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java;31;39;https://github.com/apache/qpid-broker-j/blob/4c4400b98a5a8493cfb9e5dbb21c97175f433a62/broker-plugins/access-control/src/main/java/org/apache/qpid/server/security/access/plugins/AclRule.java/#L31-L39;1;"@ManagedAttributeValueType
public interface AclRule extends ManagedAttributeValue
{
    String getIdentity();
    ObjectType getObjectType();
    LegacyOperation getOperation();
    Map<ObjectProperties.Property,String> getAttributes();
    RuleOutcome getOutcome();
}"
13768;1;3942097;long method;major;2019-08-30 12:25:40.246456;function;org.apache.aries.spifly.statictool.Main.weaveDir File|String|String|String;git@github.com:apache/aries.git;52293d20268de7c98833846ded2b70d6476773de;/spi-fly/spi-fly-static-tool/src/main/java/org/apache/aries/spifly/statictool/Main.java;173;223;https://github.com/apache/aries/blob/52293d20268de7c98833846ded2b70d6476773de/spi-fly/spi-fly-static-tool/src/main/java/org/apache/aries/spifly/statictool/Main.java/#L173-L223;1;"    private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {
        Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);

        URLClassLoader cl = new URLClassLoader(new URL [] {dir.toURI().toURL()}, Main.class.getClassLoader());
        String dirName = dir.getAbsolutePath();

        DirTree dt = new DirTree(dir);
        for (File f : dt.getFiles()) {
            if (!f.getName().endsWith("".class""))
                continue;

            String className = f.getAbsolutePath().substring(dirName.length());
            if (className.startsWith(File.separator))
                className = className.substring(1);
            className = className.substring(0, className.length() - "".class"".length());
            className = className.replace(File.separator, ""."");

            InputStream is = new FileInputStream(f);
            byte[] b;
            try {
                ClassReader cr = new ClassReader(is);
                ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);
                TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);
                cr.accept(cv, ClassReader.SKIP_FRAMES);
                if (cv.isWoven()) {
                    b = cw.toByteArray();
                } else {
                    // if not woven, store the original bytes
                    b = Streams.suck(new FileInputStream(f));
                }
            } finally {
                is.close();
            }

            OutputStream os = new FileOutputStream(f);
            try {
                os.write(b);
            } finally {
                os.close();
            }
        }

        if (bundleClassPath != null) {
            for (String entry : bundleClassPath.split("","")) {
                File jarFile = new File(dir, entry.trim());
                if (jarFile.isFile()) {
                    weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);
                }
            }
        }
    }"
10126;13;7777067;feature envy;major;2019-07-25 12:58:15.776743;function;org.apache.druid.segment.virtual.ExpressionSelectors.supplierFromDimensionSelector DimensionSelector;git@github.com:apache/incubator-druid.git;8ca7cb4886dcaeeaaea3a06aceb9e6d50eeecab5;/processing/src/main/java/org/apache/druid/segment/virtual/ExpressionSelectors.java;311;327;https://github.com/apache/incubator-druid/blob/8ca7cb4886dcaeeaaea3a06aceb9e6d50eeecab5/processing/src/main/java/org/apache/druid/segment/virtual/ExpressionSelectors.java/#L311-L327;1;"  @VisibleForTesting
  @Nonnull
  static Supplier<Object> supplierFromDimensionSelector(final DimensionSelector selector)
  {
    Preconditions.checkNotNull(selector, ""selector"");
    return () -> {
      final IndexedInts row = selector.getRow();

      if (row.size() == 1) {
        return selector.lookupName(row.get(0));
      } else {
        // Can't handle non-singly-valued rows in expressions.
        // Treat them as nulls until we think of something better to do.
        return null;
      }
    };
  }"
14009;15;7155743;data class;critical;2019-09-01 17:20:58.975024;class;com.microsoft.sqlserver.jdbc.Segment;git@github.com:Microsoft/mssql-jdbc.git;84484edf7944de56749fd2648d0af2ffa2459b7a;/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java;1932;1947;https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947;0;"class Segment {
    private byte segmentType;

    Segment(byte segmentType) {
        this.segmentType = segmentType;
    }

    /**
     * Returns the segmentType value.
     * 
     * @return byte segmentType value.
     */
    public byte getSegmentType() {
        return segmentType;
    }
}"
3634;4;7916535;long method;major;2019-04-05 13:14:52.896932;function;org.apache.xalan.xsltc.runtime.ObjectFactory.findProviderClass String|ClassLoader|boolean;git@github.com:apache/servicemix-bundles.git;5f2c7727f71c167997947ad4604f9b8200952af2;/xalan-2.7.2/src/main/java/org/apache/xalan/xsltc/runtime/ObjectFactory.java;477;529;https://github.com/apache/servicemix-bundles/blob/5f2c7727f71c167997947ad4604f9b8200952af2/xalan-2.7.2/src/main/java/org/apache/xalan/xsltc/runtime/ObjectFactory.java/#L477-L529;0;"    static Class findProviderClass(String className, ClassLoader cl,
                                           boolean doFallback)
        throws ClassNotFoundException, ConfigurationError
    {   
        //throw security exception if the calling thread is not allowed to access the
        //class. Restrict the access to the package classes as specified in java.security policy.
        SecurityManager security = System.getSecurityManager();
        try{
                if (security != null){
                    final int lastDot = className.lastIndexOf('.');
                    String packageName = className;
                    if (lastDot != -1) packageName = className.substring(0, lastDot);
                    security.checkPackageAccess(packageName);
                 }   
        }catch(SecurityException e){
            throw e;
        }
        
        Class providerClass;
        if (cl == null) {
            // XXX Use the bootstrap ClassLoader.  There is no way to
            // load a class using the bootstrap ClassLoader that works
            // in both JDK 1.1 and Java 2.  However, this should still
            // work b/c the following should be true:
            //
            // (cl == null) iff current ClassLoader == null
            //
            // Thus Class.forName(String) will use the current
            // ClassLoader which will be the bootstrap ClassLoader.
            providerClass = Class.forName(className);
        } else {
            try {
                providerClass = cl.loadClass(className);
            } catch (ClassNotFoundException x) {
                if (doFallback) {
                    // Fall back to current classloader
                    ClassLoader current = ObjectFactory.class.getClassLoader();
                    if (current == null) {
                        providerClass = Class.forName(className);
                    } else if (cl != current) {
                        cl = current;
                        providerClass = cl.loadClass(className);
                    } else {
                        throw x;
                    }
                } else {
                    throw x;
                }
            }
        }

        return providerClass;
    }"
15335;20;7916535;long method;major;2019-09-13 07:22:27.594324;function;org.apache.xalan.xsltc.runtime.ObjectFactory.findProviderClass String|ClassLoader|boolean;git@github.com:apache/servicemix-bundles.git;5f2c7727f71c167997947ad4604f9b8200952af2;/xalan-2.7.2/src/main/java/org/apache/xalan/xsltc/runtime/ObjectFactory.java;477;529;https://github.com/apache/servicemix-bundles/blob/5f2c7727f71c167997947ad4604f9b8200952af2/xalan-2.7.2/src/main/java/org/apache/xalan/xsltc/runtime/ObjectFactory.java/#L477-L529;0;"    static Class findProviderClass(String className, ClassLoader cl,
                                           boolean doFallback)
        throws ClassNotFoundException, ConfigurationError
    {   
        //throw security exception if the calling thread is not allowed to access the
        //class. Restrict the access to the package classes as specified in java.security policy.
        SecurityManager security = System.getSecurityManager();
        try{
                if (security != null){
                    final int lastDot = className.lastIndexOf('.');
                    String packageName = className;
                    if (lastDot != -1) packageName = className.substring(0, lastDot);
                    security.checkPackageAccess(packageName);
                 }   
        }catch(SecurityException e){
            throw e;
        }
        
        Class providerClass;
        if (cl == null) {
            // XXX Use the bootstrap ClassLoader.  There is no way to
            // load a class using the bootstrap ClassLoader that works
            // in both JDK 1.1 and Java 2.  However, this should still
            // work b/c the following should be true:
            //
            // (cl == null) iff current ClassLoader == null
            //
            // Thus Class.forName(String) will use the current
            // ClassLoader which will be the bootstrap ClassLoader.
            providerClass = Class.forName(className);
        } else {
            try {
                providerClass = cl.loadClass(className);
            } catch (ClassNotFoundException x) {
                if (doFallback) {
                    // Fall back to current classloader
                    ClassLoader current = ObjectFactory.class.getClassLoader();
                    if (current == null) {
                        providerClass = Class.forName(className);
                    } else if (cl != current) {
                        cl = current;
                        providerClass = cl.loadClass(className);
                    } else {
                        throw x;
                    }
                } else {
                    throw x;
                }
            }
        }

        return providerClass;
    }"
752;5;6328547;data class;none;2019-03-29 13:05:36.520744;class;org.eclipse.kapua.message.internal.device.lifecycle.KapuaAppsMessageImpl;git@github.com:eclipse/kapua.git;11e610c657f7e473b52882833e33a2261bd3d67d;/message/internal/src/main/java/org/eclipse/kapua/message/internal/device/lifecycle/KapuaAppsMessageImpl.java;22;25;https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/message/internal/src/main/java/org/eclipse/kapua/message/internal/device/lifecycle/KapuaAppsMessageImpl.java/#L22-L25;1;"public class KapuaAppsMessageImpl extends AbstractLifecycleMessageImpl<KapuaAppsChannel, KapuaAppsPayload> implements KapuaAppsMessage {

    private static final long serialVersionUID = 1L;
}"
2843;22;5232497;long method;major;2019-04-05 12:15:07.677127;function;org.apache.oodt.cas.crawl.ProductCrawler#crawl File;git@github.com:apache/oodt.git;9f2a500b9d061c31ccd71fc66c4d6e40f0c25acb;/crawler/src/main/java/org/apache/oodt/cas/crawl/ProductCrawler.java;79;124;https://github.com/apache/oodt/blob/9f2a500b9d061c31ccd71fc66c4d6e40f0c25acb/crawler/src/main/java/org/apache/oodt/cas/crawl/ProductCrawler.java/#L79-L124;1;"   public void crawl(File dirRoot) {
      LOG.info(String.format(""Start crawling dir: %s"", dirRoot));

      // Reset ingest status.a

      ingestStatus.clear();

      // Load actions.
      loadAndValidateActions();

      // Create Ingester.
      setupIngester();

      // Verify valid crawl directory.
      if (dirRoot == null || !dirRoot.exists()) {
         throw new IllegalArgumentException(""dir root is null or non existant!"");
      }

      // Start crawling.
      Stack<File> stack = new Stack<File>();
      stack.push(dirRoot.isDirectory() ? dirRoot : dirRoot.getParentFile());
      while (!stack.isEmpty()) {
         File dir = (File) stack.pop();
         LOG.log(Level.INFO, ""Crawling "" + dir);

         File[] productFiles;
         productFiles = isCrawlForDirs() ? dir.listFiles(DIR_FILTER) : dir.listFiles(FILE_FILTER);

         if(productFiles!=null) {
            for (File productFile : productFiles) {
               ingestStatus.add(handleFile(productFile));
            }
         }

         if (!isNoRecur()) {
            File[] subdirs = dir.listFiles(DIR_FILTER);
            if (subdirs != null) {
               for (File subdir : subdirs) {
                  stack.push(subdir);
               }
            }
         }
      }

      LOG.info(String.format(""Finished crawling dir: %s"", dirRoot));
   }"
5043;5;9260596;data class;major;2019-04-12 14:55:51.697685;class;com.sun.org.apache.xerces.internal.impl.xpath.regex.Op.ModifierOp;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xpath/regex/Op.java;204;218;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xpath/regex/Op.java/#L204-L218;1;"    static class ModifierOp extends ChildOp {
        final int v1;
        final int v2;
        ModifierOp(int type, int v1, int v2) {
            super(type);
            this.v1 = v1;
            this.v2 = v2;
        }
        int getData() {
            return this.v1;
        }
        int getData2() {
            return this.v2;
        }
    }"
4439;5;4189945;data class;critical;2019-04-12 12:33:38.413984;class;org.apache.cayenne.template.parser.ExpressionNode;git@github.com:apache/cayenne.git;5be5235ed1c02589b6300e9729cf3c308c0173e8;/cayenne-server/src/main/java/org/apache/cayenne/template/parser/ExpressionNode.java;27;39;https://github.com/apache/cayenne/blob/5be5235ed1c02589b6300e9729cf3c308c0173e8/cayenne-server/src/main/java/org/apache/cayenne/template/parser/ExpressionNode.java/#L27-L39;1;"public interface ExpressionNode {

    String evaluateAsString(Context context);

    Object evaluateAsObject(Context context);

    long evaluateAsLong(Context context);

    double evaluateAsDouble(Context context);

    boolean evaluateAsBoolean(Context context);

}"
7728;3;8618517;long method;major;2019-07-12 23:58:35.599463;function;org.apache.ignite.internal.processors.cache.transactions.TxLocksResponse#readFrom ByteBuffer|MessageReader;git@github.com:apache/ignite.git;7a7c407ea41477aae8508bfe871b4e9a67e1b277;/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/TxLocksResponse.java;272;317;https://github.com/apache/ignite/blob/7a7c407ea41477aae8508bfe871b4e9a67e1b277/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/TxLocksResponse.java/#L272-L317;1;"    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {
        reader.setBuffer(buf);

        if (!reader.beforeMessageRead())
            return false;

        if (!super.readFrom(buf, reader))
            return false;

        switch (reader.state()) {
            case 3:
                futId = reader.readLong(""futId"");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 4:
                locksArr = reader.readObjectArray(""locksArr"", MessageCollectionItemType.MSG, TxLockList.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 5:
                nearTxKeysArr = reader.readObjectArray(""nearTxKeysArr"", MessageCollectionItemType.MSG, IgniteTxKey.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 6:
                txKeysArr = reader.readObjectArray(""txKeysArr"", MessageCollectionItemType.MSG, IgniteTxKey.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

        }

        return reader.afterMessageRead(TxLocksResponse.class);
    }"
3063;14;5816939;feature envy;major;2019-04-05 12:31:47.333628;function;org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil.applyAll S|Traversal.Admin<S, E>;git@github.com:apache/tinkerpop.git;7d9df0f0acf08f9e675ca7b337fc5e0243c09b53;/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalUtil.java;99;103;https://github.com/apache/tinkerpop/blob/7d9df0f0acf08f9e675ca7b337fc5e0243c09b53/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalUtil.java/#L99-L103;1;"    public static final <S, E> Iterator<E> applyAll(final S start, final Traversal.Admin<S, E> traversal) {
        traversal.reset();
        traversal.addStart(traversal.getTraverserGenerator().generate(start, traversal.getStartStep(), 1l));
        return traversal; // flatMap
    }"
3894;17;5764315;blob;none;2019-04-05 13:53:33.694756;class;org.apache.syncope.core.persistence.api.entity.anyobject.ARelationship;git@github.com:apache/syncope.git;114c412afbfba24ffb4fbc804e5308a823a16a78;/core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/entity/anyobject/ARelationship.java;23;25;https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/entity/anyobject/ARelationship.java/#L23-L25;1;"public interface ARelationship extends Relationship<AnyObject, AnyObject> {

}"
936;5;6623370;feature envy;none;2019-03-29 13:22:08.157221;function;com.epam.wilma.core.processor.entity.Base64DecoderProcessor#getInputStream byte[];git@github.com:epam/Wilma.git;af271176f7847d06512b62ed8f1a4a0e7fd8b10a;/wilma-application/modules/wilma-core/src/main/java/com/epam/wilma/core/processor/entity/Base64DecoderProcessor.java;60;62;https://github.com/epam/Wilma/blob/af271176f7847d06512b62ed8f1a4a0e7fd8b10a/wilma-application/modules/wilma-core/src/main/java/com/epam/wilma/core/processor/entity/Base64DecoderProcessor.java/#L60-L62;1;"    private ByteArrayInputStream getInputStream(final byte[] bytes) {
        return new ByteArrayInputStream(bytes);
    }"
6214;20;4431383;data class;major;2019-04-19 15:28:11.650355;class;org.apache.eagle.jpm.util.resourcefetch.model.Applications;git@github.com:apache/eagle.git;7ac9421c2c27d12ae88f001866b4444310fcaa3f;/eagle-jpm/eagle-jpm-util/src/main/java/org/apache/eagle/jpm/util/resourcefetch/model/Applications.java;24;38;https://github.com/apache/eagle/blob/7ac9421c2c27d12ae88f001866b4444310fcaa3f/eagle-jpm/eagle-jpm-util/src/main/java/org/apache/eagle/jpm/util/resourcefetch/model/Applications.java/#L24-L38;0,5;"@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class Applications {

    private List<AppInfo> app;

    public List<AppInfo> getApp() {
        return app;
    }

    public void setApp(List<AppInfo> app) {
        this.app = app;
    }

}"
3309;17;3811653;feature envy;major;2019-04-05 12:51:43.849087;function;org.apache.activemq.artemis.core.server.impl.MessageReferenceImpl#copy Queue;git@github.com:apache/activemq-artemis.git;5bd5c610195d6f4a3dd1ac28170727003f8a5a54;/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/MessageReferenceImpl.java;137;140;https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/MessageReferenceImpl.java/#L137-L140;1;"   @Override
   public MessageReference copy(final Queue queue) {
      return new MessageReferenceImpl(this, queue);
   }"
1952;16;3877056;feature envy;major;2019-03-29 18:02:23.708308;function;org.apache.accumulo.server.util.ListVolumesUsed.listZookeeper ServerContext;git@github.com:apache/accumulo.git;f896c98c2356a52dfa2235d2cc02ae556ab17909;/server/base/src/main/java/org/apache/accumulo/server/util/ListVolumesUsed.java;61;75;https://github.com/apache/accumulo/blob/f896c98c2356a52dfa2235d2cc02ae556ab17909/server/base/src/main/java/org/apache/accumulo/server/util/ListVolumesUsed.java/#L61-L75;1;"  private static void listZookeeper(ServerContext context) throws Exception {
    System.out.println(""Listing volumes referenced in zookeeper"");
    TreeSet<String> volumes = new TreeSet<>();

    volumes.add(getTableURI(MetadataTableUtil.getRootTabletDir(context)));
    ArrayList<LogEntry> result = new ArrayList<>();
    MetadataTableUtil.getRootLogEntries(context, result);
    for (LogEntry logEntry : result) {
      getLogURIs(volumes, logEntry);
    }

    for (String volume : volumes)
      System.out.println(""\tVolume : "" + volume);

  }"
546;6;5812130;blob;none;2019-03-27 10:41:21.898803;class;org.apache.tinkerpop.gremlin.process.traversal.step.util.event.Event.ElementPropertyChangedEvent;git@github.com:apache/tinkerpop.git;7d9df0f0acf08f9e675ca7b337fc5e0243c09b53;/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/event/Event.java;217;222;https://github.com/apache/tinkerpop/blob/7d9df0f0acf08f9e675ca7b337fc5e0243c09b53/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/event/Event.java/#L217-L222;1;"    abstract class ElementPropertyChangedEvent extends ElementPropertyEvent {

        public ElementPropertyChangedEvent(final Element element, final Property oldValue, final Object newValue, final Object... vertexPropertyKeyValues) {
            super(element, oldValue, newValue, vertexPropertyKeyValues);
        }
    }"
2139;3;8799964;blob;none;2019-04-01 13:22:04.968182;class;org.apache.airavata.sharing.registry.service.cpi.SharingRegistryService.createPermissionType_args.createPermissionType_argsTupleSchemeFactory;git@github.com:apache/airavata.git;391843a00eefa7b6213e845f2f044b4e042894d5;/modules/sharing-registry/sharing-registry-stubs/src/main/java/org/apache/airavata/sharing/registry/service/cpi/SharingRegistryService.java;45666;45670;https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/sharing-registry/sharing-registry-stubs/src/main/java/org/apache/airavata/sharing/registry/service/cpi/SharingRegistryService.java/#L45666-L45670;1;"    private static class createPermissionType_argsTupleSchemeFactory implements SchemeFactory {
      public createPermissionType_argsTupleScheme getScheme() {
        return new createPermissionType_argsTupleScheme();
      }
    }"
10590;13;8293792;feature envy;critical;2019-07-26 12:29:53.260266;function;org.apache.james.mailrepository.cassandra.CassandraMailRepositoryMailDAO#toByteBuffer Serializable;git@github.com:apache/james-project.git;fa24a096a5853459c3769a34ccc68feb91626bfa;/server/mailrepository/mailrepository-cassandra/src/main/java/org/apache/james/mailrepository/cassandra/CassandraMailRepositoryMailDAO.java;257;265;https://github.com/apache/james-project/blob/fa24a096a5853459c3769a34ccc68feb91626bfa/server/mailrepository/mailrepository-cassandra/src/main/java/org/apache/james/mailrepository/cassandra/CassandraMailRepositoryMailDAO.java/#L257-L265;1;"    private ByteBuffer toByteBuffer(Serializable serializable) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            new ObjectOutputStream(outputStream).writeObject(serializable);
            return ByteBuffer.wrap(outputStream.toByteArray());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }"
3803;4;5129580;blob;none;2019-04-05 13:25:23.535319;class;org.apache.maven.index.ArtifactDiscoveryListener;git@github.com:apache/maven-indexer.git;8fcb8551345c78871a6adbc0f7238ccd408178d3;/indexer-core/src/main/java/org/apache/maven/index/ArtifactDiscoveryListener.java;27;30;https://github.com/apache/maven-indexer/blob/8fcb8551345c78871a6adbc0f7238ccd408178d3/indexer-core/src/main/java/org/apache/maven/index/ArtifactDiscoveryListener.java/#L27-L30;1;"public interface ArtifactDiscoveryListener
{
    void artifactDiscovered( ArtifactContext ac );
}"
14561;4;7155743;data class;major;2019-09-11 15:09:18.060285;class;com.microsoft.sqlserver.jdbc.Segment;git@github.com:Microsoft/mssql-jdbc.git;84484edf7944de56749fd2648d0af2ffa2459b7a;/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java;1932;1947;https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947;0;"class Segment {
    private byte segmentType;

    Segment(byte segmentType) {
        this.segmentType = segmentType;
    }

    /**
     * Returns the segmentType value.
     * 
     * @return byte segmentType value.
     */
    public byte getSegmentType() {
        return segmentType;
    }
}"
10733;4;7108130;long method;major;2019-07-26 19:51:05.704399;function;java.util.Base64.Encoder#encode0 byte[]|int|int|byte[];git@github.com:google/j2objc.git;471504a735b48d5d4ace51afa1542cc4790a921a;/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/Base64.java;391;438;https://github.com/google/j2objc/blob/471504a735b48d5d4ace51afa1542cc4790a921a/jre_emul/android/platform/libcore/ojluni/src/main/java/java/util/Base64.java/#L391-L438;1;"        private int encode0(byte[] src, int off, int end, byte[] dst) {
            char[] base64 = isURL ? toBase64URL : toBase64;
            int sp = off;
            int slen = (end - off) / 3 * 3;
            int sl = off + slen;
            if (linemax > 0 && slen  > linemax / 4 * 3)
                slen = linemax / 4 * 3;
            int dp = 0;
            while (sp < sl) {
                int sl0 = Math.min(sp + slen, sl);
                for (int sp0 = sp, dp0 = dp ; sp0 < sl0; ) {
                    int bits = (src[sp0++] & 0xff) << 16 |
                               (src[sp0++] & 0xff) <<  8 |
                               (src[sp0++] & 0xff);
                    dst[dp0++] = (byte)base64[(bits >>> 18) & 0x3f];
                    dst[dp0++] = (byte)base64[(bits >>> 12) & 0x3f];
                    dst[dp0++] = (byte)base64[(bits >>> 6)  & 0x3f];
                    dst[dp0++] = (byte)base64[bits & 0x3f];
                }
                int dlen = (sl0 - sp) / 3 * 4;
                dp += dlen;
                sp = sl0;
                if (dlen == linemax && sp < end) {
                    for (byte b : newline){
                        dst[dp++] = b;
                    }
                }
            }
            if (sp < end) {               // 1 or 2 leftover bytes
                int b0 = src[sp++] & 0xff;
                dst[dp++] = (byte)base64[b0 >> 2];
                if (sp == end) {
                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f];
                    if (doPadding) {
                        dst[dp++] = '=';
                        dst[dp++] = '=';
                    }
                } else {
                    int b1 = src[sp++] & 0xff;
                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f | (b1 >> 4)];
                    dst[dp++] = (byte)base64[(b1 << 2) & 0x3f];
                    if (doPadding) {
                        dst[dp++] = '=';
                    }
                }
            }
            return dp;
        }"
1429;13;7471737;blob;none;2019-03-29 13:50:22.339793;class;example.repo.Customer170Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/repo/Customer170Repository.java;9;12;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer170Repository.java/#L9-L12;0;"public interface Customer170Repository extends CrudRepository<Customer170, Long> {

	List<Customer170> findByLastName(String lastName);
}"
750;5;6328915;long method;none;2019-03-29 13:05:08.359998;function;org.eclipse.kapua.app.console.module.api.shared.model.session.GwtSession#getUserName;git@github.com:eclipse/kapua.git;11e610c657f7e473b52882833e33a2261bd3d67d;/console/module/api/src/main/java/org/eclipse/kapua/app/console/module/api/shared/model/session/GwtSession.java;129;131;https://github.com/eclipse/kapua/blob/11e610c657f7e473b52882833e33a2261bd3d67d/console/module/api/src/main/java/org/eclipse/kapua/app/console/module/api/shared/model/session/GwtSession.java/#L129-L131;1;"    public String getUserName() {
        return userName;
    }"
1421;11;7483476;feature envy;none;2019-03-29 13:50:09.337059;function;example.model.Customer1942.Customer1942;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/model/Customer1942.java;15;15;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer1942.java/#L15-L15;0;	protected Customer1942() {}
10168;13;3856911;feature envy;critical;2019-07-25 16:04:25.800763;function;org.apache.ambari.server.api.query.render.AlertSummaryRenderer#addRequiredAlertProperties Set<String>;git@github.com:apache/ambari.git;2bc4779a1e6aabe638101fc8b0e28cd1963d6b13;/ambari-server/src/main/java/org/apache/ambari/server/api/query/render/AlertSummaryRenderer.java;205;209;https://github.com/apache/ambari/blob/2bc4779a1e6aabe638101fc8b0e28cd1963d6b13/ambari-server/src/main/java/org/apache/ambari/server/api/query/render/AlertSummaryRenderer.java/#L205-L209;1;"  protected void addRequiredAlertProperties(Set<String> properties) {
    properties.add(AlertResourceProvider.ALERT_STATE);
    properties.add(AlertResourceProvider.ALERT_ORIGINAL_TIMESTAMP);
    properties.add(AlertResourceProvider.ALERT_MAINTENANCE_STATE);
  }"
11226;3;5894091;long method;major;2019-08-04 19:46:57.138337;function;org.apache.vxquery.runtime.functions.type.SequenceTypeMatcher#matchesAllInstances SequenceType;git@github.com:apache/vxquery.git;5d1175d2cb04a54ba751295f2ac67daec38bf723;/vxquery-core/src/main/java/org/apache/vxquery/runtime/functions/type/SequenceTypeMatcher.java;156;184;https://github.com/apache/vxquery/blob/5d1175d2cb04a54ba751295f2ac67daec38bf723/vxquery-core/src/main/java/org/apache/vxquery/runtime/functions/type/SequenceTypeMatcher.java/#L156-L184;1;"    public boolean matchesAllInstances(SequenceType testST) {
        Quantifier stq = sequenceType.getQuantifier();
        ItemType it = sequenceType.getItemType();
        if (stq.isSubQuantifier(testST.getQuantifier())) {
            if (it instanceof AnyItemType) {
                return true;
            } else if (it.isAtomicType() && testST.getItemType().isAtomicType()) {
                AtomicType ait = (AtomicType) it;
                AtomicType testIT = (AtomicType) testST.getItemType();
                if (BuiltinTypeRegistry.INSTANCE.isBuiltinTypeId(testIT.getTypeId())) {
                    SchemaType vType = BuiltinTypeRegistry.INSTANCE.getSchemaTypeById(testIT.getTypeId());
                    while (vType != null && vType.getTypeId() != ait.getTypeId()) {
                        vType = vType.getBaseType();
                    }
                    return vType != null;
                }
            } else if (it instanceof NodeType && testST.getItemType() instanceof NodeType) {
                NodeType nt = (NodeType) it;
                NodeKind kind = nt.getNodeKind();
                NodeType testNT = (NodeType) testST.getItemType();
                NodeKind testKind = testNT.getNodeKind();
                if (kind == NodeKind.ANY || kind == testKind) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }"
668;7;6179479;blob;none;2019-03-27 11:05:21.871282;class;org.eclipse.che.api.languageserver.util.JsonSerializable;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/plugins/plugin-languageserver/che-plugin-languageserver-ide/src/main/java/org/eclipse/che/api/languageserver/util/JsonSerializable.java;22;24;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/plugins/plugin-languageserver/che-plugin-languageserver-ide/src/main/java/org/eclipse/che/api/languageserver/util/JsonSerializable.java/#L22-L24;1;"public interface JsonSerializable extends org.eclipse.che.ide.dto.JsonSerializable {
  JSONValue toJsonElement();
}"
10869;1;7432284;long method;major;2019-07-29 12:05:55.570029;function;org.springframework.data.jdbc.config.oracle.PoolingDataSourceBeanDefinitionParser#setOptionalAttribute BeanDefinitionBuilder|Map<String, Object>|String|String|String;git@github.com:spring-projects/spring-data-jdbc-ext.git;9f19335f6f776ad36158cfaa0f5aad64333ce988;/spring-data-oracle/src/main/java/org/springframework/data/jdbc/config/oracle/PoolingDataSourceBeanDefinitionParser.java;341;388;https://github.com/spring-projects/spring-data-jdbc-ext/blob/9f19335f6f776ad36158cfaa0f5aad64333ce988/spring-data-oracle/src/main/java/org/springframework/data/jdbc/config/oracle/PoolingDataSourceBeanDefinitionParser.java/#L341-L388;0;"	private void setOptionalAttribute(BeanDefinitionBuilder builder,
				Map<String, Object> providedProperties,
				String propertyPrefix,
				String attributeValue,
				String attributeName) {
		String propertyKey;
		if (""username"".equals(attributeName)) {
			String userKey = (propertyPrefix != null ?
					propertyPrefix + ""user"" :
					""user"");
			if (providedProperties.containsKey(userKey)) {
				propertyKey = userKey;
			}
			else {
				propertyKey = (propertyPrefix != null ?
						propertyPrefix + attributeName :
						attributeName);
			}
		}
		else {
			propertyKey = (propertyPrefix != null ?
					propertyPrefix + attributeToPropertyMap.get(attributeName) :
					attributeToPropertyMap.get(attributeName));
		}

		if (StringUtils.hasText(attributeValue)) {
			if (logger.isDebugEnabled()) {
				if (""password"".equals(attributeName)) {
					logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +
							"" with attribute value ******"");
				}
				else {
					logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +
							"" with attribute value "" + attributeValue);
				}
			}
			builder.addPropertyValue(attributeToPropertyMap.get(attributeName), attributeValue);
		}
		else if (providedProperties.containsKey(propertyKey)) {
			if (logger.isDebugEnabled()) {
				logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +
						"" with property value "" +
						(""password"".equals(attributeName) ? ""******"" : providedProperties.get(propertyKey)));
			}
			builder.addPropertyValue(attributeToPropertyMap.get(attributeName), providedProperties.get(propertyKey));
		}
		removeProvidedProperty(providedProperties, propertyKey);
	}"
14876;5;7155743;data class;major;2019-09-12 09:36:58.568122;class;com.microsoft.sqlserver.jdbc.Segment;git@github.com:Microsoft/mssql-jdbc.git;84484edf7944de56749fd2648d0af2ffa2459b7a;/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java;1932;1947;https://github.com/Microsoft/mssql-jdbc/blob/84484edf7944de56749fd2648d0af2ffa2459b7a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java/#L1932-L1947;0;"class Segment {
    private byte segmentType;

    Segment(byte segmentType) {
        this.segmentType = segmentType;
    }

    /**
     * Returns the segmentType value.
     * 
     * @return byte segmentType value.
     */
    public byte getSegmentType() {
        return segmentType;
    }
}"
12748;3;6229861;blob;major;2019-08-06 21:03:09.099076;class;org.eclipse.gef.layout.LayoutContext;git@github.com:eclipse/gef.git;8f2649b90ab14a1bb010188036d4eedf7586e123;/org.eclipse.gef.layout/src/org/eclipse/gef/layout/LayoutContext.java;35;315;https://github.com/eclipse/gef/blob/8f2649b90ab14a1bb010188036d4eedf7586e123/org.eclipse.gef.layout/src/org/eclipse/gef/layout/LayoutContext.java/#L35-L315;1;"public class LayoutContext {

	/**
	 * An {@link LayoutContext} notifies registered listeners about changes to
	 * the layout algorithm using this property name.
	 */
	public static final String LAYOUT_ALGORITHM_PROPERTY = ""layoutAlgorithm"";

	private ObjectProperty<ILayoutAlgorithm> layoutAlgorithmProperty = new SimpleObjectProperty<>(
			this, LAYOUT_ALGORITHM_PROPERTY);

	private Graph graph;
	private final List<Runnable> postLayoutPass = new ArrayList<>();
	private final List<Runnable> preLayoutPass = new ArrayList<>();
	private final List<ILayoutFilter> layoutFilters = new ArrayList<>();

	/**
	 * Adds the given ILayoutFilter to this {@link LayoutContext}.
	 * 
	 * @param layoutFilter
	 *            The ILayoutFilter to add to this context.
	 */
	public void addLayoutFilter(ILayoutFilter layoutFilter) {
		layoutFilters.add(layoutFilter);
	}

	/**
	 * Applies the layout algorithm of this LayoutContext. The clean flag is
	 * passed-in to the layout algorithm to indicate whether the context changed
	 * significantly since the last layout pass.
	 * 
	 * @param clear
	 *            <code>true</code> to indicate that the algorithm has to fully
	 *            re-compute the layout, otherwise <code>false</code>.
	 */
	public void applyLayout(boolean clear) {
		ILayoutAlgorithm layoutAlgorithm = layoutAlgorithmProperty.get();
		if (layoutAlgorithm != null) {
			preLayout();
			layoutAlgorithm.applyLayout(this, clear);
			postLayout();
		}
	}

	/**
	 * Initiated by the context or by an {@link ILayoutAlgorithm} to perform
	 * steps that are scheduled to be run after the layout pass. Should not be
	 * called by clients.
	 */
	public void postLayout() {
		for (Runnable r : new ArrayList<>(postLayoutPass)) {
			r.run();
		}
	}

	/**
	 * Initiated by the context or by an {@link ILayoutAlgorithm} to perform
	 * steps that are scheduled to be run before the layout pass. Should not be
	 * called by clients.
	 */
	public void preLayout() {
		for (Runnable r : preLayoutPass) {
			r.run();
		}
	}

	/**
	 * Returns the graph that is to be layouted.
	 * 
	 * @return The {@link Graph} that is to be layouted.
	 */
	public Graph getGraph() {
		return graph;
	}

	/**
	 * Sets the graph that is to be layouted by this context.
	 * 
	 * @param graph
	 *            The {@link Graph} to layout.
	 */
	public void setGraph(Graph graph) {
		// TODO: we should not allow to pass in null here. Instead we should
		// guard ourselves against null.
		if (graph == null) {
			graph = new Graph();
		}
		this.graph = graph;
	}

	/**
	 * Returns all the nodes that should be laid out. Replacing elements in the
	 * returned array does not affect this context.
	 * 
	 * @return array of nodes to lay out
	 */
	// TODO: remove this (algorithms should use getGraph().getNodes())
	public Node[] getNodes() {
		ObservableList<Node> nodes = graph.getNodes();
		List<Node> layoutRelevantNodes = new ArrayList<>();
		for (Node n : nodes) {
			if (!isLayoutIrrelevant(n)) {
				layoutRelevantNodes.add(n);
			}
		}
		return layoutRelevantNodes.toArray(new Node[] {});
	}

	/**
	 * Returns all the connections between nodes that should be laid out.
	 * Replacing elements in the returned array does not affect this context.
	 * 
	 * @return array of connections between nodes
	 */
	public Edge[] getEdges() {
		ObservableList<Edge> edges = graph.getEdges();
		List<Edge> layoutRelevantEdges = new ArrayList<>();
		for (Edge e : edges) {
			if (!isLayoutIrrelevant(e)) {
				layoutRelevantEdges.add(e);
			}
		}
		return layoutRelevantEdges.toArray(new Edge[] {});
	}

	/**
	 * Returns the static layout algorithm used to layout a newly initialized
	 * graph or after heavy changes to it.
	 * 
	 * @return The layout algorithm that is used by this {@link LayoutContext}.
	 */
	public ILayoutAlgorithm getLayoutAlgorithm() {
		return layoutAlgorithmProperty.get();
	}

	/**
	 * Returns <code>true</code> when the given {@link Edge} is not relevant for
	 * layout according to the configured {@link ILayoutFilter layout filters}.
	 * Otherwise returns <code>false</code>.
	 * 
	 * @param edge
	 *            The {@link Edge} in question.
	 * @return <code>true</code> when the given {@link Edge} is not relevant for
	 *         layout according to the configure layout filters, otherwise
	 *         <code>false</code>.
	 */
	public boolean isLayoutIrrelevant(Edge edge) {
		for (ILayoutFilter filter : layoutFilters) {
			if (filter.isLayoutIrrelevant(edge)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Returns <code>true</code> when the given {@link Node} is not relevant for
	 * layout according to the configured {@link ILayoutFilter layout filters}.
	 * Otherwise returns <code>false</code>.
	 * 
	 * @param nodeLayout
	 *            The {@link Node} in question.
	 * @return <code>true</code> when the given {@link Node} is not relevant for
	 *         layout according to the configure layout filters, otherwise
	 *         <code>false</code>.
	 */
	public boolean isLayoutIrrelevant(Node nodeLayout) {
		for (ILayoutFilter filter : layoutFilters) {
			if (filter.isLayoutIrrelevant(nodeLayout)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * A property representing the layout algorithm used by this
	 * {@link LayoutContext}.
	 * 
	 * @see #getLayoutAlgorithm()
	 * @see #setLayoutAlgorithm(ILayoutAlgorithm)
	 * 
	 * @return A property named {@link #LAYOUT_ALGORITHM_PROPERTY}.
	 */
	public ObjectProperty<ILayoutAlgorithm> layoutAlgorithmProperty() {
		return layoutAlgorithmProperty;
	};

	/**
	 * Removes the given ILayoutFilter from this {@link LayoutContext}.
	 * 
	 * @param layoutFilter
	 *            The ILayoutFilter to remove to this context.
	 */
	public void removeLayoutFilter(ILayoutFilter layoutFilter) {
		layoutFilters.remove(layoutFilter);
	}

	/**
	 * Adds the given {@link Runnable} to the list of runnables which are called
	 * when this {@link LayoutContext} is asked to apply all changes made to its
	 * elements to the display.
	 * 
	 * @param runnable
	 *            A {@link Runnable} called whenever this context is asked to
	 *            apply all changes made to its elements to the display.
	 */
	public void schedulePostLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (!postLayoutPass.contains(runnable)) {
			postLayoutPass.add(runnable);
		}
	}

	/**
	 * Adds the given {@link Runnable} to the list of {@link Runnable}s which
	 * are executed before applying a layout, i.e. before
	 * {@link #applyLayout(boolean)}.
	 * 
	 * @param runnable
	 *            The {@link Runnable} to add to the list of {@link Runnable}s
	 *            which are executed before applying a layout.
	 */
	public void schedulePreLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (!preLayoutPass.contains(runnable)) {
			preLayoutPass.add(runnable);
		}
	}

	/**
	 * Sets the layout algorithm for this context.
	 * 
	 * @param algorithm
	 *            The new {@link ILayoutAlgorithm} for this
	 *            {@link LayoutContext}.
	 */
	public void setLayoutAlgorithm(ILayoutAlgorithm algorithm) {
		layoutAlgorithmProperty.set(algorithm);
	}

	/**
	 * Removes the given {@link Runnable} from the list of runnables which are
	 * called when this {@link LayoutContext} is asked to apply all changes made
	 * to its elements to the display.
	 * 
	 * @param runnable
	 *            The {@link Runnable} that should no longer get called when
	 *            flushing changes.
	 */
	public void unschedulePostLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (postLayoutPass.contains(runnable)) {
			postLayoutPass.remove(runnable);
		}
	}

	/**
	 * Removes the given {@link Runnable} from the list of {@link Runnable}s
	 * which are executed before applying a layout, i.e. before
	 * {@link #applyLayout(boolean)}.
	 * 
	 * @param runnable
	 *            The {@link Runnable} to remove from the list of
	 *            {@link Runnable}s which are executed before applying a layout.
	 */
	public void unschedulePreLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (preLayoutPass.contains(runnable)) {
			preLayoutPass.remove(runnable);
		}
	}
}"
12445;3;9225640;long method;major;2019-08-06 16:33:35.956995;function;jdk.internal.net.http.WindowController#increaseConnectionWindow int;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.net.http/share/classes/jdk/internal/net/http/WindowController.java;181;226;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.net.http/share/classes/jdk/internal/net/http/WindowController.java/#L181-L226;1;"    boolean increaseConnectionWindow(int amount) {
        List<Stream<?>> candidates = null;
        controllerLock.lock();
        try {
            int size = connectionWindowSize;
            size += amount;
            if (size < 0)
                return false;
            connectionWindowSize = size;
            if (debug.on())
                debug.log(""Connection window size is now %d (amount added %d)"",
                          size, amount);

            // Notify waiting streams, until the new increased window size is
            // effectively exhausted.
            Iterator<Map.Entry<Integer,Map.Entry<Stream<?>,Integer>>> iter =
                    pending.entrySet().iterator();

            while (iter.hasNext() && size > 0) {
                Map.Entry<Integer,Map.Entry<Stream<?>,Integer>> item = iter.next();
                Integer streamSize = streams.get(item.getKey());
                if (streamSize == null) {
                    iter.remove();
                } else {
                    Map.Entry<Stream<?>,Integer> e = item.getValue();
                    int requestedAmount = e.getValue();
                    // only wakes up the pending streams for which there is
                    // at least 1 byte of space in both windows
                    int minAmount = 1;
                    if (size >= minAmount && streamSize >= minAmount) {
                        size -= Math.min(streamSize, requestedAmount);
                        iter.remove();
                        if (candidates == null)
                            candidates = new ArrayList<>();
                        candidates.add(e.getKey());
                    }
                }
            }
        } finally {
            controllerLock.unlock();
        }
        if (candidates != null) {
            candidates.forEach(Stream::signalWindowUpdate);
        }
        return true;
    }"
1836;10;8334291;blob;major;2019-03-29 14:24:22.425779;class;org.aspectj.apache.bcel.classfile.AttributeUtils;git@github.com:eclipse/org.aspectj.git;370f291c359cd159c5f3f0abd6e9e53e81234a07;/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/AttributeUtils.java;9;99;https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/AttributeUtils.java/#L9-L99;1;"public class AttributeUtils {

	public static Attribute[] readAttributes(DataInputStream dataInputstream, ConstantPool cpool) {
		try {
			int length = dataInputstream.readUnsignedShort();
			if (length == 0) {
				return Attribute.NoAttributes;
			}
			Attribute[] attrs = new Attribute[length];
			for (int i = 0; i < length; i++) {
				attrs[i] = Attribute.readAttribute(dataInputstream, cpool);
			}
			return attrs;
		} catch (IOException e) {
			throw new ClassFormatException(""IOException whilst reading set of attributes: "" + e.toString());
		}
	}

	/** Write (serialize) a set of attributes into a specified output stream */
	public static void writeAttributes(Attribute[] attributes, DataOutputStream file) throws IOException {
		if (attributes == null) {
			file.writeShort(0);
		} else {
			file.writeShort(attributes.length);
			for (int i = 0; i < attributes.length; i++) {
				attributes[i].dump(file);
			}
		}
	}

	public static Signature getSignatureAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SIGNATURE) {
				return (Signature) attributes[i];
			}
		}
		return null;
	}

	public static Code getCodeAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_CODE) {
				return (Code) attributes[i];
			}
		}
		return null;
	}

	public static ExceptionTable getExceptionTableAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_EXCEPTIONS) {
				return (ExceptionTable) attributes[i];
			}
		}
		return null;
	}

	public static ConstantValue getConstantValueAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].getTag() == Constants.ATTR_CONSTANT_VALUE) {
				return (ConstantValue) attributes[i];
			}
		}
		return null;
	}

	public static void accept(Attribute[] attributes, ClassVisitor visitor) {
		for (int i = 0; i < attributes.length; i++) {
			attributes[i].accept(visitor);
		}
	}

	public static boolean hasSyntheticAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SYNTHETIC) {
				return true;
			}
		}
		return false;
	}

	public static SourceFile getSourceFileAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SOURCE_FILE) {
				return (SourceFile) attributes[i];
			}
		}
		return null;
	}

}"
2250;3;9012542;data class;major;2019-04-01 14:01:28.193667;class;org.apache.lucene.codecs.memory.FSTTermsWriter.FieldMetaData;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java;229;247;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java/#L229-L247;1;"  private static class FieldMetaData {
    public final FieldInfo fieldInfo;
    public final long numTerms;
    public final long sumTotalTermFreq;
    public final long sumDocFreq;
    public final int docCount;
    public final int longsSize;
    public final FST<FSTTermOutputs.TermData> dict;

    public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST<FSTTermOutputs.TermData> fst) {
      this.fieldInfo = fieldInfo;
      this.numTerms = numTerms;
      this.sumTotalTermFreq = sumTotalTermFreq;
      this.sumDocFreq = sumDocFreq;
      this.docCount = docCount;
      this.longsSize = longsSize;
      this.dict = fst;
    }
  }"
3676;4;7391055;data class;major;2019-04-05 13:17:39.663160;class;org.springframework.data.release.model.Release;git@github.com:spring-projects/spring-data-dev-tools.git;a25ff3ae28026f132871f7172c6ba5c3b64e1671;/release-tools/src/main/java/org/springframework/data/release/model/Release.java;25;33;https://github.com/spring-projects/spring-data-dev-tools/blob/a25ff3ae28026f132871f7172c6ba5c3b64e1671/release-tools/src/main/java/org/springframework/data/release/model/Release.java/#L25-L33;0;"@Value
public class Release {

	private final String id;
	private final ProjectKey projectKey;
	private final String name;
	private final String description;
	private final LocalDate date;
}"
2331;3;3972555;data class;none;2019-04-01 14:09:03.676399;class;org.apache.aurora.scheduler.storage.durability.RecoveryTool.RecoveryEndpoint;git@github.com:apache/aurora.git;6ec953f27f7f80366d6bf4c8e7cba0e62a874753;/src/main/java/org/apache/aurora/scheduler/storage/durability/RecoveryTool.java;60;64;https://github.com/apache/aurora/blob/6ec953f27f7f80366d6bf4c8e7cba0e62a874753/src/main/java/org/apache/aurora/scheduler/storage/durability/RecoveryTool.java/#L60-L64;1;"  interface RecoveryEndpoint {
    Iterable<Object> getOptions();

    Persistence create();
  }"
14665;4;6257015;data class;major;2019-09-12 08:05:33.800734;class;org.eclipse.hawkbit.HawkbitServerProperties.Build;git@github.com:eclipse/hawkbit.git;51be28147f6f575b6c1ab4a5ef84ffd9174f1209;/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java;75;90;https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90;1;"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }"
526;6;5771277;feature envy;none;2019-03-27 10:34:53.041496;function;org.apache.syncope.client.ui.commons.ConnIdSpecialName.ConnIdSpecialName;git@github.com:apache/syncope.git;114c412afbfba24ffb4fbc804e5308a823a16a78;/client/idrepo/ui/src/main/java/org/apache/syncope/client/ui/commons/ConnIdSpecialName.java;35;37;https://github.com/apache/syncope/blob/114c412afbfba24ffb4fbc804e5308a823a16a78/client/idrepo/ui/src/main/java/org/apache/syncope/client/ui/commons/ConnIdSpecialName.java/#L35-L37;1;"    private ConnIdSpecialName() {
        // private constructor for static utility class
    }"
720;7;6246396;feature envy;none;2019-03-27 11:19:04.513842;function;org.eclipse.hono.adapter.mqtt.CommandSubscription#getQos;git@github.com:eclipse/hono.git;ec84947227564c6459801f708bdeabd7687a8bf0;/adapters/mqtt-vertx-base/src/main/java/org/eclipse/hono/adapter/mqtt/CommandSubscription.java;141;143;https://github.com/eclipse/hono/blob/ec84947227564c6459801f708bdeabd7687a8bf0/adapters/mqtt-vertx-base/src/main/java/org/eclipse/hono/adapter/mqtt/CommandSubscription.java/#L141-L143;1;"    public MqttQoS getQos() {
        return qos;
    }"
946;1;6605811;blob;none;2019-03-29 13:22:25.535817;class;com.epam.catgenome.entity.wig.WigFile;git@github.com:epam/NGB.git;340504529fc576eeec92fbae636e437ce486cc4a;/server/catgenome/src/main/java/com/epam/catgenome/entity/wig/WigFile.java;38;42;https://github.com/epam/NGB/blob/340504529fc576eeec92fbae636e437ce486cc4a/server/catgenome/src/main/java/com/epam/catgenome/entity/wig/WigFile.java/#L38-L42;1;"public class WigFile extends FeatureFile {
    public WigFile() {
        setFormat(BiologicalDataItemFormat.WIG);
    }
}"
12599;3;4394144;blob;critical;2019-08-06 19:30:02.222592;class;org.apache.cxf.jaxrs.rx2.client.FlowableRxInvoker;git@github.com:apache/cxf.git;6bf89e9c8804c8845ec4d38583dd33eea8256439;/rt/rs/extensions/rx2/src/main/java/org/apache/cxf/jaxrs/rx2/client/FlowableRxInvoker.java;29;106;https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/rt/rs/extensions/rx2/src/main/java/org/apache/cxf/jaxrs/rx2/client/FlowableRxInvoker.java/#L29-L106;1;"@SuppressWarnings(""rawtypes"")
public interface FlowableRxInvoker extends RxInvoker<Flowable> {

    @Override
    Flowable<Response> get();

    @Override
    <T> Flowable<T> get(Class<T> responseType);

    @Override
    <T> Flowable<T> get(GenericType<T> responseType);

    @Override
    Flowable<Response> put(Entity<?> entity);

    @Override
    <T> Flowable<T> put(Entity<?> entity, Class<T> clazz);

    @Override
    <T> Flowable<T> put(Entity<?> entity, GenericType<T> type);

    @Override
    Flowable<Response> post(Entity<?> entity);

    @Override
    <T> Flowable<T> post(Entity<?> entity, Class<T> clazz);

    @Override
    <T> Flowable<T> post(Entity<?> entity, GenericType<T> type);

    @Override
    Flowable<Response> delete();

    @Override
    <T> Flowable<T> delete(Class<T> responseType);

    @Override
    <T> Flowable<T> delete(GenericType<T> responseType);

    @Override
    Flowable<Response> head();

    @Override
    Flowable<Response> options();

    @Override
    <T> Flowable<T> options(Class<T> responseType);

    @Override
    <T> Flowable<T> options(GenericType<T> responseType);

    @Override
    Flowable<Response> trace();

    @Override
    <T> Flowable<T> trace(Class<T> responseType);

    @Override
    <T> Flowable<T> trace(GenericType<T> responseType);

    @Override
    Flowable<Response> method(String name);

    @Override
    <T> Flowable<T> method(String name, Class<T> responseType);

    @Override
    <T> Flowable<T> method(String name, GenericType<T> responseType);

    @Override
    Flowable<Response> method(String name, Entity<?> entity);

    @Override
    <T> Flowable<T> method(String name, Entity<?> entity, Class<T> responseType);

    @Override
    <T> Flowable<T> method(String name, Entity<?> entity, GenericType<T> responseType);
}"
1002;1;6920891;long method;none;2019-03-29 13:25:59.015255;function;com.google.gdata.data.docs.ArchiveEntry#hasArchiveNotify;git@github.com:google/gdata-java-client.git;c6202a55f5f29afb37ffcf876674dca372f3fb4c;/java/src/com/google/gdata/data/docs/ArchiveEntry.java;199;201;https://github.com/google/gdata-java-client/blob/c6202a55f5f29afb37ffcf876674dca372f3fb4c/java/src/com/google/gdata/data/docs/ArchiveEntry.java/#L199-L201;0,5;"  public boolean hasArchiveNotify() {
    return hasExtension(ArchiveNotify.class);
  }"
9438;4;8495850;long method;major;2019-07-23 20:12:53.906977;function;org.apache.cloudstack.api.command.admin.storage.AddImageStoreS3CMD#execute;git@github.com:apache/cloudstack.git;8d3feb100aab4a45b31a789f444038b892161eec;/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/AddImageStoreS3CMD.java;99;147;https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/api/src/main/java/org/apache/cloudstack/api/command/admin/storage/AddImageStoreS3CMD.java/#L99-L147;1;"    @Override
    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException,
        ResourceAllocationException, NetworkRuleConflictException {

        Map<String, String> dm = new HashMap();

        dm.put(ApiConstants.S3_ACCESS_KEY, getAccessKey());
        dm.put(ApiConstants.S3_SECRET_KEY, getSecretKey());
        dm.put(ApiConstants.S3_END_POINT, getEndPoint());
        dm.put(ApiConstants.S3_BUCKET_NAME, getBucketName());

        if (getSigner() != null && (getSigner().equals(ApiConstants.S3_V3_SIGNER) || getSigner().equals(ApiConstants.S3_V4_SIGNER))) {
            dm.put(ApiConstants.S3_SIGNER, getSigner());
        }
        if (isHttps() != null) {
            dm.put(ApiConstants.S3_HTTPS_FLAG, isHttps().toString());
        }
        if (getConnectionTimeout() != null) {
            dm.put(ApiConstants.S3_CONNECTION_TIMEOUT, getConnectionTimeout().toString());
        }
        if (getMaxErrorRetry() != null) {
            dm.put(ApiConstants.S3_MAX_ERROR_RETRY, getMaxErrorRetry().toString());
        }
        if (getSocketTimeout() != null) {
            dm.put(ApiConstants.S3_SOCKET_TIMEOUT, getSocketTimeout().toString());
        }
        if (getConnectionTtl() != null) {
            dm.put(ApiConstants.S3_CONNECTION_TTL, getConnectionTtl().toString());
        }
        if (getUseTCPKeepAlive() != null) {
            dm.put(ApiConstants.S3_USE_TCP_KEEPALIVE, getUseTCPKeepAlive().toString());
        }

        try{
            ImageStore result = _storageService.discoverImageStore(null, null, ""S3"", null, dm);
            ImageStoreResponse storeResponse;
            if (result != null) {
                storeResponse = _responseGenerator.createImageStoreResponse(result);
                storeResponse.setResponseName(getCommandName());
                storeResponse.setObjectName(""imagestore"");
                setResponseObject(storeResponse);
            } else {
                throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to add S3 Image Store."");
            }
        } catch (DiscoveryException ex) {
            s_logger.warn(""Exception: "", ex);
            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());
        }
    }"
1110;17;7074773;feature envy;none;2019-03-29 13:31:13.801056;function;com.linkedin.parseq.example.simple.DegradedExperienceExample.main String[];git@github.com:linkedin/parseq.git;6151cc9064cf8af2ec5ab10ec80aa8c40db6b13c;/subprojects/parseq-examples/src/main/java/com/linkedin/parseq/example/simple/DegradedExperienceExample.java;19;21;https://github.com/linkedin/parseq/blob/6151cc9064cf8af2ec5ab10ec80aa8c40db6b13c/subprojects/parseq-examples/src/main/java/com/linkedin/parseq/example/simple/DegradedExperienceExample.java/#L19-L21;1;"  public static void main(String[] args) throws Exception {
    new DegradedExperienceExample().runExample();
  }"
11123;10;6890147;data class;major;2019-08-02 12:11:00.157481;class;com.sun.tools.sjavac.server.SysInfo;git@github.com:google/error-prone-javac.git;a53d069bbdb2c60232ed3811c19b65e41c3e60e0;/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java;45;56;https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56;0;"public class SysInfo implements Serializable {

    static final long serialVersionUID = -3096346807579L;

    public int numCores;
    public long maxMemory;

    public SysInfo(int nc, long mm) {
        numCores = nc;
        maxMemory = mm;
    }
}"
1004;12;6890147;data class;critical;2019-03-29 13:25:59.333729;class;com.sun.tools.sjavac.server.SysInfo;git@github.com:google/error-prone-javac.git;a53d069bbdb2c60232ed3811c19b65e41c3e60e0;/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java;45;56;https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56;0;"public class SysInfo implements Serializable {

    static final long serialVersionUID = -3096346807579L;

    public int numCores;
    public long maxMemory;

    public SysInfo(int nc, long mm) {
        numCores = nc;
        maxMemory = mm;
    }
}"
2155;3;8902918;blob;none;2019-04-01 13:22:43.809093;class;org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore.drop_wm_trigger_args.drop_wm_trigger_argsTupleSchemeFactory;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java;229053;229057;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/standalone-metastore/metastore-common/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ThriftHiveMetastore.java/#L229053-L229057;1;"    private static class drop_wm_trigger_argsTupleSchemeFactory implements SchemeFactory {
      public drop_wm_trigger_argsTupleScheme getScheme() {
        return new drop_wm_trigger_argsTupleScheme();
      }
    }"
12773;3;6772589;blob;major;2019-08-06 21:15:09.514031;class;com.facebook.ads.sdk.Page.APIRequestCreateMessengerProfile;git@github.com:facebook/facebook-java-business-sdk.git;561f1a75e1220b55a160a1b92b0187f72be9cd08;/src/main/java/com/facebook/ads/sdk/Page.java;25416;25594;https://github.com/facebook/facebook-java-business-sdk/blob/561f1a75e1220b55a160a1b92b0187f72be9cd08/src/main/java/com/facebook/ads/sdk/Page.java/#L25416-L25594;1;"  public static class APIRequestCreateMessengerProfile extends APIRequest<Page> {

    Page lastResponse = null;
    @Override
    public Page getLastResponse() {
      return lastResponse;
    }
    public static final String[] PARAMS = {
      ""get_started"",
      ""persistent_menu"",
      ""target_audience"",
      ""whitelisted_domains"",
      ""greeting"",
      ""account_linking_url"",
      ""payment_settings"",
      ""home_url"",
    };

    public static final String[] FIELDS = {
    };

    @Override
    public Page parseResponse(String response, String header) throws APIException {
      return Page.parseResponse(response, getContext(), this, header).head();
    }

    @Override
    public Page execute() throws APIException {
      return execute(new HashMap<String, Object>());
    }

    @Override
    public Page execute(Map<String, Object> extraParams) throws APIException {
      ResponseWrapper rw = executeInternal(extraParams);
      lastResponse = parseResponse(rw.getBody(), rw.getHeader());
      return lastResponse;
    }

    public ListenableFuture<Page> executeAsync() throws APIException {
      return executeAsync(new HashMap<String, Object>());
    };

    public ListenableFuture<Page> executeAsync(Map<String, Object> extraParams) throws APIException {
      return Futures.transform(
        executeAsyncInternal(extraParams),
        new Function<ResponseWrapper, Page>() {
           public Page apply(ResponseWrapper result) {
             try {
               return APIRequestCreateMessengerProfile.this.parseResponse(result.getBody(), result.getHeader());
             } catch (Exception e) {
               throw new RuntimeException(e);
             }
           }
         }
      );
    };

    public APIRequestCreateMessengerProfile(String nodeId, APIContext context) {
      super(context, nodeId, ""/messenger_profile"", ""POST"", Arrays.asList(PARAMS));
    }

    @Override
    public APIRequestCreateMessengerProfile setParam(String param, Object value) {
      setParamInternal(param, value);
      return this;
    }

    @Override
    public APIRequestCreateMessengerProfile setParams(Map<String, Object> params) {
      setParamsInternal(params);
      return this;
    }


    public APIRequestCreateMessengerProfile setGetStarted (Object getStarted) {
      this.setParam(""get_started"", getStarted);
      return this;
    }
    public APIRequestCreateMessengerProfile setGetStarted (String getStarted) {
      this.setParam(""get_started"", getStarted);
      return this;
    }

    public APIRequestCreateMessengerProfile setPersistentMenu (List<Object> persistentMenu) {
      this.setParam(""persistent_menu"", persistentMenu);
      return this;
    }
    public APIRequestCreateMessengerProfile setPersistentMenu (String persistentMenu) {
      this.setParam(""persistent_menu"", persistentMenu);
      return this;
    }

    public APIRequestCreateMessengerProfile setTargetAudience (Object targetAudience) {
      this.setParam(""target_audience"", targetAudience);
      return this;
    }
    public APIRequestCreateMessengerProfile setTargetAudience (String targetAudience) {
      this.setParam(""target_audience"", targetAudience);
      return this;
    }

    public APIRequestCreateMessengerProfile setWhitelistedDomains (List<String> whitelistedDomains) {
      this.setParam(""whitelisted_domains"", whitelistedDomains);
      return this;
    }
    public APIRequestCreateMessengerProfile setWhitelistedDomains (String whitelistedDomains) {
      this.setParam(""whitelisted_domains"", whitelistedDomains);
      return this;
    }

    public APIRequestCreateMessengerProfile setGreeting (List<Object> greeting) {
      this.setParam(""greeting"", greeting);
      return this;
    }
    public APIRequestCreateMessengerProfile setGreeting (String greeting) {
      this.setParam(""greeting"", greeting);
      return this;
    }

    public APIRequestCreateMessengerProfile setAccountLinkingUrl (String accountLinkingUrl) {
      this.setParam(""account_linking_url"", accountLinkingUrl);
      return this;
    }

    public APIRequestCreateMessengerProfile setPaymentSettings (Object paymentSettings) {
      this.setParam(""payment_settings"", paymentSettings);
      return this;
    }
    public APIRequestCreateMessengerProfile setPaymentSettings (String paymentSettings) {
      this.setParam(""payment_settings"", paymentSettings);
      return this;
    }

    public APIRequestCreateMessengerProfile setHomeUrl (Object homeUrl) {
      this.setParam(""home_url"", homeUrl);
      return this;
    }
    public APIRequestCreateMessengerProfile setHomeUrl (String homeUrl) {
      this.setParam(""home_url"", homeUrl);
      return this;
    }

    public APIRequestCreateMessengerProfile requestAllFields () {
      return this.requestAllFields(true);
    }

    public APIRequestCreateMessengerProfile requestAllFields (boolean value) {
      for (String field : FIELDS) {
        this.requestField(field, value);
      }
      return this;
    }

    @Override
    public APIRequestCreateMessengerProfile requestFields (List<String> fields) {
      return this.requestFields(fields, true);
    }

    @Override
    public APIRequestCreateMessengerProfile requestFields (List<String> fields, boolean value) {
      for (String field : fields) {
        this.requestField(field, value);
      }
      return this;
    }

    @Override
    public APIRequestCreateMessengerProfile requestField (String field) {
      this.requestField(field, true);
      return this;
    }

    @Override
    public APIRequestCreateMessengerProfile requestField (String field, boolean value) {
      this.requestFieldInternal(field, value);
      return this;
    }

  }"
2912;20;7461973;blob;none;2019-04-05 12:20:25.131404;class;example.repo.Customer1677Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/repo/Customer1677Repository.java;9;12;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer1677Repository.java/#L9-L12;0;"public interface Customer1677Repository extends CrudRepository<Customer1677, Long> {

	List<Customer1677> findByLastName(String lastName);
}"
10668;10;7457996;data class;major;2019-07-26 13:12:08.828302;class;example.model.Customer388;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/model/Customer388.java;8;27;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/model/Customer388.java/#L8-L27;0;"@Entity
public class Customer388 {

	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id;
	private String firstName;
	private String lastName;

	protected Customer388() {}

	public Customer388(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	@Override
	public String toString() {
		return String.format(""Customer388[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}

}"
13635;1;5117164;long method;major;2019-08-30 09:38:27.773365;function;org.apache.manifoldcf.agents.system.AgentsDaemon.AgentsThread#run;git@github.com:apache/manifoldcf.git;542db79eb8662c086e39ee7deac743da430f5714;/framework/agents/src/main/java/org/apache/manifoldcf/agents/system/AgentsDaemon.java;197;247;https://github.com/apache/manifoldcf/blob/542db79eb8662c086e39ee7deac743da430f5714/framework/agents/src/main/java/org/apache/manifoldcf/agents/system/AgentsDaemon.java/#L197-L247;0,5;"    public void run()
    {
      try
      {
        IThreadContext threadContext = ThreadContextFactory.make();
        while (true)
        {
          try
          {
            if (Thread.currentThread().isInterrupted())
              throw new ManifoldCFException(""Interrupted"",ManifoldCFException.INTERRUPTED);

            checkAgents(threadContext);
            ManifoldCF.sleep(5000L);
          }
          catch (InterruptedException e)
          {
            break;
          }
          catch (ManifoldCFException e)
          {
            if (e.getErrorCode() == ManifoldCFException.INTERRUPTED)
              break;
            if (e.getErrorCode() == ManifoldCFException.SETUP_ERROR)
            {
              System.err.println(""Misconfigured ManifoldCF agents - shutting down"");
              Logging.agents.fatal(""AgentThread configuration exception tossed: ""+e.getMessage(),e);
              System.exit(-200);
            }
            Logging.agents.error(""Exception tossed: ""+e.getMessage(),e);
          }
          catch (OutOfMemoryError e)
          {
            System.err.println(""Agents process ran out of memory - shutting down"");
            e.printStackTrace(System.err);
            System.exit(-200);
          }
          catch (Throwable e)
          {
            Logging.agents.fatal(""Error tossed: ""+e.getMessage(),e);
          }
        }
      }
      catch (Throwable e)
      {
        // Severe error on initialization
        System.err.println(""Agents process could not start - shutting down"");
        Logging.agents.fatal(""AgentThread initialization error tossed: ""+e.getMessage(),e);
        System.exit(-300);
      }
    }"
12310;3;7291517;long method;major;2019-08-06 12:16:30.351119;function;org.grails.ide.eclipse.editor.actions.UrlMappingHyperlinkDetector#findLinkComponentsInClosure ClosureExpression|int;git@github.com:spring-projects/grails-ide.git;cb5162c5a7fc60a2847c39d2750003ada7e80ff7;/org.grails.ide.eclipse.editor.groovy/src/org/grails/ide/eclipse/editor/actions/UrlMappingHyperlinkDetector.java;319;360;https://github.com/spring-projects/grails-ide/blob/cb5162c5a7fc60a2847c39d2750003ada7e80ff7/org.grails.ide.eclipse.editor.groovy/src/org/grails/ide/eclipse/editor/actions/UrlMappingHyperlinkDetector.java/#L319-L360;0,5;"    private NameRegion[] findLinkComponentsInClosure(ClosureExpression firstArg,
            int offset) {
        if (! (firstArg.getCode() instanceof BlockStatement)) {
            return null;
        }
        
        BlockStatement code = (BlockStatement) firstArg.getCode();
        if (code.getStatements() == null) {
            return null;
        }
        NameRegion controllerName = null;
        NameRegion actionName = null;
        NameRegion viewName = null;

        for (Statement state : code.getStatements()) {
            if (state instanceof ExpressionStatement) {
                if (((ExpressionStatement) state).getExpression() instanceof BinaryExpression) {
                    BinaryExpression bexpr = (BinaryExpression) ((ExpressionStatement) state).getExpression();
                    Expression left = bexpr.getLeftExpression();
                    if (bexpr.getOperation().getText().equals(""="") && left instanceof VariableExpression) {
                        Expression right = bexpr.getRightExpression();
                        Region region;
                        if (right.getStart() <= offset && right.getEnd() >= offset) {
                            region = new Region(right.getStart(), right.getLength());
                        } else {
                            region = null;
                        }

                        String name = left.getText();
                        if (name.equals(""controller"")) {
                            controllerName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""action"")) {
                            actionName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""view"")) {
                            viewName = new NameRegion(right.getText(), region);
                        }
                    }
                }
            }
        }
        return new NameRegion[] { controllerName, actionName, viewName };
    }"
10781;4;6234592;long method;major;2019-07-26 20:16:56.550341;function;org.eclipse.elk.core.meta.ide.contentassist.antlr.internal.InternalMetaDataParser#rule__MdCategory__Group_4_0__1__Impl;git@github.com:eclipse/elk.git;9a87764f00d863463b1be6de1920d8aa3c3ade70;/plugins/org.eclipse.elk.core.meta.ui/src-gen/org/eclipse/elk/core/meta/ide/contentassist/antlr/internal/InternalMetaDataParser.java;22554;22599;https://github.com/eclipse/elk/blob/9a87764f00d863463b1be6de1920d8aa3c3ade70/plugins/org.eclipse.elk.core.meta.ui/src-gen/org/eclipse/elk/core/meta/ide/contentassist/antlr/internal/InternalMetaDataParser.java/#L22554-L22599;1;"    public final void rule__MdCategory__Group_4_0__1__Impl() throws RecognitionException {

        		int stackSize = keepStackSize();
        	
        try {
            // InternalMetaData.g:6468:1: ( ( ( rule__MdCategory__LabelAssignment_4_0_1 ) ) )
            // InternalMetaData.g:6469:1: ( ( rule__MdCategory__LabelAssignment_4_0_1 ) )
            {
            // InternalMetaData.g:6469:1: ( ( rule__MdCategory__LabelAssignment_4_0_1 ) )
            // InternalMetaData.g:6470:2: ( rule__MdCategory__LabelAssignment_4_0_1 )
            {
            if ( state.backtracking==0 ) {
               before(grammarAccess.getMdCategoryAccess().getLabelAssignment_4_0_1()); 
            }
            // InternalMetaData.g:6471:2: ( rule__MdCategory__LabelAssignment_4_0_1 )
            // InternalMetaData.g:6471:3: rule__MdCategory__LabelAssignment_4_0_1
            {
            pushFollow(FOLLOW_2);
            rule__MdCategory__LabelAssignment_4_0_1();

            state._fsp--;
            if (state.failed) return ;

            }

            if ( state.backtracking==0 ) {
               after(grammarAccess.getMdCategoryAccess().getLabelAssignment_4_0_1()); 
            }

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {

            	restoreStackSize(stackSize);

        }
        return ;
    }"
14061;20;4919602;long method;major;2019-09-02 06:43:29.549609;function;org.apache.jmeter.protocol.http.config.gui.UrlConfigGui#configure TestElement;git@github.com:apache/jmeter.git;0facf1525a7d0bd816efd33e72309856e901a883;/src/protocol/http/org/apache/jmeter/protocol/http/config/gui/UrlConfigGui.java;272;314;https://github.com/apache/jmeter/blob/0facf1525a7d0bd816efd33e72309856e901a883/src/protocol/http/org/apache/jmeter/protocol/http/config/gui/UrlConfigGui.java/#L272-L314;1;"    public void configure(TestElement el) {
        setName(el.getName());
        Arguments arguments = (Arguments) el.getProperty(HTTPSamplerBase.ARGUMENTS).getObjectValue();

        boolean useRaw = el.getPropertyAsBoolean(HTTPSamplerBase.POST_BODY_RAW, HTTPSamplerBase.POST_BODY_RAW_DEFAULT);
        if(useRaw) {
            String postBody = computePostBody(arguments, true); // Convert CRLF to CR, see modifyTestElement
            postBodyContent.setInitialText(postBody); 
            postBodyContent.setCaretPosition(0);
            argsPanel.clear();
            postContentTabbedPane.setSelectedIndex(tabRawBodyIndex, false);
        } else {
            postBodyContent.setInitialText("""");
            argsPanel.configure(arguments);
            postContentTabbedPane.setSelectedIndex(TAB_PARAMETERS, false);
        }
        if(showFileUploadPane) {
            filesPanel.configure(el);
        }

        domain.setText(el.getPropertyAsString(HTTPSamplerBase.DOMAIN));

        String portString = el.getPropertyAsString(HTTPSamplerBase.PORT);

        // Only display the port number if it is meaningfully specified
        if (portString.equals(HTTPSamplerBase.UNSPECIFIED_PORT_AS_STRING)) {
            port.setText(""""); // $NON-NLS-1$
        } else {
            port.setText(portString);
        }
        protocol.setText(el.getPropertyAsString(HTTPSamplerBase.PROTOCOL));
        contentEncoding.setText(el.getPropertyAsString(HTTPSamplerBase.CONTENT_ENCODING));
        path.setText(el.getPropertyAsString(HTTPSamplerBase.PATH));
        if (notConfigOnly){
            method.setText(el.getPropertyAsString(HTTPSamplerBase.METHOD));
            followRedirects.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.FOLLOW_REDIRECTS));
            autoRedirects.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.AUTO_REDIRECTS));
            useKeepAlive.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.USE_KEEPALIVE));
            useMultipart.setSelected(el.getPropertyAsBoolean(HTTPSamplerBase.DO_MULTIPART_POST));
            useBrowserCompatibleMultipartMode.setSelected(el.getPropertyAsBoolean(
                    HTTPSamplerBase.BROWSER_COMPATIBLE_MULTIPART, HTTPSamplerBase.BROWSER_COMPATIBLE_MULTIPART_MODE_DEFAULT));
        }
    }"
11463;3;7725645;data class;major;2019-08-04 23:05:51.467002;class;com.vmware.xenon.common.jwt.Header;git@github.com:vmware/xenon.git;b6fb48b745985af2efc59b7ee0e5e7d69a289fbc;/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java;23;30;https://github.com/vmware/xenon/blob/b6fb48b745985af2efc59b7ee0e5e7d69a289fbc/xenon-common/src/main/java/com/vmware/xenon/common/jwt/Header.java/#L23-L30;0;"public class Header {
    @SerializedName(""typ"")
    public String type;
    @SerializedName(""alg"")
    public String algorithm;
    @SerializedName(""cty"")
    public String contentType;
}"
13551;1;6890147;data class;major;2019-08-30 08:07:07.088238;class;com.sun.tools.sjavac.server.SysInfo;git@github.com:google/error-prone-javac.git;a53d069bbdb2c60232ed3811c19b65e41c3e60e0;/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java;45;56;https://github.com/google/error-prone-javac/blob/a53d069bbdb2c60232ed3811c19b65e41c3e60e0/src/jdk.compiler/share/classes/com/sun/tools/sjavac/server/SysInfo.java/#L45-L56;0;"public class SysInfo implements Serializable {

    static final long serialVersionUID = -3096346807579L;

    public int numCores;
    public long maxMemory;

    public SysInfo(int nc, long mm) {
        numCores = nc;
        maxMemory = mm;
    }
}"
2819;22;8965373;data class;none;2019-04-05 12:13:29.455244;class;org.apache.hive.service.rpc.thrift.TArrayTypeEntry.TArrayTypeEntryTupleSchemeFactory;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/service-rpc/src/gen/thrift/gen-javabean/org/apache/hive/service/rpc/thrift/TArrayTypeEntry.java;364;368;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/service-rpc/src/gen/thrift/gen-javabean/org/apache/hive/service/rpc/thrift/TArrayTypeEntry.java/#L364-L368;1;"  private static class TArrayTypeEntryTupleSchemeFactory implements SchemeFactory {
    public TArrayTypeEntryTupleScheme getScheme() {
      return new TArrayTypeEntryTupleScheme();
    }
  }"
14401;4;5023689;long method;major;2019-09-08 21:24:02.919656;function;org.apache.lens.cube.metadata.FactPartition#compareTo FactPartition;git@github.com:apache/lens.git;f64a0f5984216a61f0a2c5ef90510a88390acde0;/lens-cube/src/main/java/org/apache/lens/cube/metadata/FactPartition.java;148;195;https://github.com/apache/lens/blob/f64a0f5984216a61f0a2c5ef90510a88390acde0/lens-cube/src/main/java/org/apache/lens/cube/metadata/FactPartition.java/#L148-L195;0,5;"  public int compareTo(FactPartition o) {
    int colComp = this.partCol.compareTo(o.partCol);
    if (colComp == 0) {
      int partComp = 0;
      if (this.partSpec != null) {
        if (o.partSpec == null) {
          partComp = 1;
        } else {
          partComp = this.partSpec.compareTo(o.partSpec);
        }
      } else {
        if (o.partSpec != null) {
          partComp = -1;
        } else {
          partComp = 0;
        }
      }
      if (partComp == 0) {
        int upComp = 0;
        if (this.period != null && o.period != null) {
          upComp = this.period.compareTo(o.period);
        } else if (this.period == null && o.period == null) {
          upComp = 0;
        } else if (this.period == null) {
          upComp = -1;
        } else {
          upComp = 1;
        }
        if (upComp == 0) {
          if (this.containingPart != null) {
            if (o.containingPart == null) {
              return 1;
            }
            return this.containingPart.compareTo(o.containingPart);
          } else {
            if (o.containingPart != null) {
              return -1;
            } else {
              return 0;
            }
          }
        }
        return upComp;
      }
      return partComp;
    }
    return colComp;
  }"
11556;3;8491397;blob;critical;2019-08-05 12:33:30.478456;class;com.cloud.vm.dao.VMInstanceDao;git@github.com:apache/cloudstack.git;8d3feb100aab4a45b31a789f444038b892161eec;/engine/schema/src/main/java/com/cloud/vm/dao/VMInstanceDao.java;34;155;https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/engine/schema/src/main/java/com/cloud/vm/dao/VMInstanceDao.java/#L34-L155;1;"public interface VMInstanceDao extends GenericDao<VMInstanceVO, Long>, StateDao<State, VirtualMachine.Event, VirtualMachine> {
    /**
     * What are the vms running on this host?
     * @param hostId host.
     * @return list of VMInstanceVO running on that host.
     */
    List<VMInstanceVO> listByHostId(long hostId);

    /**
     * List VMs by zone ID
     * @param zoneId
     * @return list of VMInstanceVO in the specified zone
     */
    List<VMInstanceVO> listByZoneId(long zoneId);

    /**
     * List VMs by pod ID
     * @param podId
     * @return list of VMInstanceVO in the specified pod
     */
    List<VMInstanceVO> listByPodId(long podId);

    /**
     * Lists non-expunged VMs by  templateId
     * @param templateId
     * @return list of VMInstanceVO deployed from the specified template, that are not expunged
     */
    public List<VMInstanceVO> listNonExpungedByTemplate(long templateId);


    /**
     * Lists non-expunged VMs by zone ID and templateId
     * @param zoneId
     * @return list of VMInstanceVO in the specified zone, deployed from the specified template, that are not expunged
     */
    public List<VMInstanceVO> listNonExpungedByZoneAndTemplate(long zoneId, long templateId);

    /**
     * Find vm instance with names like.
     *
     * @param name name that fits SQL like.
     * @return list of VMInstanceVO
     */
    List<VMInstanceVO> findVMInstancesLike(String name);

    List<VMInstanceVO> findVMInTransition(Date time, State... states);

    List<VMInstanceVO> listByHostAndState(long hostId, State... states);

    List<VMInstanceVO> listByTypes(VirtualMachine.Type... types);

    VMInstanceVO findByIdTypes(long id, VirtualMachine.Type... types);

    VMInstanceVO findVMByInstanceName(String name);

    VMInstanceVO findVMByHostName(String hostName);

    void updateProxyId(long id, Long proxyId, Date time);

    List<VMInstanceVO> listByHostIdTypes(long hostid, VirtualMachine.Type... types);

    List<VMInstanceVO> listUpByHostIdTypes(long hostid, VirtualMachine.Type... types);

    List<VMInstanceVO> listByZoneIdAndType(long zoneId, VirtualMachine.Type type);

    List<VMInstanceVO> listUpByHostId(Long hostId);

    List<VMInstanceVO> listByLastHostId(Long hostId);

    List<VMInstanceVO> listByTypeAndState(VirtualMachine.Type type, State state);

    List<VMInstanceVO> listByAccountId(long accountId);

    public List<Long> findIdsOfAllocatedVirtualRoutersForAccount(long accountId);

    List<VMInstanceVO> listByClusterId(long clusterId);  // this does not pull up VMs which are starting

    List<VMInstanceVO> listLHByClusterId(long clusterId);  // get all the VMs even starting one on this cluster

    List<VMInstanceVO> listVmsMigratingFromHost(Long hostId);

    public Long countActiveByHostId(long hostId);

    Pair<List<Long>, Map<Long, Double>> listClusterIdsInZoneByVmCount(long zoneId, long accountId);

    Pair<List<Long>, Map<Long, Double>> listClusterIdsInPodByVmCount(long podId, long accountId);

    Pair<List<Long>, Map<Long, Double>> listPodIdsInZoneByVmCount(long dataCenterId, long accountId);

    List<Long> listHostIdsByVmCount(long dcId, Long podId, Long clusterId, long accountId);

    Long countRunningByAccount(long accountId);

    Long countByZoneAndState(long zoneId, State state);

    List<VMInstanceVO> listNonRemovedVmsByTypeAndNetwork(long networkId, VirtualMachine.Type... types);

    /**
     * @param networkId
     * @param types
     * @return
     */
    List<String> listDistinctHostNames(long networkId, VirtualMachine.Type... types);

    List<VMInstanceVO> findByHostInStates(Long hostId, State... states);

    List<VMInstanceVO> listStartingWithNoHostId();

    boolean updatePowerState(long instanceId, long powerHostId, VirtualMachine.PowerState powerState);

    void resetVmPowerStateTracking(long instanceId);

    void resetHostPowerStateTracking(long hostId);

    HashMap<String, Long> countVgpuVMs(Long dcId, Long podId, Long clusterId);

    VMInstanceVO findVMByHostNameInZone(String hostName, long zoneId);

    boolean isPowerStateUpToDate(long instanceId);

    List<VMInstanceVO> listNonMigratingVmsByHostEqualsLastHost(long hostId);
}"
3830;20;7899540;data class;none;2019-04-05 13:27:12.009837;class;com.facebook.buck.parser.exceptions.BuildTargetException;git@github.com:facebook/buck.git;1bc8d383ea5cb153ca9bf4f2807e6be498648523;/src/com/facebook/buck/parser/exceptions/BuildTargetException.java;20;24;https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/src/com/facebook/buck/parser/exceptions/BuildTargetException.java/#L20-L24;1;"public abstract class BuildTargetException extends BuildFileParseException {
  public BuildTargetException(String message) {
    super(message);
  }
}"
10960;3;5355489;long method;major;2019-08-01 23:29:34.860336;function;org.apache.nifi.processors.media.ExtractMediaMetadata#tika_parse InputStream|String|Integer|Integer;git@github.com:apache/nifi.git;c8eff590efa3babcda0b755009224dcac168708b;/nifi-nar-bundles/nifi-media-bundle/nifi-media-processors/src/main/java/org/apache/nifi/processors/media/ExtractMediaMetadata.java;210;255;https://github.com/apache/nifi/blob/c8eff590efa3babcda0b755009224dcac168708b/nifi-nar-bundles/nifi-media-bundle/nifi-media-processors/src/main/java/org/apache/nifi/processors/media/ExtractMediaMetadata.java/#L210-L255;1;"    private Map<String, String> tika_parse(InputStream sourceStream, String prefix, Integer maxAttribs,
                                           Integer maxAttribLen) throws IOException, TikaException, SAXException {
        final Metadata metadata = new Metadata();
        final TikaInputStream tikaInputStream = TikaInputStream.get(sourceStream);
        try {
            autoDetectParser.parse(tikaInputStream, new DefaultHandler(), metadata);
        } finally {
            tikaInputStream.close();
        }

        final Map<String, String> results = new HashMap<>();
        final Pattern metadataKeyFilter = metadataKeyFilterRef.get();
        final StringBuilder dataBuilder = new StringBuilder();
        for (final String key : metadata.names()) {
            if (metadataKeyFilter != null && !metadataKeyFilter.matcher(key).matches()) {
                continue;
            }
            dataBuilder.setLength(0);
            if (metadata.isMultiValued(key)) {
                for (String val : metadata.getValues(key)) {
                    if (dataBuilder.length() > 1) {
                        dataBuilder.append("", "");
                    }
                    if (dataBuilder.length() + val.length() < maxAttribLen) {
                        dataBuilder.append(val);
                    } else {
                        dataBuilder.append(""..."");
                        break;
                    }
                }
            } else {
                dataBuilder.append(metadata.get(key));
            }
            if (prefix == null) {
                results.put(key, dataBuilder.toString().trim());
            } else {
                results.put(prefix + key, dataBuilder.toString().trim());
            }

            // cutoff at max if provided
            if (maxAttribs != null && results.size() >= maxAttribs) {
                break;
            }
        }
        return results;
    }"
12284;3;5384197;long method;major;2019-08-06 11:44:31.648380;function;org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MultiQueryOptimizer#removeAndReconnect MapReduceOper|MapReduceOper;git@github.com:apache/pig.git;17a4d1795ead1f2b4c62043eaf4739ed39ec2f3f;/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java;1096;1141;https://github.com/apache/pig/blob/17a4d1795ead1f2b4c62043eaf4739ed39ec2f3f/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java/#L1096-L1141;1;"    private void removeAndReconnect(MapReduceOper mr, MapReduceOper newMR) throws VisitorException {
        List<MapReduceOper> mapperSuccs = getPlan().getSuccessors(mr);
        List<MapReduceOper> mapperPreds = getPlan().getPredecessors(mr);

        // make a copy before removing operator
        ArrayList<MapReduceOper> succsCopy = null;
        ArrayList<MapReduceOper> predsCopy = null;
        if (mapperSuccs != null) {
            succsCopy = new ArrayList<MapReduceOper>(mapperSuccs);
        }
        if (mapperPreds != null) {
            predsCopy = new ArrayList<MapReduceOper>(mapperPreds);
        }
        getPlan().remove(mr);

        // reconnect the mapper's successors
        if (succsCopy != null) {
            for (MapReduceOper succ : succsCopy) {
                try {
                    getPlan().connect(newMR, succ);
                } catch (PlanException e) {
                    int errCode = 2133;
                    String msg = ""Internal Error. Unable to connect map plan with successors for optimization."";
                    throw new OptimizerException(msg, errCode, PigException.BUG, e);
                }
            }
        }

        // reconnect the mapper's predecessors
        if (predsCopy != null) {
            for (MapReduceOper pred : predsCopy) {
                if (newMR.getOperatorKey().equals(pred.getOperatorKey())) {
                    continue;
                }
                try {
                    getPlan().connect(pred, newMR);
                } catch (PlanException e) {
                    int errCode = 2134;
                    String msg = ""Internal Error. Unable to connect map plan with predecessors for optimization."";
                    throw new OptimizerException(msg, errCode, PigException.BUG, e);
                }
            }
        }

        mergeMROperProperties(mr, newMR);
    }"
11262;3;8132817;blob;major;2019-08-04 20:01:17.525987;class;org.eclipse.xtext.parser.unorderedGroups.backtrackingBug325745TestLanguage.impl.BacktrackingBug325745TestLanguagePackageImpl;git@github.com:eclipse/xtext-core.git;e04964e4c2a3e0338c0079bd8333688835e77c31;/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parser/unorderedGroups/backtrackingBug325745TestLanguage/impl/BacktrackingBug325745TestLanguagePackageImpl.java;28;426;https://github.com/eclipse/xtext-core/blob/e04964e4c2a3e0338c0079bd8333688835e77c31/org.eclipse.xtext.tests/src-gen/org/eclipse/xtext/parser/unorderedGroups/backtrackingBug325745TestLanguage/impl/BacktrackingBug325745TestLanguagePackageImpl.java/#L28-L426;1;"public class BacktrackingBug325745TestLanguagePackageImpl extends EPackageImpl implements BacktrackingBug325745TestLanguagePackage
{
  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass modelEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass elementEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass dataTypeEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass simpleTermEClass = null;

  /**
   * Creates an instance of the model <b>Package</b>, registered with
   * {@link org.eclipse.emf.ecore.EPackage.Registry EPackage.Registry} by the package
   * package URI value.
   * <p>Note: the correct way to create the package is via the static
   * factory method {@link #init init()}, which also performs
   * initialization of the package, or returns the registered package,
   * if one already exists.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see org.eclipse.emf.ecore.EPackage.Registry
   * @see org.eclipse.xtext.parser.unorderedGroups.backtrackingBug325745TestLanguage.BacktrackingBug325745TestLanguagePackage#eNS_URI
   * @see #init()
   * @generated
   */
  private BacktrackingBug325745TestLanguagePackageImpl()
  {
    super(eNS_URI, BacktrackingBug325745TestLanguageFactory.eINSTANCE);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private static boolean isInited = false;

  /**
   * Creates, registers, and initializes the <b>Package</b> for this model, and for any others upon which it depends.
   * 
   * <p>This method is used to initialize {@link BacktrackingBug325745TestLanguagePackage#eINSTANCE} when that field is accessed.
   * Clients should not invoke it directly. Instead, they should simply access that field to obtain the package.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #eNS_URI
   * @see #createPackageContents()
   * @see #initializePackageContents()
   * @generated
   */
  public static BacktrackingBug325745TestLanguagePackage init()
  {
    if (isInited) return (BacktrackingBug325745TestLanguagePackage)EPackage.Registry.INSTANCE.getEPackage(BacktrackingBug325745TestLanguagePackage.eNS_URI);

    // Obtain or create and register package
    BacktrackingBug325745TestLanguagePackageImpl theBacktrackingBug325745TestLanguagePackage = (BacktrackingBug325745TestLanguagePackageImpl)(EPackage.Registry.INSTANCE.get(eNS_URI) instanceof BacktrackingBug325745TestLanguagePackageImpl ? EPackage.Registry.INSTANCE.get(eNS_URI) : new BacktrackingBug325745TestLanguagePackageImpl());

    isInited = true;

    // Initialize simple dependencies
    EcorePackage.eINSTANCE.eClass();

    // Create package meta-data objects
    theBacktrackingBug325745TestLanguagePackage.createPackageContents();

    // Initialize created meta-data
    theBacktrackingBug325745TestLanguagePackage.initializePackageContents();

    // Mark meta-data to indicate it can't be changed
    theBacktrackingBug325745TestLanguagePackage.freeze();

  
    // Update the registry and return the package
    EPackage.Registry.INSTANCE.put(BacktrackingBug325745TestLanguagePackage.eNS_URI, theBacktrackingBug325745TestLanguagePackage);
    return theBacktrackingBug325745TestLanguagePackage;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EClass getModel()
  {
    return modelEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EReference getModel_Fields()
  {
    return (EReference)modelEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EClass getElement()
  {
    return elementEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getElement_Name()
  {
    return (EAttribute)elementEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EReference getElement_DataType()
  {
    return (EReference)elementEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EReference getElement_Expression()
  {
    return (EReference)elementEClass.getEStructuralFeatures().get(2);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EClass getDataType()
  {
    return dataTypeEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getDataType_BaseType()
  {
    return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getDataType_DefaultValue()
  {
    return (EAttribute)dataTypeEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EClass getExpression()
  {
    return expressionEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getExpression_Prefix()
  {
    return (EAttribute)expressionEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EReference getExpression_Terms()
  {
    return (EReference)expressionEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getExpression_Postfix()
  {
    return (EAttribute)expressionEClass.getEStructuralFeatures().get(2);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EClass getSimpleTerm()
  {
    return simpleTermEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getSimpleTerm_LineCount()
  {
    return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getSimpleTerm_CharCount()
  {
    return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getSimpleTerm_CharSet()
  {
    return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(2);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EAttribute getSimpleTerm_RefChar()
  {
    return (EAttribute)simpleTermEClass.getEStructuralFeatures().get(3);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public BacktrackingBug325745TestLanguageFactory getBacktrackingBug325745TestLanguageFactory()
  {
    return (BacktrackingBug325745TestLanguageFactory)getEFactoryInstance();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private boolean isCreated = false;

  /**
   * Creates the meta-model objects for the package.  This method is
   * guarded to have no affect on any invocation but its first.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public void createPackageContents()
  {
    if (isCreated) return;
    isCreated = true;

    // Create classes and their features
    modelEClass = createEClass(MODEL);
    createEReference(modelEClass, MODEL__FIELDS);

    elementEClass = createEClass(ELEMENT);
    createEAttribute(elementEClass, ELEMENT__NAME);
    createEReference(elementEClass, ELEMENT__DATA_TYPE);
    createEReference(elementEClass, ELEMENT__EXPRESSION);

    dataTypeEClass = createEClass(DATA_TYPE);
    createEAttribute(dataTypeEClass, DATA_TYPE__BASE_TYPE);
    createEAttribute(dataTypeEClass, DATA_TYPE__DEFAULT_VALUE);

    expressionEClass = createEClass(EXPRESSION);
    createEAttribute(expressionEClass, EXPRESSION__PREFIX);
    createEReference(expressionEClass, EXPRESSION__TERMS);
    createEAttribute(expressionEClass, EXPRESSION__POSTFIX);

    simpleTermEClass = createEClass(SIMPLE_TERM);
    createEAttribute(simpleTermEClass, SIMPLE_TERM__LINE_COUNT);
    createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_COUNT);
    createEAttribute(simpleTermEClass, SIMPLE_TERM__CHAR_SET);
    createEAttribute(simpleTermEClass, SIMPLE_TERM__REF_CHAR);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private boolean isInitialized = false;

  /**
   * Complete the initialization of the package and its meta-model.  This
   * method is guarded to have no affect on any invocation but its first.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public void initializePackageContents()
  {
    if (isInitialized) return;
    isInitialized = true;

    // Initialize package
    setName(eNAME);
    setNsPrefix(eNS_PREFIX);
    setNsURI(eNS_URI);

    // Obtain other dependent packages
    EcorePackage theEcorePackage = (EcorePackage)EPackage.Registry.INSTANCE.getEPackage(EcorePackage.eNS_URI);

    // Create type parameters

    // Set bounds for type parameters

    // Add supertypes to classes

    // Initialize classes and features; add operations and parameters
    initEClass(modelEClass, Model.class, ""Model"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getModel_Fields(), this.getElement(), null, ""fields"", null, 0, -1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(elementEClass, Element.class, ""Element"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getElement_Name(), theEcorePackage.getEString(), ""name"", null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getElement_DataType(), this.getDataType(), null, ""dataType"", null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getElement_Expression(), this.getExpression(), null, ""expression"", null, 0, 1, Element.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(dataTypeEClass, DataType.class, ""DataType"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getDataType_BaseType(), theEcorePackage.getEString(), ""baseType"", null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEAttribute(getDataType_DefaultValue(), theEcorePackage.getEString(), ""defaultValue"", null, 0, 1, DataType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionEClass, Expression.class, ""Expression"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpression_Prefix(), theEcorePackage.getEString(), ""prefix"", null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpression_Terms(), this.getSimpleTerm(), null, ""terms"", null, 0, -1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEAttribute(getExpression_Postfix(), theEcorePackage.getEString(), ""postfix"", null, 0, 1, Expression.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(simpleTermEClass, SimpleTerm.class, ""SimpleTerm"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getSimpleTerm_LineCount(), theEcorePackage.getEInt(), ""lineCount"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEAttribute(getSimpleTerm_CharCount(), theEcorePackage.getEInt(), ""charCount"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEAttribute(getSimpleTerm_CharSet(), theEcorePackage.getEString(), ""charSet"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEAttribute(getSimpleTerm_RefChar(), theEcorePackage.getEString(), ""refChar"", null, 0, 1, SimpleTerm.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    // Create resource
    createResource(eNS_URI);
  }

} //BacktrackingBug325745TestLanguagePackageImpl"
2447;3;4124615;blob;major;2019-04-01 14:14:50.588822;class;org.apache.brooklyn.rest.resources.SensorResource;git@github.com:apache/brooklyn-server.git;880eb1da00f6358d7fd76d065322e3685bfb1a04;/rest/rest-resources/src/main/java/org/apache/brooklyn/rest/resources/SensorResource.java;46;183;https://github.com/apache/brooklyn-server/blob/880eb1da00f6358d7fd76d065322e3685bfb1a04/rest/rest-resources/src/main/java/org/apache/brooklyn/rest/resources/SensorResource.java/#L46-L183;1;"@HaHotStateRequired
public class SensorResource extends AbstractBrooklynRestResource implements SensorApi {

    private static final Logger log = LoggerFactory.getLogger(SensorResource.class);

    @Override
    public List<SensorSummary> list(final String application, final String entityToken) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"",
                    Entitlements.getEntitlementContext().user(), entity);
        }

        List<SensorSummary> result = Lists.newArrayList();
        
        for (AttributeSensor<?> sensor : filter(entity.getEntityType().getSensors(), AttributeSensor.class)) {
            // Exclude config that user is not allowed to see
            if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
                log.trace(""User {} not authorized to see sensor {} of entity {}; excluding from AttributeSensor list results"", 
                        new Object[] {Entitlements.getEntitlementContext().user(), sensor.getName(), entity});
                continue;
            }
            result.add(SensorTransformer.sensorSummary(entity, sensor, ui.getBaseUriBuilder()));
        }
        
        return result;
    }

    @Override
    public Map<String, Object> batchSensorRead(final String application, final String entityToken, final Boolean raw) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"",
                    Entitlements.getEntitlementContext().user(), entity);
        }

        Map<String, Object> sensorMap = Maps.newHashMap();
        @SuppressWarnings(""rawtypes"")
        Iterable<AttributeSensor> sensors = filter(entity.getEntityType().getSensors(), AttributeSensor.class);

        for (AttributeSensor<?> sensor : sensors) {
            // Exclude sensors that user is not allowed to see
            if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
                log.trace(""User {} not authorized to see sensor {} of entity {}; excluding from current-state results"", 
                        new Object[] {Entitlements.getEntitlementContext().user(), sensor.getName(), entity});
                continue;
            }

            Object value = entity.getAttribute(findSensor(entity, sensor.getName()));
            sensorMap.put(sensor.getName(), 
                resolving(value).preferJson(true).asJerseyOutermostReturnValue(false).raw(raw).context(entity).timeout(Duration.ZERO).renderAs(sensor).resolve());
        }
        return sensorMap;
    }

    protected Object get(boolean preferJson, String application, String entityToken, String sensorName, Boolean raw) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        AttributeSensor<?> sensor = findSensor(entity, sensorName);
        
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"",
                    Entitlements.getEntitlementContext().user(), entity);
        }
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s' sensor '%s'"",
                    Entitlements.getEntitlementContext().user(), entity, sensor.getName());
        }
        
        Object value = entity.getAttribute(sensor);
        return resolving(value).preferJson(preferJson).asJerseyOutermostReturnValue(true).raw(raw).context(entity).immediately(true).renderAs(sensor).resolve();
    }

    @Override
    public String getPlain(String application, String entityToken, String sensorName, final Boolean raw) {
        return (String) get(false, application, entityToken, sensorName, raw);
    }

    @Override
    public Object get(final String application, final String entityToken, String sensorName, final Boolean raw) {
        return get(true, application, entityToken, sensorName, raw);
    }

    private AttributeSensor<?> findSensor(Entity entity, String name) {
        Sensor<?> s = entity.getEntityType().getSensor(name);
        if (s instanceof AttributeSensor) return (AttributeSensor<?>) s;
        return new BasicAttributeSensor<Object>(Object.class, name);
    }
    
    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    @Override
    public void setFromMap(String application, String entityToken, Map newValues) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"",
                Entitlements.getEntitlementContext().user(), entity);
        }

        if (log.isDebugEnabled())
            log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" setting sensors ""+newValues);
        for (Object entry: newValues.entrySet()) {
            String sensorName = Strings.toString(((Map.Entry)entry).getKey());
            Object newValue = ((Map.Entry)entry).getValue();
            
            AttributeSensor sensor = findSensor(entity, sensorName);
            entity.sensors().set(sensor, newValue);
        }
    }
    
    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    @Override
    public void set(String application, String entityToken, String sensorName, Object newValue) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"",
                Entitlements.getEntitlementContext().user(), entity);
        }
        
        AttributeSensor sensor = findSensor(entity, sensorName);
        if (log.isDebugEnabled())
            log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" setting sensor ""+sensorName+"" to ""+newValue);
        entity.sensors().set(sensor, newValue);
    }
    
    @Override
    public void delete(String application, String entityToken, String sensorName) {
        final Entity entity = brooklyn().getEntity(application, entityToken);
        if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
            throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"",
                Entitlements.getEntitlementContext().user(), entity);
        }
        
        AttributeSensor<?> sensor = findSensor(entity, sensorName);
        if (log.isDebugEnabled())
            log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" deleting sensor ""+sensorName);
        ((EntityInternal)entity).sensors().remove(sensor);
    }
    
}"
14944;20;6257015;data class;major;2019-09-12 09:56:32.100584;class;org.eclipse.hawkbit.HawkbitServerProperties.Build;git@github.com:eclipse/hawkbit.git;51be28147f6f575b6c1ab4a5ef84ffd9174f1209;/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java;75;90;https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90;1;"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }"
13259;1;8791597;long method;major;2019-08-29 12:17:17.075352;function;org.apache.airavata.registry.api.service.handler.RegistryServerHandler#updateExperiment String|ExperimentModel;git@github.com:apache/airavata.git;391843a00eefa7b6213e845f2f044b4e042894d5;/modules/registry/registry-server/registry-api-service/src/main/java/org/apache/airavata/registry/api/service/handler/RegistryServerHandler.java;3124;3178;https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/modules/registry/registry-server/registry-api-service/src/main/java/org/apache/airavata/registry/api/service/handler/RegistryServerHandler.java/#L3124-L3178;1;"    @Override
    public void updateExperiment(String airavataExperimentId, ExperimentModel experiment) throws RegistryServiceException, TException {
        try {
            experimentCatalog = RegistryFactory.getDefaultExpCatalog();
            if (!experimentCatalog.isExist(ExperimentCatalogModelType.EXPERIMENT, airavataExperimentId)) {
                logger.error(airavataExperimentId, ""Update request failed, Experiment {} doesn't exist."", airavataExperimentId);
                throw new RegistryServiceException(""Requested experiment id "" + airavataExperimentId + "" does not exist in the system.."");
            }

            ExperimentStatus experimentStatus = getExperimentStatusInternal(airavataExperimentId);
            if (experimentStatus != null){
                ExperimentState experimentState = experimentStatus.getState();
                switch (experimentState){
                    case CREATED: case VALIDATED:
                        if(experiment.getUserConfigurationData() != null && experiment.getUserConfigurationData()
                                .getComputationalResourceScheduling() != null){
                            String compResourceId = experiment.getUserConfigurationData()
                                    .getComputationalResourceScheduling().getResourceHostId();
                            ComputeResourceDescription computeResourceDescription = appCatalog.getComputeResource()
                                    .getComputeResource(compResourceId);
                            if(!computeResourceDescription.isEnabled()){
                                logger.error(""Compute Resource is not enabled by the Admin!"");
                                AiravataSystemException exception = new AiravataSystemException();
                                exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);
                                exception.setMessage(""Compute Resource is not enabled by the Admin!"");
                                throw exception;
                            }
                        }
                        experimentCatalog.update(ExperimentCatalogModelType.EXPERIMENT, experiment, airavataExperimentId);
                        logger.debug(airavataExperimentId, ""Successfully updated experiment {} "", experiment.getExperimentName());
                        break;
                    default:
                        logger.error(airavataExperimentId, ""Error while updating experiment. Update experiment is only valid for experiments "" +
                                ""with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given "" +
                                ""experiment is in one of above statuses... "");
                        AiravataSystemException exception = new AiravataSystemException();
                        exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);
                        exception.setMessage(""Error while updating experiment. Update experiment is only valid for experiments "" +
                                ""with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given "" +
                                ""experiment is in one of above statuses... "");
                        throw exception;
                }
            }
        } catch (RegistryException e) {
            logger.error(airavataExperimentId, ""Error while updating experiment"", e);
            RegistryServiceException exception = new RegistryServiceException();
            exception.setMessage(""Error while updating experiment. More info : "" + e.getMessage());
            throw exception;
        } catch (AppCatalogException e) {
            logger.error(airavataExperimentId, ""Error while updating experiment"", e);
            RegistryServiceException exception = new RegistryServiceException();
            exception.setMessage(""Error while updating experiment. More info : "" + e.getMessage());
            throw exception;
        }
    }"
796;11;6435518;feature envy;none;2019-03-29 13:11:33.213010;function;org.eclipse.milo.opcua.stack.core.types.structured.QueryNextResponse#getTypeId;git@github.com:eclipse/milo.git;e752e540d31eb3c226e6e79dd197c54d7d254685;/opc-ua-stack/stack-core/src/main/java/org/eclipse/milo/opcua/stack/core/types/structured/QueryNextResponse.java;54;55;https://github.com/eclipse/milo/blob/e752e540d31eb3c226e6e79dd197c54d7d254685/opc-ua-stack/stack-core/src/main/java/org/eclipse/milo/opcua/stack/core/types/structured/QueryNextResponse.java/#L54-L55;1;"    @Override
    public NodeId getTypeId() { return TypeId; }"
1397;10;7476496;blob;none;2019-03-29 13:48:50.399155;class;example.repo.Customer1569Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/repo/Customer1569Repository.java;9;12;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/repo/Customer1569Repository.java/#L9-L12;0;"public interface Customer1569Repository extends CrudRepository<Customer1569, Long> {

	List<Customer1569> findByLastName(String lastName);
}"
14757;4;4431383;data class;major;2019-09-12 08:47:31.187417;class;org.apache.eagle.jpm.util.resourcefetch.model.Applications;git@github.com:apache/eagle.git;7ac9421c2c27d12ae88f001866b4444310fcaa3f;/eagle-jpm/eagle-jpm-util/src/main/java/org/apache/eagle/jpm/util/resourcefetch/model/Applications.java;24;38;https://github.com/apache/eagle/blob/7ac9421c2c27d12ae88f001866b4444310fcaa3f/eagle-jpm/eagle-jpm-util/src/main/java/org/apache/eagle/jpm/util/resourcefetch/model/Applications.java/#L24-L38;0,5;"@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class Applications {

    private List<AppInfo> app;

    public List<AppInfo> getApp() {
        return app;
    }

    public void setApp(List<AppInfo> app) {
        this.app = app;
    }

}"
3219;14;7910247;feature envy;critical;2019-04-05 12:45:31.998883;function;com.facebook.buck.android.resources.ResTableTypeSpec#transformKeyReferences RefTransformer;git@github.com:facebook/buck.git;1bc8d383ea5cb153ca9bf4f2807e6be498648523;/src/com/facebook/buck/android/resources/ResTableTypeSpec.java;166;168;https://github.com/facebook/buck/blob/1bc8d383ea5cb153ca9bf4f2807e6be498648523/src/com/facebook/buck/android/resources/ResTableTypeSpec.java/#L166-L168;1;"  public void transformKeyReferences(RefTransformer visitor) {
    configs.forEach(c -> c.transformKeyReferences(visitor));
  }"
9351;13;9295088;feature envy;critical;2019-07-23 16:05:21.110474;function;sun.nio.fs.WindowsSecurity.openProcessToken int;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.base/windows/classes/sun/nio/fs/WindowsSecurity.java;39;45;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.base/windows/classes/sun/nio/fs/WindowsSecurity.java/#L39-L45;1;"    private static long openProcessToken(int access) {
        try {
            return OpenProcessToken(GetCurrentProcess(), access);
        } catch (WindowsException x) {
            return 0L;
        }
    }"
12534;3;4788662;long method;major;2019-08-06 16:49:26.842996;function;org.apache.sentry.provider.db.service.thrift.TListSentryPrivilegesRequest#equals TListSentryPrivilegesRequest;git@github.com:apache/incubator-sentry.git;4643f988a5e0ce2b9749e6365edea3a16482de86;/sentry-provider/sentry-provider-db/src/gen/thrift/gen-javabean/org/apache/sentry/provider/db/service/thrift/TListSentryPrivilegesRequest.java;360;401;https://github.com/apache/incubator-sentry/blob/4643f988a5e0ce2b9749e6365edea3a16482de86/sentry-provider/sentry-provider-db/src/gen/thrift/gen-javabean/org/apache/sentry/provider/db/service/thrift/TListSentryPrivilegesRequest.java/#L360-L401;0;"  public boolean equals(TListSentryPrivilegesRequest that) {
    if (that == null)
      return false;

    boolean this_present_protocol_version = true;
    boolean that_present_protocol_version = true;
    if (this_present_protocol_version || that_present_protocol_version) {
      if (!(this_present_protocol_version && that_present_protocol_version))
        return false;
      if (this.protocol_version != that.protocol_version)
        return false;
    }

    boolean this_present_requestorUserName = true && this.isSetRequestorUserName();
    boolean that_present_requestorUserName = true && that.isSetRequestorUserName();
    if (this_present_requestorUserName || that_present_requestorUserName) {
      if (!(this_present_requestorUserName && that_present_requestorUserName))
        return false;
      if (!this.requestorUserName.equals(that.requestorUserName))
        return false;
    }

    boolean this_present_roleName = true && this.isSetRoleName();
    boolean that_present_roleName = true && that.isSetRoleName();
    if (this_present_roleName || that_present_roleName) {
      if (!(this_present_roleName && that_present_roleName))
        return false;
      if (!this.roleName.equals(that.roleName))
        return false;
    }

    boolean this_present_authorizableHierarchy = true && this.isSetAuthorizableHierarchy();
    boolean that_present_authorizableHierarchy = true && that.isSetAuthorizableHierarchy();
    if (this_present_authorizableHierarchy || that_present_authorizableHierarchy) {
      if (!(this_present_authorizableHierarchy && that_present_authorizableHierarchy))
        return false;
      if (!this.authorizableHierarchy.equals(that.authorizableHierarchy))
        return false;
    }

    return true;
  }"
2061;3;8564277;blob;none;2019-04-01 12:42:11.200430;class;org.apache.hadoop.hbase.client.Cancellable;git@github.com:apache/hbase.git;44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f;/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Cancellable.java;27;31;https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Cancellable.java/#L27-L31;1;"@InterfaceAudience.Private
interface Cancellable {
  public void cancel();
  public boolean isCancelled();
}"
4555;20;8934300;long method;major;2019-04-12 13:07:03.993055;function;org.apache.hadoop.hive.ql.optimizer.calcite.cost.HiveOnTezCostModel.TezBucketJoinAlgorithm#getCost HiveJoin;git@github.com:apache/hive.git;2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53;/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/cost/HiveOnTezCostModel.java;414;464;https://github.com/apache/hive/blob/2fa22bf360898dc8fd1408bfcc96e1c6aeaf9a53/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/cost/HiveOnTezCostModel.java/#L414-L464;1;"    @Override
    public RelOptCost getCost(HiveJoin join) {
      final RelMetadataQuery mq = join.getCluster().getMetadataQuery();
      // 1. Sum of input cardinalities
      final Double leftRCount = mq.getRowCount(join.getLeft());
      final Double rightRCount = mq.getRowCount(join.getRight());
      if (leftRCount == null || rightRCount == null) {
        return null;
      }
      final double rCount = leftRCount + rightRCount;
      // 2. CPU cost = HashTable  construction  cost  +
      //               join cost
      ImmutableList<Double> cardinalities = new ImmutableList.Builder<Double>().
              add(leftRCount).
              add(rightRCount).
              build();
      ImmutableBitSet.Builder streamingBuilder = ImmutableBitSet.builder();
      switch (join.getStreamingSide()) {
        case LEFT_RELATION:
          streamingBuilder.set(0);
          break;
        case RIGHT_RELATION:
          streamingBuilder.set(1);
          break;
        default:
          return null;
      }
      ImmutableBitSet streaming = streamingBuilder.build();
      final double cpuCost = algoUtils.computeBucketMapJoinCPUCost(cardinalities, streaming);
      // 3. IO cost = cost of transferring small tables to join node *
      //              degree of parallelism
      final Double leftRAverageSize = mq.getAverageRowSize(join.getLeft());
      final Double rightRAverageSize = mq.getAverageRowSize(join.getRight());
      if (leftRAverageSize == null || rightRAverageSize == null) {
        return null;
      }
      ImmutableList<Pair<Double,Double>> relationInfos = new ImmutableList.Builder<Pair<Double,Double>>().
              add(new Pair<Double,Double>(leftRCount,leftRAverageSize)).
              add(new Pair<Double,Double>(rightRCount,rightRAverageSize)).
              build();
      //TODO: No Of buckets is not same as no of splits
      JoinAlgorithm oldAlgo = join.getJoinAlgorithm();
      join.setJoinAlgorithm(TezBucketJoinAlgorithm.INSTANCE);
      final int parallelism = mq.splitCount(join) == null
              ? 1 : mq.splitCount(join);
      join.setJoinAlgorithm(oldAlgo);

      final double ioCost = algoUtils.computeBucketMapJoinIOCost(relationInfos, streaming, parallelism);
      // 4. Result
      return HiveCost.FACTORY.makeCost(rCount, cpuCost, ioCost);
    }"
14087;21;6487817;feature envy;none;2019-09-02 08:35:00.932576;function;com.ibm.j9ddr.vm29.types.U32#add UDATA;git@github.com:eclipse/openj9.git;4911084853eb75b20e037c434ad4521b7317ebfb;/debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/types/U32.java;70;72;https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/types/U32.java/#L70-L72;1;"	public UDATA add(UDATA parameter) {
		return new UDATA(this).add(parameter);
	}"
838;4;6492213;feature envy;none;2019-03-29 13:15:35.980024;function;org.eclipse.rdf4j.query.algebra.IRIFunction.IRIFunction ValueExpr;git@github.com:eclipse/rdf4j.git;6f63df540e30b28e0c8880bea72f85cb88424b03;/queryalgebra-model/src/main/java/org/eclipse/rdf4j/query/algebra/IRIFunction.java;27;29;https://github.com/eclipse/rdf4j/blob/6f63df540e30b28e0c8880bea72f85cb88424b03/queryalgebra-model/src/main/java/org/eclipse/rdf4j/query/algebra/IRIFunction.java/#L27-L29;1;"	public IRIFunction(ValueExpr arg) {
		super(arg);
	}"
14568;4;9260596;data class;major;2019-09-11 15:11:22.599961;class;com.sun.org.apache.xerces.internal.impl.xpath.regex.Op.ModifierOp;git@github.com:SAP/SapMachine.git;6e62561730c46dc5000c39665c43951832192ceb;/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xpath/regex/Op.java;204;218;https://github.com/SAP/SapMachine/blob/6e62561730c46dc5000c39665c43951832192ceb/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xpath/regex/Op.java/#L204-L218;1;"    static class ModifierOp extends ChildOp {
        final int v1;
        final int v2;
        ModifierOp(int type, int v1, int v2) {
            super(type);
            this.v1 = v1;
            this.v2 = v2;
        }
        int getData() {
            return this.v1;
        }
        int getData2() {
            return this.v2;
        }
    }"
2745;5;3939400;blob;none;2019-04-05 12:08:40.149667;class;org.apache.aries.subsystem.example.helloIsolation.HelloIsolation;git@github.com:apache/aries.git;52293d20268de7c98833846ded2b70d6476773de;/subsystem/subsystem-example/subsystem-helloIsolation/src/main/java/org/apache/aries/subsystem/example/helloIsolation/HelloIsolation.java;19;23;https://github.com/apache/aries/blob/52293d20268de7c98833846ded2b70d6476773de/subsystem/subsystem-example/subsystem-helloIsolation/src/main/java/org/apache/aries/subsystem/example/helloIsolation/HelloIsolation.java/#L19-L23;1;"public interface HelloIsolation
{
  public void hello();
  public void checkPermission(final Permission permission) throws SecurityException;
}"
1807;10;8226389;feature envy;major;2019-03-29 14:21:37.850688;function;org.eclipse.xtext.parser.assignments.idea.highlighting.AssignmentsTestLanguageBaseColorSettingsPage#getDisplayName;git@github.com:eclipse/xtext-idea.git;3aa1424ae35f1942dd7c3a457057006f9131de5e;/org.eclipse.xtext.core.idea.tests/src-gen/org/eclipse/xtext/parser/assignments/idea/highlighting/AssignmentsTestLanguageBaseColorSettingsPage.java;13;16;https://github.com/eclipse/xtext-idea/blob/3aa1424ae35f1942dd7c3a457057006f9131de5e/org.eclipse.xtext.core.idea.tests/src-gen/org/eclipse/xtext/parser/assignments/idea/highlighting/AssignmentsTestLanguageBaseColorSettingsPage.java/#L13-L16;0;"	@Override
	public String getDisplayName() {
		return AssignmentsTestLanguageLanguage.INSTANCE.getDisplayName();
	}"
10805;4;8334291;blob;major;2019-07-26 20:29:42.368065;class;org.aspectj.apache.bcel.classfile.AttributeUtils;git@github.com:eclipse/org.aspectj.git;370f291c359cd159c5f3f0abd6e9e53e81234a07;/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/AttributeUtils.java;9;99;https://github.com/eclipse/org.aspectj/blob/370f291c359cd159c5f3f0abd6e9e53e81234a07/bcel-builder/src/main/java/org/aspectj/apache/bcel/classfile/AttributeUtils.java/#L9-L99;1;"public class AttributeUtils {

	public static Attribute[] readAttributes(DataInputStream dataInputstream, ConstantPool cpool) {
		try {
			int length = dataInputstream.readUnsignedShort();
			if (length == 0) {
				return Attribute.NoAttributes;
			}
			Attribute[] attrs = new Attribute[length];
			for (int i = 0; i < length; i++) {
				attrs[i] = Attribute.readAttribute(dataInputstream, cpool);
			}
			return attrs;
		} catch (IOException e) {
			throw new ClassFormatException(""IOException whilst reading set of attributes: "" + e.toString());
		}
	}

	/** Write (serialize) a set of attributes into a specified output stream */
	public static void writeAttributes(Attribute[] attributes, DataOutputStream file) throws IOException {
		if (attributes == null) {
			file.writeShort(0);
		} else {
			file.writeShort(attributes.length);
			for (int i = 0; i < attributes.length; i++) {
				attributes[i].dump(file);
			}
		}
	}

	public static Signature getSignatureAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SIGNATURE) {
				return (Signature) attributes[i];
			}
		}
		return null;
	}

	public static Code getCodeAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_CODE) {
				return (Code) attributes[i];
			}
		}
		return null;
	}

	public static ExceptionTable getExceptionTableAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_EXCEPTIONS) {
				return (ExceptionTable) attributes[i];
			}
		}
		return null;
	}

	public static ConstantValue getConstantValueAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].getTag() == Constants.ATTR_CONSTANT_VALUE) {
				return (ConstantValue) attributes[i];
			}
		}
		return null;
	}

	public static void accept(Attribute[] attributes, ClassVisitor visitor) {
		for (int i = 0; i < attributes.length; i++) {
			attributes[i].accept(visitor);
		}
	}

	public static boolean hasSyntheticAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SYNTHETIC) {
				return true;
			}
		}
		return false;
	}

	public static SourceFile getSourceFileAttribute(Attribute[] attributes) {
		for (int i = 0; i < attributes.length; i++) {
			if (attributes[i].tag == Constants.ATTR_SOURCE_FILE) {
				return (SourceFile) attributes[i];
			}
		}
		return null;
	}

}"
3138;20;6186813;feature envy;none;2019-04-05 12:37:55.511064;function;org.eclipse.che.core.metrics.ApiResponseMetricFilter#init FilterConfig;git@github.com:eclipse/che.git;c5498c2ac562cd8a2fc79a6bb0446d291f05a201;/core/che-core-metrics-core/src/main/java/org/eclipse/che/core/metrics/ApiResponseMetricFilter.java;40;41;https://github.com/eclipse/che/blob/c5498c2ac562cd8a2fc79a6bb0446d291f05a201/core/che-core-metrics-core/src/main/java/org/eclipse/che/core/metrics/ApiResponseMetricFilter.java/#L40-L41;1;"  @Override
  public void init(FilterConfig filterConfig) throws ServletException {}"
2679;3;4600851;long method;none;2019-04-02 06:51:06.845574;function;org.apache.giraph.examples.SimpleCheckpoint.SimpleCheckpointVertexWorkerContext#postSuperstep;git@github.com:apache/giraph.git;d3bf4a2cf5347f7cfd9d217b216c906cb7801217;/giraph-examples/src/main/java/org/apache/giraph/examples/SimpleCheckpoint.java;182;183;https://github.com/apache/giraph/blob/d3bf4a2cf5347f7cfd9d217b216c906cb7801217/giraph-examples/src/main/java/org/apache/giraph/examples/SimpleCheckpoint.java/#L182-L183;1;"    @Override
    public void postSuperstep() { }"
1607;5;7747098;blob;major;2019-03-29 14:04:16.441196;class;org.apache.brooklyn.util.text.StringFunctions;git@github.com:apache/incubator-brooklyn.git;337a5d22d5e9c98cc96ea1085383cbed1ee0b741;/brooklyn-server/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java;32;415;https://github.com/apache/incubator-brooklyn/blob/337a5d22d5e9c98cc96ea1085383cbed1ee0b741/brooklyn-server/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java/#L32-L415;1;"public class StringFunctions {

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,String> appendOld(final String suffix) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            @Nullable
            public String apply(@Nullable String input) {
                if (input==null) return null;
                return input + suffix;
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,String> prependOld(final String prefix) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            @Nullable
            public String apply(@Nullable String input) {
                if (input==null) return null;
                return prefix + input;
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Object, String> formatterOld(final String pattern) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Object, String>() {
            public String apply(@Nullable Object input) {
                return String.format(pattern, input);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Object[], String> formatterForArrayOld(final String pattern) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Object[], String>() {
            public String apply(@Nullable Object[] input) {
                return String.format(pattern, input);
            }
        };
    }
    
    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Iterable<?>, String> joinerOld(final String separator) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Iterable<?>, String>() {
            public String apply(@Nullable Iterable<?> input) {
                return Strings.join(input, separator);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<Object[], String> joinerForArrayOld(final String separator) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<Object[], String>() {
            public String apply(@Nullable Object[] input) {
                if (input == null) return Strings.EMPTY;
                return Strings.join(input, separator);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,Integer> lengthOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String,Integer>() {
            @Override
            public Integer apply(@Nullable String input) {
                if (input == null) return -1;
                return input.length();
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String,String> surroundOld(final String prefix, final String suffix) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String,String>() {
            @Override
            public String apply(@Nullable String input) {
                if (input == null) return null;
                return prefix+input+suffix;
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> trimOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(@Nullable String input) {
                if (input == null) return null;
                if (Strings.isBlank(input)) return Strings.EMPTY;
                return CharMatcher.BREAKING_WHITESPACE.trimFrom(input);
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> toLowerCaseOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(String input) {
                return input.toLowerCase();
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> toUpperCaseOld() {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(String input) {
                return input.toUpperCase();
            }
        };
    }

    /** @deprecated since 0.9.0 kept only to allow conversion of anonymous inner classes */
    @SuppressWarnings(""unused"") @Deprecated 
    private static Function<String, String> convertCaseOld(final CaseFormat src, final CaseFormat target) {
        // TODO PERSISTENCE WORKAROUND
        return new Function<String, String>() {
            @Override
            public String apply(String input) {
                return src.to(target, input);
            }
        };
    }

    public static Function<String,String> append(final String suffix) {
        return new AppendFunction(checkNotNull(suffix, ""suffix""));
    }

    private static class AppendFunction implements Function<String, String> {
        private final String suffix;

        public AppendFunction(String suffix) {
            this.suffix = suffix;
        }
        @Override
        @Nullable
        public String apply(@Nullable String input) {
            if (input==null) return null;
            return input + suffix;
        }
    };

    public static Function<String,String> prepend(final String prefix) {
        return new PrependFunction(checkNotNull(prefix, ""prefix""));
    }
    
    protected static class PrependFunction implements Function<String, String> {
        private final String prefix;

        public PrependFunction(String prefix) {
            this.prefix = prefix;
        }

        @Override
        @Nullable
        public String apply(@Nullable String input) {
            if (input==null) return null;
            return prefix + input;
        }
    }

    /** given e.g. ""hello %s"" returns a function which will insert a string into that pattern */
    public static Function<Object, String> formatter(final String pattern) {
        return new FormatterFunction(pattern);
    }

    protected static class FormatterFunction implements Function<Object, String> {
        private final String pattern;
        
        FormatterFunction(String pattern) {
            this.pattern = pattern;
        }
        public String apply(@Nullable Object input) {
            return String.format(pattern, input);
        }
    };

    /** given e.g. ""hello %s %s"" returns a function which will insert an array of two strings into that pattern */
    public static Function<Object[], String> formatterForArray(final String pattern) {
        return new FormatterForArrayFunction(checkNotNull(pattern, ""pattern""));
    }
    
    protected static class FormatterForArrayFunction implements Function<Object[], String> {
        private final String pattern;
        
        public FormatterForArrayFunction(String pattern) {
            this.pattern = pattern;
        }
        public String apply(@Nullable Object[] input) {
            return String.format(pattern, input);
        }
    }
    
    /** 
     * Given e.g. ""hello %s %s"" returns a function which will insert an Iterable of two strings into that pattern
     * 
     * @since 0.9.0
     */
    public static Function<Iterable<?>, String> formatterForIterable(final String pattern) {
        return new FormatterForIterableFunction(pattern);
    }

    protected static class FormatterForIterableFunction implements Function<Iterable<?>, String> {
        final String pattern;

        public FormatterForIterableFunction(String pattern) {
            this.pattern = pattern;
        }

        public String apply(@Nullable Iterable<?> input) {
            Object[] arr = (input == null) ? null : Iterables.toArray(input, Object.class);
            return String.format(pattern, arr);
        }
    }

    /** joins the given objects in a collection as a toString with the given separator */
    public static Function<Iterable<?>, String> joiner(final String separator) {
        return new JoinerFunction(separator);
    }

    private static class JoinerFunction implements Function<Iterable<?>, String> {
        private final String separator;

        public JoinerFunction(String separator) {
            this.separator = separator;
        }
        public String apply(@Nullable Iterable<?> input) {
            return Strings.join(input, separator);
        }
    }
    
    /** joins the given objects as a toString with the given separator, but expecting an array of objects, not a collection */
    public static Function<Object[], String> joinerForArray(final String separator) {
        return new JoinerForArrayFunction(checkNotNull(separator, ""separator""));
    }

    private static class JoinerForArrayFunction implements Function<Object[], String> {
        private final String separator;

        protected JoinerForArrayFunction(String separator) {
            this.separator = separator;
        }
        public String apply(@Nullable Object[] input) {
            if (input == null) return Strings.EMPTY;
            return Strings.join(input, separator);
        }
    }

    /** provided here as a convenience; prefer {@link Functions#toStringFunction()} */
    public static Function<Object,String> toStringFunction() {
        return Functions.toStringFunction();
    }

    /** returns function which gives length of input, with -1 for nulls */
    public static Function<String,Integer> length() {
        return new LengthFunction();
    }

    protected static class LengthFunction implements Function<String,Integer> {
        @Override
        public Integer apply(@Nullable String input) {
            if (input == null) return -1;
            return input.length();
        }
    }

    /** Surrounds an input string with the given prefix and suffix */
    public static Function<String,String> surround(final String prefix, final String suffix) {
        Preconditions.checkNotNull(prefix);
        Preconditions.checkNotNull(suffix);
        return new SurroundFunction(prefix, suffix);
    }
    
    protected static class SurroundFunction implements Function<String,String> {
        private final String prefix;
        private final String suffix;
        public SurroundFunction(String prefix, String suffix) {
            this.prefix = prefix;
            this.suffix = suffix;
        }
        @Override
        public String apply(@Nullable String input) {
            if (input == null) return null;
            return prefix+input+suffix;
        }
    }

    public static Function<String, String> trim() {
        return new TrimFunction();
    }
    
    protected static class TrimFunction implements Function<String, String> {
        @Override
        public String apply(@Nullable String input) {
            if (input == null) return null;
            if (Strings.isBlank(input)) return Strings.EMPTY;
            return CharMatcher.BREAKING_WHITESPACE.trimFrom(input);
        }
    }

    public static Function<String, String> toLowerCase() {
        return new LowerCaseFunction();
    }
    
    protected static class LowerCaseFunction implements Function<String, String> {
        @Override
        public String apply(String input) {
            return input.toLowerCase();
        }
    }

    public static Function<String, String> toUpperCase() {
        return new UpperCaseFunction();
    }
    
    protected static class UpperCaseFunction implements Function<String, String> {
        @Override
        public String apply(String input) {
            return input.toUpperCase();
        }
    }

    public static Function<String, String> convertCase(final CaseFormat src, final CaseFormat target) {
        return new ConvertCaseFunction(checkNotNull(src, ""src""), checkNotNull(target, ""target""));
    }
    
    protected static class ConvertCaseFunction implements Function<String, String> {
       private final CaseFormat src;
       private final CaseFormat target;

       public ConvertCaseFunction(CaseFormat src, CaseFormat target) {
          this.src = src;
          this.target = target;
       }

       @Override
       public String apply(String input) {
          return src.to(target, input);
       }
    }

    public static class RegexReplacer implements Function<String, String> {
        private final String pattern;
        private final String replacement;

        public RegexReplacer(String pattern, String replacement) {
            this.pattern = pattern;
            this.replacement = replacement;
        }

        @Nullable
        @Override
        public String apply(@Nullable String s) {
            return Strings.replaceAllRegex(s, pattern, replacement);
        }
    }
}"
5328;5;7372240;blob;critical;2019-04-12 15:12:40.538189;class;org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer;git@github.com:spring-projects/spring-boot.git;2225b362991f225e3a93f00e160526d2b8abdfb2;/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/annotation/EndpointDiscoverer.java;67;532;https://github.com/spring-projects/spring-boot/blob/2225b362991f225e3a93f00e160526d2b8abdfb2/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/annotation/EndpointDiscoverer.java/#L67-L532;1;"public abstract class EndpointDiscoverer<E extends ExposableEndpoint<O>, O extends Operation>
		implements EndpointsSupplier<E> {

	private final ApplicationContext applicationContext;

	private final Collection<EndpointFilter<E>> filters;

	private final DiscoveredOperationsFactory<O> operationsFactory;

	private final Map<EndpointBean, E> filterEndpoints = new ConcurrentHashMap<>();

	private volatile Collection<E> endpoints;

	/**
	 * Create a new {@link EndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param filters filters to apply
	 */
	public EndpointDiscoverer(ApplicationContext applicationContext,
			ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<E>> filters) {
		Assert.notNull(applicationContext, ""ApplicationContext must not be null"");
		Assert.notNull(parameterValueMapper, ""ParameterValueMapper must not be null"");
		Assert.notNull(invokerAdvisors, ""InvokerAdvisors must not be null"");
		Assert.notNull(filters, ""Filters must not be null"");
		this.applicationContext = applicationContext;
		this.filters = Collections.unmodifiableCollection(filters);
		this.operationsFactory = getOperationsFactory(parameterValueMapper,
				invokerAdvisors);
	}

	private DiscoveredOperationsFactory<O> getOperationsFactory(
			ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors) {
		return new DiscoveredOperationsFactory<O>(parameterValueMapper, invokerAdvisors) {

			@Override
			protected O createOperation(EndpointId endpointId,
					DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
				return EndpointDiscoverer.this.createOperation(endpointId,
						operationMethod, invoker);
			}

		};
	}

	@Override
	public final Collection<E> getEndpoints() {
		if (this.endpoints == null) {
			this.endpoints = discoverEndpoints();
		}
		return this.endpoints;
	}

	private Collection<E> discoverEndpoints() {
		Collection<EndpointBean> endpointBeans = createEndpointBeans();
		addExtensionBeans(endpointBeans);
		return convertToEndpoints(endpointBeans);
	}

	private Collection<EndpointBean> createEndpointBeans() {
		Map<EndpointId, EndpointBean> byId = new LinkedHashMap<>();
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(
				this.applicationContext, Endpoint.class);
		for (String beanName : beanNames) {
			if (!ScopedProxyUtils.isScopedTarget(beanName)) {
				EndpointBean endpointBean = createEndpointBean(beanName);
				EndpointBean previous = byId.putIfAbsent(endpointBean.getId(),
						endpointBean);
				Assert.state(previous == null,
						() -> ""Found two endpoints with the id '"" + endpointBean.getId()
								+ ""': '"" + endpointBean.getBeanName() + ""' and '""
								+ previous.getBeanName() + ""'"");
			}
		}
		return byId.values();
	}

	private EndpointBean createEndpointBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new EndpointBean(beanName, bean);
	}

	private void addExtensionBeans(Collection<EndpointBean> endpointBeans) {
		Map<EndpointId, EndpointBean> byId = endpointBeans.stream()
				.collect(Collectors.toMap(EndpointBean::getId, Function.identity()));
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(
				this.applicationContext, EndpointExtension.class);
		for (String beanName : beanNames) {
			ExtensionBean extensionBean = createExtensionBean(beanName);
			EndpointBean endpointBean = byId.get(extensionBean.getEndpointId());
			Assert.state(endpointBean != null,
					() -> (""Invalid extension '"" + extensionBean.getBeanName()
							+ ""': no endpoint found with id '""
							+ extensionBean.getEndpointId() + ""'""));
			addExtensionBean(endpointBean, extensionBean);
		}
	}

	private ExtensionBean createExtensionBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new ExtensionBean(beanName, bean);
	}

	private void addExtensionBean(EndpointBean endpointBean,
			ExtensionBean extensionBean) {
		if (isExtensionExposed(endpointBean, extensionBean)) {
			Assert.state(
					isEndpointExposed(endpointBean) || isEndpointFiltered(endpointBean),
					() -> ""Endpoint bean '"" + endpointBean.getBeanName()
							+ ""' cannot support the extension bean '""
							+ extensionBean.getBeanName() + ""'"");
			endpointBean.addExtension(extensionBean);
		}
	}

	private Collection<E> convertToEndpoints(Collection<EndpointBean> endpointBeans) {
		Set<E> endpoints = new LinkedHashSet<>();
		for (EndpointBean endpointBean : endpointBeans) {
			if (isEndpointExposed(endpointBean)) {
				endpoints.add(convertToEndpoint(endpointBean));
			}
		}
		return Collections.unmodifiableSet(endpoints);
	}

	private E convertToEndpoint(EndpointBean endpointBean) {
		MultiValueMap<OperationKey, O> indexed = new LinkedMultiValueMap<>();
		EndpointId id = endpointBean.getId();
		addOperations(indexed, id, endpointBean.getBean(), false);
		if (endpointBean.getExtensions().size() > 1) {
			String extensionBeans = endpointBean.getExtensions().stream()
					.map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(
					""Found multiple extensions for the endpoint bean ""
							+ endpointBean.getBeanName() + "" ("" + extensionBeans + "")"");
		}
		for (ExtensionBean extensionBean : endpointBean.getExtensions()) {
			addOperations(indexed, id, extensionBean.getBean(), true);
		}
		assertNoDuplicateOperations(endpointBean, indexed);
		List<O> operations = indexed.values().stream().map(this::getLast)
				.filter(Objects::nonNull).collect(Collectors.collectingAndThen(
						Collectors.toList(), Collections::unmodifiableList));
		return createEndpoint(endpointBean.getBean(), id,
				endpointBean.isEnabledByDefault(), operations);
	}

	private void addOperations(MultiValueMap<OperationKey, O> indexed, EndpointId id,
			Object target, boolean replaceLast) {
		Set<OperationKey> replacedLast = new HashSet<>();
		Collection<O> operations = this.operationsFactory.createOperations(id, target);
		for (O operation : operations) {
			OperationKey key = createOperationKey(operation);
			O last = getLast(indexed.get(key));
			if (replaceLast && replacedLast.add(key) && last != null) {
				indexed.get(key).remove(last);
			}
			indexed.add(key, operation);
		}
	}

	private <T> T getLast(List<T> list) {
		return CollectionUtils.isEmpty(list) ? null : list.get(list.size() - 1);
	}

	private void assertNoDuplicateOperations(EndpointBean endpointBean,
			MultiValueMap<OperationKey, O> indexed) {
		List<OperationKey> duplicates = indexed.entrySet().stream()
				.filter((entry) -> entry.getValue().size() > 1).map(Map.Entry::getKey)
				.collect(Collectors.toList());
		if (!duplicates.isEmpty()) {
			Set<ExtensionBean> extensions = endpointBean.getExtensions();
			String extensionBeanNames = extensions.stream()
					.map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(
					""Unable to map duplicate endpoint operations: ""
							+ duplicates.toString() + "" to "" + endpointBean.getBeanName()
							+ (extensions.isEmpty() ? """"
									: "" ("" + extensionBeanNames + "")""));
		}
	}

	private boolean isExtensionExposed(EndpointBean endpointBean,
			ExtensionBean extensionBean) {
		return isFilterMatch(extensionBean.getFilter(), endpointBean)
				&& isExtensionExposed(extensionBean.getBean());
	}

	/**
	 * Determine if an extension bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param extensionBean the extension bean
	 * @return {@code true} if the extension is exposed
	 */
	protected boolean isExtensionExposed(Object extensionBean) {
		return true;
	}

	private boolean isEndpointExposed(EndpointBean endpointBean) {
		return isFilterMatch(endpointBean.getFilter(), endpointBean)
				&& !isEndpointFiltered(endpointBean)
				&& isEndpointExposed(endpointBean.getBean());
	}

	/**
	 * Determine if an endpoint bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param endpointBean the endpoint bean
	 * @return {@code true} if the endpoint is exposed
	 */
	protected boolean isEndpointExposed(Object endpointBean) {
		return true;
	}

	private boolean isEndpointFiltered(EndpointBean endpointBean) {
		for (EndpointFilter<E> filter : this.filters) {
			if (!isFilterMatch(filter, endpointBean)) {
				return true;
			}
		}
		return false;
	}

	@SuppressWarnings(""unchecked"")
	private boolean isFilterMatch(Class<?> filter, EndpointBean endpointBean) {
		if (!isEndpointExposed(endpointBean.getBean())) {
			return false;
		}
		if (filter == null) {
			return true;
		}
		E endpoint = getFilterEndpoint(endpointBean);
		Class<?> generic = ResolvableType.forClass(EndpointFilter.class, filter)
				.resolveGeneric(0);
		if (generic == null || generic.isInstance(endpoint)) {
			EndpointFilter<E> instance = (EndpointFilter<E>) BeanUtils
					.instantiateClass(filter);
			return isFilterMatch(instance, endpoint);
		}
		return false;

	}

	private boolean isFilterMatch(EndpointFilter<E> filter, EndpointBean endpointBean) {
		return isFilterMatch(filter, getFilterEndpoint(endpointBean));
	}

	@SuppressWarnings(""unchecked"")
	private boolean isFilterMatch(EndpointFilter<E> filter, E endpoint) {
		return LambdaSafe.callback(EndpointFilter.class, filter, endpoint)
				.withLogger(EndpointDiscoverer.class).invokeAnd((f) -> f.match(endpoint))
				.get();
	}

	private E getFilterEndpoint(EndpointBean endpointBean) {
		E endpoint = this.filterEndpoints.get(endpointBean);
		if (endpoint == null) {
			endpoint = createEndpoint(endpointBean.getBean(), endpointBean.getId(),
					endpointBean.isEnabledByDefault(), Collections.emptySet());
			this.filterEndpoints.put(endpointBean, endpoint);
		}
		return endpoint;
	}

	@SuppressWarnings(""unchecked"")
	protected Class<? extends E> getEndpointType() {
		return (Class<? extends E>) ResolvableType
				.forClass(EndpointDiscoverer.class, getClass()).resolveGeneric(0);
	}

	/**
	 * Factory method called to create the {@link ExposableEndpoint endpoint}.
	 * @param endpointBean the source endpoint bean
	 * @param id the ID of the endpoint
	 * @param enabledByDefault if the endpoint is enabled by default
	 * @param operations the endpoint operations
	 * @return a created endpoint (a {@link DiscoveredEndpoint} is recommended)
	 */
	protected abstract E createEndpoint(Object endpointBean, EndpointId id,
			boolean enabledByDefault, Collection<O> operations);

	/**
	 * Factory method to create an {@link Operation endpoint operation}.
	 * @param endpointId the endpoint id
	 * @param operationMethod the operation method
	 * @param invoker the invoker to use
	 * @return a created operation
	 */
	protected abstract O createOperation(EndpointId endpointId,
			DiscoveredOperationMethod operationMethod, OperationInvoker invoker);

	/**
	 * Create an {@link OperationKey} for the given operation.
	 * @param operation the source operation
	 * @return the operation key
	 */
	protected abstract OperationKey createOperationKey(O operation);

	/**
	 * A key generated for an {@link Operation} based on specific criteria from the actual
	 * operation implementation.
	 */
	protected static final class OperationKey {

		private final Object key;

		private final Supplier<String> description;

		/**
		 * Create a new {@link OperationKey} instance.
		 * @param key the underlying key for the operation
		 * @param description a human readable description of the key
		 */
		public OperationKey(Object key, Supplier<String> description) {
			Assert.notNull(key, ""Key must not be null"");
			Assert.notNull(description, ""Description must not be null"");
			this.key = key;
			this.description = description;
		}

		@Override
		public boolean equals(Object obj) {
			if (obj == this) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.key.equals(((OperationKey) obj).key);
		}

		@Override
		public int hashCode() {
			return this.key.hashCode();
		}

		@Override
		public String toString() {
			return this.description.get();
		}

	}

	/**
	 * Information about an {@link Endpoint @Endpoint} bean.
	 */
	private static class EndpointBean {

		private final String beanName;

		private final Object bean;

		private final EndpointId id;

		private boolean enabledByDefault;

		private final Class<?> filter;

		private Set<ExtensionBean> extensions = new LinkedHashSet<>();

		EndpointBean(String beanName, Object bean) {
			AnnotationAttributes attributes = AnnotatedElementUtils
					.findMergedAnnotationAttributes(bean.getClass(), Endpoint.class, true,
							true);
			String id = attributes.getString(""id"");
			Assert.state(StringUtils.hasText(id),
					() -> ""No @Endpoint id attribute specified for ""
							+ bean.getClass().getName());
			this.beanName = beanName;
			this.bean = bean;
			this.id = EndpointId.of(id);
			this.enabledByDefault = (Boolean) attributes.get(""enableByDefault"");
			this.filter = getFilter(this.bean.getClass());
		}

		public void addExtension(ExtensionBean extensionBean) {
			this.extensions.add(extensionBean);
		}

		public Set<ExtensionBean> getExtensions() {
			return this.extensions;
		}

		private Class<?> getFilter(Class<?> type) {
			AnnotationAttributes attributes = AnnotatedElementUtils
					.getMergedAnnotationAttributes(type, FilteredEndpoint.class);
			if (attributes == null) {
				return null;
			}
			return attributes.getClass(""value"");
		}

		public String getBeanName() {
			return this.beanName;
		}

		public Object getBean() {
			return this.bean;
		}

		public EndpointId getId() {
			return this.id;
		}

		public boolean isEnabledByDefault() {
			return this.enabledByDefault;
		}

		public Class<?> getFilter() {
			return this.filter;
		}

	}

	/**
	 * Information about an {@link EndpointExtension EndpointExtension} bean.
	 */
	private static class ExtensionBean {

		private final String beanName;

		private final Object bean;

		private final EndpointId endpointId;

		private final Class<?> filter;

		ExtensionBean(String beanName, Object bean) {
			this.bean = bean;
			this.beanName = beanName;
			AnnotationAttributes attributes = AnnotatedElementUtils
					.getMergedAnnotationAttributes(bean.getClass(),
							EndpointExtension.class);
			Class<?> endpointType = attributes.getClass(""endpoint"");
			AnnotationAttributes endpointAttributes = AnnotatedElementUtils
					.findMergedAnnotationAttributes(endpointType, Endpoint.class, true,
							true);
			Assert.state(endpointAttributes != null, () -> ""Extension ""
					+ endpointType.getName() + "" does not specify an endpoint"");
			this.endpointId = EndpointId.of(endpointAttributes.getString(""id""));
			this.filter = attributes.getClass(""filter"");
		}

		public String getBeanName() {
			return this.beanName;
		}

		public Object getBean() {
			return this.bean;
		}

		public EndpointId getEndpointId() {
			return this.endpointId;
		}

		public Class<?> getFilter() {
			return this.filter;
		}

	}

}"
11928;3;6487817;long method;none;2019-08-05 22:02:31.407123;function;com.ibm.j9ddr.vm29.types.U32#add UDATA;git@github.com:eclipse/openj9.git;4911084853eb75b20e037c434ad4521b7317ebfb;/debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/types/U32.java;70;72;https://github.com/eclipse/openj9/blob/4911084853eb75b20e037c434ad4521b7317ebfb/debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/types/U32.java/#L70-L72;1;"	public UDATA add(UDATA parameter) {
		return new UDATA(this).add(parameter);
	}"
6625;3;3764238;blob;major;2019-05-20 08:50:46.523399;class;com.amazon.pay.response.parser.Parser;git@github.com:amzn/amazon-pay-sdk-java.git;5a3547d00c796aab8f0c8ac12e0310f7a5c4678a;/src/com/amazon/pay/response/parser/Parser.java;57;252;https://github.com/amzn/amazon-pay-sdk-java/blob/5a3547d00c796aab8f0c8ac12e0310f7a5c4678a/src/com/amazon/pay/response/parser/Parser.java/#L57-L252;1;"public class Parser {

    public static GetOrderReferenceDetailsResponseData getOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {
        final GetOrderReferenceDetailsResponse response = marshalXML(GetOrderReferenceDetailsResponse.class, rawResponse);
        return new GetOrderReferenceDetailsResponseData(response, rawResponse);
    }


    public static SetOrderReferenceDetailsResponseData setOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {
        final SetOrderReferenceDetailsResponse response = marshalXML(SetOrderReferenceDetailsResponse.class, rawResponse);
        return new SetOrderReferenceDetailsResponseData(response, rawResponse);
    }


    public static AuthorizeResponseData getAuthorizeData(ResponseData rawResponse) throws AmazonServiceException {
        final AuthorizeResponse response = marshalXML(AuthorizeResponse.class, rawResponse);
        return new AuthorizeResponseData(response, rawResponse);
    }

    public static GetAuthorizationDetailsResponseData getAuthorizationDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetAuthorizationDetailsResponse response = marshalXML(GetAuthorizationDetailsResponse.class, rawResponse);
        return new GetAuthorizationDetailsResponseData(response, rawResponse);
    }

    public static CaptureResponseData getCapture(ResponseData rawResponse) throws AmazonServiceException {
        final CaptureResponse response = marshalXML(CaptureResponse.class, rawResponse);
        return new CaptureResponseData(response, rawResponse);
    }

    public static GetCaptureDetailsResponseData getCaptureDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetCaptureDetailsResponse response = marshalXML(GetCaptureDetailsResponse.class, rawResponse);
        return new GetCaptureDetailsResponseData(response, rawResponse);
    }

    public static ConfirmOrderReferenceResponseData confirmOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final ConfirmOrderReferenceResponse response = marshalXML(ConfirmOrderReferenceResponse.class, rawResponse);
        return new ConfirmOrderReferenceResponseData(response, rawResponse);
    }

    public static CloseAuthorizationResponseData closeAuthorizationResponse(ResponseData rawResponse) throws AmazonServiceException {
        final CloseAuthorizationResponse response = marshalXML(CloseAuthorizationResponse.class, rawResponse);
        return new CloseAuthorizationResponseData(response, rawResponse);
    }

    public static CancelOrderReferenceResponseData getCancelOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final CancelOrderReferenceResponse response = marshalXML(CancelOrderReferenceResponse.class, rawResponse);
        return new CancelOrderReferenceResponseData(response, rawResponse);
    }

    public static CloseOrderReferenceResponseData getCloseOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final CloseOrderReferenceResponse response = marshalXML(CloseOrderReferenceResponse.class, rawResponse);
        return new CloseOrderReferenceResponseData(response, rawResponse);
    }

    public static RefundResponseData getRefundData(ResponseData rawResponse) throws AmazonServiceException {
        final RefundResponse response = marshalXML(RefundResponse.class, rawResponse);
        return new RefundResponseData(response, rawResponse);
    }

    public static GetRefundDetailsResponseData getRefundDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetRefundDetailsResponse response = marshalXML(GetRefundDetailsResponse.class, rawResponse);
        return new GetRefundDetailsResponseData(response, rawResponse);
    }

    public static GetBillingAgreementDetailsResponseData getBillingAgreementDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetBillingAgreementDetailsResponse response = marshalXML(GetBillingAgreementDetailsResponse.class, rawResponse);
        return new GetBillingAgreementDetailsResponseData(response, rawResponse);
    }

    public static SetBillingAgreementDetailsResponseData getSetBillingAgreementDetailsResponse(ResponseData rawResponse) throws AmazonServiceException {
        final SetBillingAgreementDetailsResponse response = marshalXML(SetBillingAgreementDetailsResponse.class, rawResponse);
        return new SetBillingAgreementDetailsResponseData(response, rawResponse);
    }

    public static ValidateBillingAgreementResponseData getValidateBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
        final ValidateBillingAgreementResponse response = marshalXML(ValidateBillingAgreementResponse.class, rawResponse);
        return new ValidateBillingAgreementResponseData(response, rawResponse);
    }

    public static ConfirmBillingAgreementResponseData confirmBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
        final ConfirmBillingAgreementResponse response = marshalXML(ConfirmBillingAgreementResponse.class, rawResponse);
        return new ConfirmBillingAgreementResponseData(response, rawResponse);
    }

    public static AuthorizeOnBillingAgreementResponseData getAuthorizeOnBillingAgreement(ResponseData rawResponse) throws AmazonServiceException {
        final AuthorizeOnBillingAgreementResponse response = marshalXML(AuthorizeOnBillingAgreementResponse.class, rawResponse);
        return new AuthorizeOnBillingAgreementResponseData(response, rawResponse);
    }

    public static CloseBillingAgreementResponseData closeBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
        final CloseBillingAgreementResponse response = marshalXML(CloseBillingAgreementResponse.class, rawResponse);
        return new CloseBillingAgreementResponseData(response, rawResponse);
    }

    public static GetProviderCreditDetailsResponseData getGetProviderCreditDetails(ResponseData rawResponse) throws AmazonServiceException {
        final GetProviderCreditDetailsResponse response = marshalXML(GetProviderCreditDetailsResponse.class, rawResponse);
        return new GetProviderCreditDetailsResponseData(response, rawResponse);
    }

    public static GetProviderCreditReversalDetailsResponseData getProviderCreditReversalDetails(ResponseData rawResponse) throws AmazonServiceException {
        final GetProviderCreditReversalDetailsResponse response = marshalXML(GetProviderCreditReversalDetailsResponse.class, rawResponse);
        return new GetProviderCreditReversalDetailsResponseData(response, rawResponse);
    }

    public static ReverseProviderCreditResponseData getReverseProviderCreditResponseData(ResponseData rawResponse) throws AmazonServiceException {
        final ReverseProviderCreditResponse response = marshalXML(ReverseProviderCreditResponse.class, rawResponse);
        return new ReverseProviderCreditResponseData(response, rawResponse);
    }

    public static GetServiceStatusResponseData getServiceStatus(
                ResponseData rawResponse) throws AmazonServiceException {
        final GetServiceStatusResponse response = marshalXML(
                GetServiceStatusResponse.class, rawResponse);
        return new GetServiceStatusResponseData(response, rawResponse);
    }

    public static CreateOrderReferenceForIdResponseData createOrderReferenceForId(
                ResponseData rawResponse) throws AmazonServiceException {
        final CreateOrderReferenceForIdResponse response = marshalXML(
                CreateOrderReferenceForIdResponse.class, rawResponse);
        return new CreateOrderReferenceForIdResponseData(response, rawResponse);
    }

    public static ListOrderReferenceResponseData listOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final ListOrderReferenceResponse response = marshalXML(ListOrderReferenceResponse.class, rawResponse);
        return new ListOrderReferenceResponseData(response, rawResponse);
    }

    public static ListOrderReferenceByNextTokenResponseData listOrderReferenceByNextToken(ResponseData rawResponse) throws AmazonServiceException {
        final ListOrderReferenceByNextTokenResponse response = marshalXML(ListOrderReferenceByNextTokenResponse.class, rawResponse);
        return new ListOrderReferenceByNextTokenResponseData(response, rawResponse);
    }

    public static SetOrderAttributesResponseData setOrderAttributes(ResponseData rawResponse) throws AmazonServiceException {
        final SetOrderAttributesResponse response = marshalXML(SetOrderAttributesResponse.class, rawResponse);
        return new SetOrderAttributesResponseData(response, rawResponse);
    }

    public static GetMerchantAccountStatusResponseData getMerchantAccountStatus(ResponseData rawResponse) throws AmazonServiceException {
        final GetMerchantAccountStatusResponse response = marshalXML(GetMerchantAccountStatusResponse.class, rawResponse);
        return new GetMerchantAccountStatusResponseData(response, rawResponse);
    }

    public static <T> T marshalXML(Class<T> clazz, ResponseData rawResponse) throws AmazonServiceException  {
        try {
            if (rawResponse.getStatusCode() == 200) {
                T responseObject = null;
                final JAXBContext context = JAXBContext.newInstance(clazz);

                // Ignore the namespace only for marshalling purpose
                final String noNamespaceXML = rawResponse.toXML().replaceAll(
                        ""xmlns(?:.*?)?=\""http://mws.amazonservices.com/schema/OffAmazonPayments/2013-01-01\"""", """");
                final StringReader reader = new StringReader(noNamespaceXML);
                final Unmarshaller unmarshaller = context.createUnmarshaller();

                final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
                xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
                final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);
                responseObject = (T) unmarshaller.unmarshal(xmlStreamReader);

                return responseObject;
            } else {
                generateErrorException(rawResponse);
            }
        } catch (JAXBException e) {
            throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
        }
        catch (XMLStreamException e) {
            throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
        }

        return null;
    }

    public static void generateErrorException(ResponseData rawResponse) throws AmazonServiceException, JAXBException {
        final JAXBContext context = JAXBContext.newInstance(ErrorResponse.class);

        // Ignore the namespace only for marshalling purpose
        final String noNamespaceXML = rawResponse.toXML().replaceAll(
                ""xmlns(?:.*?)?=\""http://mws.amazonservices.com/schema/OffAmazonPayments/2013-01-01\"""", """");
        final StringReader reader = new StringReader(noNamespaceXML);
        final Unmarshaller unmarshaller = context.createUnmarshaller();

        final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
        xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        try {
            final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);
            final ErrorResponse result = (ErrorResponse) unmarshaller.unmarshal(xmlStreamReader);
            throw new AmazonServiceException(result, rawResponse);
        } catch (XMLStreamException e) {
            throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
        }
    }
}"
886;11;6546622;feature envy;none;2019-03-29 13:18:47.337450;function;org.eclipse.n4js.semver.services.SemverGrammarAccess#getWILDCARDAccess;git@github.com:eclipse/n4js.git;f715912fce0352ab574ff878086f77d17a78c908;/plugins/org.eclipse.n4js.semver/src-gen/org/eclipse/n4js/semver/services/SemverGrammarAccess.java;1703;1705;https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.semver/src-gen/org/eclipse/n4js/semver/services/SemverGrammarAccess.java/#L1703-L1705;1;"	public WILDCARDElements getWILDCARDAccess() {
		return pWILDCARD;
	}"
12454;3;6060474;long method;major;2019-08-06 16:34:40.476359;function;org.eclipse.ceylon.compiler.java.loader.CeylonEnter#main List<JCCompilationUnit>;git@github.com:eclipse/ceylon.git;d3994d6cd120c4df85952cd9432123b413cfd65a;/compiler-java/src/org/eclipse/ceylon/compiler/java/loader/CeylonEnter.java;203;255;https://github.com/eclipse/ceylon/blob/d3994d6cd120c4df85952cd9432123b413cfd65a/compiler-java/src/org/eclipse/ceylon/compiler/java/loader/CeylonEnter.java/#L203-L255;1;"    @Override
    public void main(List<JCCompilationUnit> trees) {
        // complete the javac AST with a completed ceylon model
        timer.startTask(""prepareForTypeChecking"");
        prepareForTypeChecking(trees);
        timer.endTask();
        List<JCCompilationUnit> javaTrees = List.nil();
        List<JCCompilationUnit> ceylonTrees = List.nil();
        // split them in two sets: java and ceylon
        for(JCCompilationUnit tree : trees){
            if(tree instanceof CeylonCompilationUnit)
                ceylonTrees = ceylonTrees.prepend(tree);
            else
                javaTrees = javaTrees.prepend(tree);
        }
        timer.startTask(""Enter on Java trees"");
        boolean needsModelReset = isBootstrap;
        // enter java trees first to set up their ClassSymbol objects for ceylon trees to use during type-checking
        if(!javaTrees.isEmpty()){
            setupImportedPackagesForJavaTrees(javaTrees);
            hasJavaAndCeylonSources = true;
            needsModelReset = true;
        }
        // this is false if we're in an APT round where we did not generate the trees
        if(!compiler.isAddModuleTrees()){
            setupImportedPackagesForJavaTrees(ceylonTrees);
        }
        if(isBootstrap || hasJavaAndCeylonSources){
            super.main(trees);
        }
        // now we can type-check the Ceylon code
        List<JCCompilationUnit> packageInfo = completeCeylonTrees(trees);
        trees = trees.prependList(packageInfo);
        ceylonTrees = ceylonTrees.prependList(packageInfo);
        
        if(compiler.isHadRunTwiceException()){
            needsModelReset = true;
        }
        if(needsModelReset){
            // bootstrapping the language module is a bit more complex
            resetAndRunEnterAgain(trees);
        }else{
            timer.startTask(""Enter on Ceylon trees"");
            // and complete their new trees
            try {
                sourceLanguage.push(Language.CEYLON);
                super.main(ceylonTrees);
            } finally {
                sourceLanguage.pop();
            }
            timer.endTask();
        }
    }"
1419;1;7483890;feature envy;none;2019-03-29 13:50:06.922280;function;example.service.Customer970Service.Customer970Service Customer970Repository;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer970Service.java;9;10;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer970Service.java/#L9-L10;0;"	public Customer970Service(Customer970Repository repo) {
	}"
1192;5;7215246;long method;none;2019-03-29 13:35:14.287972;function;com.rabbitmq.client.impl.AMQChannel#toString;git@github.com:rabbitmq/rabbitmq-java-client.git;8bc24bdce4da758f7be4f4451a46ab185058b272;/src/main/java/com/rabbitmq/client/impl/AMQChannel.java;380;382;https://github.com/rabbitmq/rabbitmq-java-client/blob/8bc24bdce4da758f7be4f4451a46ab185058b272/src/main/java/com/rabbitmq/client/impl/AMQChannel.java/#L380-L382;1;"    @Override public String toString() {
        return ""AMQChannel("" + _connection + "","" + _channelNumber + "")"";
    }"
3733;16;8845555;data class;none;2019-04-05 13:21:48.003936;class;org.apache.airavata.api.Airavata.registerDataProduct_result.registerDataProduct_resultStandardSchemeFactory;git@github.com:apache/airavata.git;391843a00eefa7b6213e845f2f044b4e042894d5;/airavata-api/airavata-api-stubs/src/main/java/org/apache/airavata/api/Airavata.java;251296;251300;https://github.com/apache/airavata/blob/391843a00eefa7b6213e845f2f044b4e042894d5/airavata-api/airavata-api-stubs/src/main/java/org/apache/airavata/api/Airavata.java/#L251296-L251300;1;"    private static class registerDataProduct_resultStandardSchemeFactory implements SchemeFactory {
      public registerDataProduct_resultStandardScheme getScheme() {
        return new registerDataProduct_resultStandardScheme();
      }
    }"
12700;3;5499603;long method;major;2019-08-06 20:32:44.537114;function;org.apache.rocketmq.console.service.impl.ConsumerServiceImpl#resetOffset ResetOffsetRequest;git@github.com:apache/rocketmq-externals.git;dba6eb0c997d5c325f26b3d1da9d739d927228dc;/rocketmq-console/src/main/java/org/apache/rocketmq/console/service/impl/ConsumerServiceImpl.java;208;251;https://github.com/apache/rocketmq-externals/blob/dba6eb0c997d5c325f26b3d1da9d739d927228dc/rocketmq-console/src/main/java/org/apache/rocketmq/console/service/impl/ConsumerServiceImpl.java/#L208-L251;1;"    @Override
    @MultiMQAdminCmdMethod
    public Map<String, ConsumerGroupRollBackStat> resetOffset(ResetOffsetRequest resetOffsetRequest) {
        Map<String, ConsumerGroupRollBackStat> groupRollbackStats = Maps.newHashMap();
        for (String consumerGroup : resetOffsetRequest.getConsumerGroupList()) {
            try {
                Map<MessageQueue, Long> rollbackStatsMap =
                    mqAdminExt.resetOffsetByTimestamp(resetOffsetRequest.getTopic(), consumerGroup, resetOffsetRequest.getResetTime(), resetOffsetRequest.isForce());
                ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
                List<RollbackStats> rollbackStatsList = consumerGroupRollBackStat.getRollbackStatsList();
                for (Map.Entry<MessageQueue, Long> rollbackStatsEntty : rollbackStatsMap.entrySet()) {
                    RollbackStats rollbackStats = new RollbackStats();
                    rollbackStats.setRollbackOffset(rollbackStatsEntty.getValue());
                    rollbackStats.setQueueId(rollbackStatsEntty.getKey().getQueueId());
                    rollbackStats.setBrokerName(rollbackStatsEntty.getKey().getBrokerName());
                    rollbackStatsList.add(rollbackStats);
                }
                groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
            }
            catch (MQClientException e) {
                if (ResponseCode.CONSUMER_NOT_ONLINE == e.getResponseCode()) {
                    try {
                        ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
                        List<RollbackStats> rollbackStatsList = mqAdminExt.resetOffsetByTimestampOld(consumerGroup, resetOffsetRequest.getTopic(), resetOffsetRequest.getResetTime(), true);
                        consumerGroupRollBackStat.setRollbackStatsList(rollbackStatsList);
                        groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
                        continue;
                    }
                    catch (Exception err) {
                        logger.error(""op=resetOffset_which_not_online_error"", err);
                    }
                }
                else {
                    logger.error(""op=resetOffset_error"", e);
                }
                groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
            }
            catch (Exception e) {
                logger.error(""op=resetOffset_error"", e);
                groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
            }
        }
        return groupRollbackStats;
    }"
8254;3;4256584;feature envy;major;2019-07-18 15:36:33.345206;function;org.apache.commons.net.discard.DiscardUDPClient#send byte[]|int|InetAddress|int;git@github.com:apache/commons-net.git;fb7aae4c64f7d2bf6dced00c49c3ffc428b2d572;/src/main/java/org/apache/commons/net/discard/DiscardUDPClient.java;63;71;https://github.com/apache/commons-net/blob/fb7aae4c64f7d2bf6dced00c49c3ffc428b2d572/src/main/java/org/apache/commons/net/discard/DiscardUDPClient.java/#L63-L71;1;"    public void send(byte[] data, int length, InetAddress host, int port)
    throws IOException
    {
        _sendPacket.setData(data);
        _sendPacket.setLength(length);
        _sendPacket.setAddress(host);
        _sendPacket.setPort(port);
        _socket_.send(_sendPacket);
    }"
10881;1;7307669;data class;major;2019-07-29 12:11:01.793336;class;org.springframework.batch.admin.web.resources.DefaultResourceService;git@github.com:spring-projects/spring-batch-admin.git;9e3ad8bff99b8fad8da62426aa7d2959eb841bcf;/spring-batch-admin-resources/src/main/java/org/springframework/batch/admin/web/resources/DefaultResourceService.java;23;38;https://github.com/spring-projects/spring-batch-admin/blob/9e3ad8bff99b8fad8da62426aa7d2959eb841bcf/spring-batch-admin-resources/src/main/java/org/springframework/batch/admin/web/resources/DefaultResourceService.java/#L23-L38;0;"public class DefaultResourceService implements ResourceService {

	private String servletPath = """";
	
	/**
	 * @param servletPath the servletPath to set
	 */
	public void setServletPath(String servletPath) {
		this.servletPath = servletPath;
	}

	public String getServletPath() {
		return servletPath;
	}

}"
14193;20;3812473;data class;major;2019-09-04 10:20:26.757949;class;org.apache.activemq.artemis.core.protocol.stomp.StompFrame.Header;git@github.com:apache/activemq-artemis.git;5bd5c610195d6f4a3dd1ac28170727003f8a5a54;/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java;158;175;https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompFrame.java/#L158-L175;1;"   public class Header {

      public String key;
      public String val;

      public Header(String key, String val) {
         this.key = key;
         this.val = val;
      }

      public String getEncodedKey() {
         return encode(key);
      }

      public String getEncodedValue() {
         return encode(val);
      }
   }"
4035;20;5055368;data class;major;2019-04-05 15:12:22.864987;class;org.apache.jena.sparql.util.IsoMatcher.Cause;git@github.com:apache/jena.git;1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77;/jena-arq/src/main/java/org/apache/jena/sparql/util/IsoMatcher.java;113;122;https://github.com/apache/jena/blob/1cca775bbf0bb0fd3ee8ac55e31f0f30cdde3b77/jena-arq/src/main/java/org/apache/jena/sparql/util/IsoMatcher.java/#L113-L122;1;"    static class Cause {
        final Tuple<Node> tuple ;
        final Mapping     mapping ;

        public Cause(Tuple<Node> tuple, Mapping mapping) {
            super() ;
            this.tuple = tuple ;
            this.mapping = mapping ;
        }
    }"
13750;1;4542224;blob;major;2019-08-30 12:17:22.770532;class;org.apache.fineract.integrationtests.common.Utils;git@github.com:apache/fineract.git;210e380df3ca5c74c8c2fa09e7fe1cffdb87e20a;/fineract-provider/src/integrationTest/java/org/apache/fineract/integrationtests/common/Utils.java;46;198;https://github.com/apache/fineract/blob/210e380df3ca5c74c8c2fa09e7fe1cffdb87e20a/fineract-provider/src/integrationTest/java/org/apache/fineract/integrationtests/common/Utils.java/#L46-L198;1;"@SuppressWarnings(""unchecked"")
public class Utils {

    public static final String TENANT_IDENTIFIER = ""tenantIdentifier=default"";

    public static final String TENANT_TIME_ZONE = ""Asia/Kolkata"";

    private static final String LOGIN_URL = ""/fineract-provider/api/v1/authentication?username=mifos&password=password&"" + TENANT_IDENTIFIER;

    public static void initializeRESTAssured() {
        RestAssured.baseURI = ""https://localhost"";
        RestAssured.port = 8443;
        RestAssured.keystore(""src/main/resources/keystore.jks"", ""openmf"");
    }

    public static String loginIntoServerAndGetBase64EncodedAuthenticationKey() {
        try {
            System.out.println(""-----------------------------------LOGIN-----------------------------------------"");
            final String json = RestAssured.post(LOGIN_URL).asString();
            assertThat(""Failed to login into fineract platform"", StringUtils.isBlank(json), is(false));
            return JsonPath.with(json).get(""base64EncodedAuthenticationKey"");
        } catch (final Exception e) {
            if (e instanceof HttpHostConnectException) {
                final HttpHostConnectException hh = (HttpHostConnectException) e;
                fail(""Failed to connect to fineract platform:"" + hh.getMessage());
            }

            throw new RuntimeException(e);
        }
    }

    public static <T> T performServerGet(final RequestSpecification requestSpec, final ResponseSpecification responseSpec,
            final String getURL, final String jsonAttributeToGetBack) {
        final String json = given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().get(getURL).andReturn().asString();
        if (jsonAttributeToGetBack == null) { return (T) json; }
        return (T) from(json).get(jsonAttributeToGetBack);
    }

    public static String performGetTextResponse(final RequestSpecification requestSpec, final ResponseSpecification responseSpec,
                                                final String getURL){
        return given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().get(getURL).andReturn().asString();
    }

    public static byte[] performGetBinaryResponse(final RequestSpecification requestSpec, final ResponseSpecification responseSpec,
                                                final String getURL){
        return given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().get(getURL).andReturn().asByteArray();
    }

    public static <T> T performServerPost(final RequestSpecification requestSpec, final ResponseSpecification responseSpec,
            final String postURL, final String jsonBodyToSend, final String jsonAttributeToGetBack) {
        final String json = given().spec(requestSpec).body(jsonBodyToSend).expect().spec(responseSpec).log().ifError().when().post(postURL)
                .andReturn().asString();
        if (jsonAttributeToGetBack == null) { return (T) json; }
        return (T) from(json).get(jsonAttributeToGetBack);
    }

    public static <T> T performServerPut(final RequestSpecification requestSpec, final ResponseSpecification responseSpec,
            final String putURL, final String jsonBodyToSend, final String jsonAttributeToGetBack) {
        final String json = given().spec(requestSpec).body(jsonBodyToSend).expect().spec(responseSpec).log().ifError().when().put(putURL)
                .andReturn().asString();
        return (T) from(json).get(jsonAttributeToGetBack);
    }

    public static <T> T performServerDelete(final RequestSpecification requestSpec, final ResponseSpecification responseSpec,
            final String deleteURL, final String jsonAttributeToGetBack) {
        final String json = given().spec(requestSpec).expect().spec(responseSpec).log().ifError().when().delete(deleteURL).andReturn()
                .asString();
        return (T) from(json).get(jsonAttributeToGetBack);
    }

    public static String convertDateToURLFormat(final String dateToBeConvert) {
        final SimpleDateFormat oldFormat = new SimpleDateFormat(""dd MMMMMM yyyy"", Locale.US);
        final SimpleDateFormat newFormat = new SimpleDateFormat(""yyyy-MM-dd"");
        String reformattedStr = """";
        try {
            reformattedStr = newFormat.format(oldFormat.parse(dateToBeConvert));
        } catch (final ParseException e) {
            e.printStackTrace();
        }
        return reformattedStr;
    }

    public static String randomStringGenerator(final String prefix, final int len, final String sourceSetString) {
        final int lengthOfSource = sourceSetString.length();
        final Random rnd = new Random();
        final StringBuilder sb = new StringBuilder(len);
        for (int i = 0; i < len; i++) {
            sb.append((sourceSetString).charAt(rnd.nextInt(lengthOfSource)));
        }
        return (prefix + (sb.toString()));
    }

    public static String randomStringGenerator(final String prefix, final int len) {
        return randomStringGenerator(prefix, len, ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"");
    }

    public static String randomNameGenerator(final String prefix, final int lenOfRandomSuffix) {
        return randomStringGenerator(prefix, lenOfRandomSuffix);
    }
    public static Long randomNumberGenerator(final int expectedLength){
       final String source=""1234567890"";
       final int lengthofSource=source.length();
       final Random random=new Random();
       StringBuilder stringBuilder=new StringBuilder(expectedLength);
        for (int i = 0; i < expectedLength; i++) {
            stringBuilder.append(source.charAt(random.nextInt(lengthofSource)));
        }
        return Long.parseLong(stringBuilder.toString());
    }

    public static String convertDateToURLFormat(final Calendar dateToBeConvert) {
        DateFormat dateFormat = new SimpleDateFormat(""dd MMMMMM yyyy"");
        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());
        return dateFormat.format(dateToBeConvert.getTime());
    }

    public static LocalDate getLocalDateOfTenant() {
        LocalDate today = new LocalDate();
        final DateTimeZone zone = DateTimeZone.forID(TENANT_TIME_ZONE);
        if (zone != null) {
            today = new LocalDate(zone);
        }
        return today;
    }

    public static TimeZone getTimeZoneOfTenant() {
        return TimeZone.getTimeZone(TENANT_TIME_ZONE);
    }

    public static String performServerTemplatePost(final RequestSpecification requestSpec,final ResponseSpecification responseSpec,
                                                   final String postURL,final String legalFormType,final File file,final String locale,final String dateFormat) {

        final String importDocumentId=given().spec(requestSpec)
                .queryParam(""legalFormType"",legalFormType)
                .multiPart(""file"",file)
                .formParam(""locale"",locale)
                .formParam(""dateFormat"",dateFormat)
                .expect().spec(responseSpec).
                log().ifError().when().post(postURL)
                .andReturn().asString();
        return importDocumentId;
    }

    public static String performServerOutputTemplateLocationGet(final RequestSpecification requestSpec,final ResponseSpecification responseSpec,
                                                                final String getURL,final String importDocumentId){
        final String templateLocation=given().spec(requestSpec).
                queryParam(""importDocumentId"",importDocumentId)
                .expect().spec(responseSpec)
                .log().ifError().when().get(getURL)
                .andReturn().asString();
        return templateLocation.substring(1,templateLocation.length()-1);
    }
}"
13658;1;4436948;feature envy;major;2019-08-30 11:09:01.822093;function;org.apache.falcon.entity.FeedHelper.getImportInitalInstance org.apache.falcon.entity.v0.feed.Cluster;git@github.com:apache/falcon.git;470e5e9f5de9ba1b6149dec60e87d3a04270eda3;/common/src/main/java/org/apache/falcon/entity/FeedHelper.java;932;934;https://github.com/apache/falcon/blob/470e5e9f5de9ba1b6149dec60e87d3a04270eda3/common/src/main/java/org/apache/falcon/entity/FeedHelper.java/#L932-L934;0,5;"    public static Date getImportInitalInstance(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {
        return feedCluster.getValidity().getStart();
    }"
4028;20;5882175;blob;major;2019-04-05 15:11:36.390899;class;org.apache.usergrid.rest.management.organizations.applications.ApplicationResource;git@github.com:apache/usergrid.git;ac1e6e4035f9307b871478ed47246cf92cfd5f7f;/stack/rest/src/main/java/org/apache/usergrid/rest/management/organizations/applications/ApplicationResource.java;63;563;https://github.com/apache/usergrid/blob/ac1e6e4035f9307b871478ed47246cf92cfd5f7f/stack/rest/src/main/java/org/apache/usergrid/rest/management/organizations/applications/ApplicationResource.java/#L63-L563;1;"@Component(""org.apache.usergrid.rest.management.organizations.applications.ApplicationResource"")
@Scope(""prototype"")
@Produces({
    MediaType.APPLICATION_JSON,
    ""application/javascript"",
    ""application/x-javascript"",
    ""text/ecmascript"",
    ""application/ecmascript"",
    ""text/jscript""
})
public class ApplicationResource extends AbstractContextResource {

    private static final Logger logger = LoggerFactory.getLogger(ApplicationResource.class);

    public static final String CONFIRM_APPLICATION_IDENTIFIER = ""confirm_application_identifier"";
    public static final String RESTORE_PASSWORD = ""restore_password"";

    //@Autowired
    //protected ExportService exportService;

    OrganizationInfo organization;
    UUID applicationId;
    ApplicationInfo application;

    @Autowired
    private SignInProviderFactory signInProviderFactory;


    public ApplicationResource() {
    }


    public ApplicationResource init( OrganizationInfo organization, UUID applicationId ) {
        this.organization = organization;
        this.applicationId = applicationId;
        return this;
    }


    public ApplicationResource init( OrganizationInfo organization, ApplicationInfo application ) {
        this.organization = organization;
        applicationId = application.getId();
        this.application = application;
        return this;
    }



    @RequireOrganizationAccess
    @GET
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse getApplication(
            @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        ServiceManager sm = smf.getServiceManager( applicationId );
        response.setAction( ""get"" );
        response.setApplication( sm.getApplication() );
        response.setParams( ui.getQueryParameters() );
        response.setResults( management.getApplicationMetadata( applicationId ) );
        return response;
    }


    @RequireOrganizationAccess
    @GET
    @Path(""credentials"")
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse getCredentials(
            @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction(""get application client credentials"");

        ClientCredentialsInfo credentials =
                new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ),
                        management.getClientSecretForApplication( applicationId ) );

        response.setCredentials( credentials );
        return response;
    }


    @RequireOrganizationAccess
    @POST
    @Path(""credentials"")
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse generateCredentials( @Context UriInfo ui,
            @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""generate application client credentials"" );

        ClientCredentialsInfo credentials =
                new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ),
                        management.newClientSecretForApplication(applicationId) );

        response.setCredentials( credentials );
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""_size"")
    public ApiResponse getApplicationSize(
        @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""get application size for all entities"" );
        long size = management.getApplicationSize(this.applicationId);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> innerMap = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        innerMap.put(""application"",size);
        sumMap.put(""size"",innerMap);
        map.put(""aggregation"", sumMap);
        response.setMetadata(map);
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""{collection_name}/_size"")
    public ApiResponse getCollectionSize(
        @Context UriInfo ui,
        @PathParam( ""collection_name"" ) String collection_name,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {
        ApiResponse response = createApiResponse();
        response.setAction(""get collection size for all entities"");
        long size = management.getCollectionSize(this.applicationId, collection_name);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        Map<String,Object> innerMap = new HashMap<>();
        innerMap.put(collection_name,size);
        sumMap.put(""size"",innerMap);
        map.put(""aggregation"",sumMap);
        response.setMetadata(map);
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""collections/_size"")
    public ApiResponse getEachCollectionSize(
        @Context UriInfo ui,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {
        ApiResponse response = createApiResponse();
        response.setAction(""get collection size for all entities"");
        Map<String,Long> sizes = management.getEachCollectionSize(this.applicationId);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        sumMap.put(""size"",sizes);
        map.put(""aggregation"",sumMap);
        response.setMetadata(map);
        return response;
    }

    @POST
    @Path(""sia-provider"")
    @Consumes(APPLICATION_JSON)
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse configureProvider(
            @Context UriInfo ui,
            @QueryParam(""provider_key"") String siaProvider,
            Map<String, Object> json,
            @QueryParam(""callback"")
            @DefaultValue("""") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""post signin provider configuration"" );

        Preconditions.checkArgument( siaProvider != null, ""Sign in provider required"" );

        SignInAsProvider signInAsProvider = null;
        if ( StringUtils.equalsIgnoreCase( siaProvider, ""facebook"" ) ) {
            signInAsProvider = signInProviderFactory.facebook(
                    smf.getServiceManager( applicationId ).getApplication() );
        }
        else if ( StringUtils.equalsIgnoreCase( siaProvider, ""pingident"" ) ) {
            signInAsProvider = signInProviderFactory.pingident(
                    smf.getServiceManager( applicationId ).getApplication() );
        }
        else if ( StringUtils.equalsIgnoreCase( siaProvider, ""foursquare"" ) ) {
            signInAsProvider = signInProviderFactory.foursquare(
                    smf.getServiceManager( applicationId ).getApplication() );
        }

        Preconditions.checkArgument( signInAsProvider != null,
                ""No signin provider found by that name: "" + siaProvider );

        signInAsProvider.saveToConfiguration( json );

        return response;
    }

//    @POST
//    @Path(""export"")
//    @Consumes(APPLICATION_JSON)
//    @RequireOrganizationAccess
//    public Response exportPostJson( @Context UriInfo ui,Map<String, Object> json,
//                                    @QueryParam(""callback"") @DefaultValue("""") String callback )
//            throws OAuthSystemException {
//
//        UsergridAwsCredentials uac = new UsergridAwsCredentials();
//
//        UUID jobUUID = null;
//        Map<String, String> uuidRet = new HashMap<String, String>();
//
//        Map<String,Object> properties;
//        Map<String, Object> storage_info;
//
//        try {
//            if((properties = ( Map<String, Object> )  json.get( ""properties"" )) == null){
//                throw new NullArgumentException(""Could not find 'properties'"");
//            }
//            storage_info = ( Map<String, Object> ) properties.get( ""storage_info"" );
//            String storage_provider = ( String ) properties.get( ""storage_provider"" );
//            if(storage_provider == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_provider'"" );
//            }
//            if(storage_info == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_info'"" );
//            }
//
//
//            String bucketName = ( String ) storage_info.get( ""bucket_location"" );
//            String accessId = ( String ) storage_info.get( ""s3_access_id"" );
//            String secretKey = ( String ) storage_info.get( ""s3_key"" );
//
//            if ( bucketName == null ) {
//                throw new NullArgumentException( ""Could not find field 'bucketName'"" );
//            }
//            if ( accessId == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_access_id'"" );
//            }
//            if ( secretKey == null ) {
//
//                throw new NullArgumentException( ""Could not find field 's3_key'"" );
//            }
//
//            json.put(""organizationId"", organization.getUuid());
//            json.put( ""applicationId"",applicationId);
//
//            jobUUID = exportService.schedule( json );
//            uuidRet.put( ""Export Entity"", jobUUID.toString() );
//        }
//        catch ( NullArgumentException e ) {
//            return Response.status( SC_BAD_REQUEST )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) ).build();
//        }
//        catch ( Exception e ) {
//            // TODO: throw descriptive error message and or include on in the response
//            // TODO: fix below, it doesn't work if there is an exception.
//            // Make it look like the OauthResponse.
//            return Response.status( SC_INTERNAL_SERVER_ERROR )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) ).build();
//        }
//
//        return Response.status( SC_ACCEPTED ).entity( uuidRet ).build();
//    }
//
//    @POST
//    @Path(""collection/{collection_name}/export"")
//    @Consumes(APPLICATION_JSON)
//    @RequireOrganizationAccess
//    public Response exportPostJson( @Context UriInfo ui,
//            @PathParam( ""collection_name"" ) String collection_name ,Map<String, Object> json,
//            @QueryParam(""callback"") @DefaultValue("""") String callback )
//            throws OAuthSystemException {
//
//        UsergridAwsCredentials uac = new UsergridAwsCredentials();
//        UUID jobUUID = null;
//        String colExport = collection_name;
//        Map<String, String> uuidRet = new HashMap<String, String>();
//
//        Map<String,Object> properties;
//        Map<String, Object> storage_info;
//
//        try {
//            //checkJsonExportProperties(json);
//            if((properties = ( Map<String, Object> )  json.get( ""properties"" )) == null){
//                throw new NullArgumentException(""Could not find 'properties'"");
//            }
//            storage_info = ( Map<String, Object> ) properties.get( ""storage_info"" );
//            String storage_provider = ( String ) properties.get( ""storage_provider"" );
//            if(storage_provider == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_provider'"" );
//            }
//            if(storage_info == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_info'"" );
//            }
//
//            String bucketName = ( String ) storage_info.get( ""bucket_location"" );
//            String accessId = ( String ) storage_info.get( ""s3_access_id"" );
//            String secretKey = ( String ) storage_info.get( ""s3_key"" );
//
//            if ( accessId == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_access_id'"" );
//            }
//            if ( secretKey == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_key'"" );
//            }
//
//            if(bucketName == null) {
//                throw new NullArgumentException( ""Could not find field 'bucketName'"" );
//            }
//
//            json.put( ""organizationId"",organization.getUuid() );
//            json.put( ""applicationId"", applicationId);
//            json.put( ""collectionName"", colExport);
//
//            jobUUID = exportService.schedule( json );
//            uuidRet.put( ""Export Entity"", jobUUID.toString() );
//        }
//        catch ( NullArgumentException e ) {
//            return Response.status( SC_BAD_REQUEST )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) )
//                .build();
//        }
//        catch ( Exception e ) {
//
//            // TODO: throw descriptive error message and or include on in the response
//            // TODO: fix below, it doesn't work if there is an exception.
//            // Make it look like the OauthResponse.
//
//            OAuthResponse errorMsg = OAuthResponse.errorResponse( SC_INTERNAL_SERVER_ERROR )
//                .setErrorDescription( e.getMessage() )
//                .buildJSONMessage();
//
//            return Response.status( errorMsg.getResponseStatus() )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( errorMsg.getBody(), callback ) )
//                .build();
//        }
//
//        return Response.status( SC_ACCEPTED ).entity( uuidRet ).build();
//    }
//
//
//    @Path( ""imports"" )
//    public ImportsResource importGetJson( @Context UriInfo ui,
//                                          @QueryParam( ""callback"" ) @DefaultValue( """" ) String callback )
//        throws Exception {
//
//
//        return getSubResource( ImportsResource.class ).init( organization, application );
//    }

    @GET
    @Path(""/status"")
    public Response getStatus() {

        Map<String, Object> statusMap = new HashMap<String, Object>();

        EntityManager em = emf.getEntityManager( applicationId );
        if ( !emf.getIndexHealth().equals( Health.RED ) ) {
            statusMap.put(""message"", ""Index Health Status RED for application "" + applicationId );
            return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
        }

        try {
            if ( em.getApplication() == null ) {
                statusMap.put(""message"", ""Application "" + applicationId + "" not found"");
                return Response.status( SC_NOT_FOUND ).entity( statusMap ).build();
            }

        } catch (Exception ex) {
            statusMap.put(""message"", ""Error looking up application "" + applicationId );
            return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
        }

        return Response.status( SC_OK ).entity( null ).build();
    }



    /**
     * Put on application URL will restore application if it was deleted.
     */
    @PUT
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse executePut(  @Context UriInfo ui, String body,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback ) throws Exception {

        if ( applicationId == null ) {
            throw new IllegalArgumentException(""Application ID not specified in request"");
        }

        ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
        if (!SubjectUtils.isServiceAdmin()) {
            // require password if it exists
            String storedRestorePassword = restorePasswordService.getApplicationRestorePassword(applicationId);
            if (StringUtils.isNotEmpty(storedRestorePassword)) {
                // must have matching password as query parameter
                String suppliedRestorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
                if (!storedRestorePassword.equals(suppliedRestorePassword)) {
                    throw new IllegalArgumentException(""Application cannot be restored without application password"");
                }
            }
        }

        management.restoreApplication( applicationId );

        // not deleting password -- will be changed upon successful soft delete

        ApiResponse response = createApiResponse();
        response.setAction( ""restore"" );
        response.setApplication( emf.getEntityManager( applicationId ).getApplication() );
        response.setParams( ui.getQueryParameters() );

        return response;
    }


    /**
     * Caller MUST pass confirm_application_identifier that is either the UUID or the
     * name of the application to be deleted. Yes, this is redundant and intended to
     * be a protection measure to force caller to confirm that they want to do a delete.
     */
    @DELETE
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse executeDelete(  @Context UriInfo ui,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback,
        @QueryParam(CONFIRM_APPLICATION_IDENTIFIER) String confirmApplicationIdentifier) throws Exception {

        if ( application == null && applicationId == null ) {
            throw new IllegalArgumentException(""Application ID not specified in request"");
        }

        // If the path uses name then expect name, otherwise if they use uuid then expect uuid.
        if (application == null) {
            if (!applicationId.toString().equals( confirmApplicationIdentifier )) {
                throw new IllegalArgumentException(
                    ""Cannot delete application without supplying correct application id."");
            }

        } else if (!application.getName().split( ""/"" )[1].equals( confirmApplicationIdentifier ) ) {
            throw new IllegalArgumentException(
                ""Cannot delete application without supplying correct application name"");
        }

        String restorePassword = null;
        ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
        if (SubjectUtils.isServiceAdmin()) {
            restorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
            if (StringUtils.isNotEmpty(restorePassword)) {
                // save password, required for future undelete if not sysadmin
                restorePasswordService.setApplicationRestorePassword(applicationId, restorePassword);
            }
        }

        management.deleteApplication( applicationId );

        if (restorePassword == null) {
            // clear restore password
            restorePasswordService.removeApplicationRestorePassword(applicationId);
        }

        if (logger.isTraceEnabled()) {
            logger.trace(""ApplicationResource.delete() deleted appId = {}"", applicationId);
        }

        ApiResponse response = createApiResponse();
        response.setAction( ""delete"" );
        response.setApplication(emf.getEntityManager( applicationId ).getApplication());
        response.setParams(ui.getQueryParameters());

        if (logger.isTraceEnabled()) {
            logger.trace(""ApplicationResource.delete() sending response "");
        }

        return response;
    }

    private ApplicationRestorePasswordService getApplicationRestorePasswordService() {
        return injector.getInstance(ApplicationRestorePasswordService.class);
    }

}"
1719;5;8025832;feature envy;none;2019-03-29 14:14:09.956171;function;org.eclipse.xtext.ui.tests.editor.contentassist.services.Bug348427TestLanguageGrammarAccess.Child2_6Elements#getRule;git@github.com:eclipse/xtext-eclipse.git;0c7546b6aaf3644a77fc68eef9f3da368cbbeabd;/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/Bug348427TestLanguageGrammarAccess.java;1308;1308;https://github.com/eclipse/xtext-eclipse/blob/0c7546b6aaf3644a77fc68eef9f3da368cbbeabd/org.eclipse.xtext.ui.tests/src-gen/org/eclipse/xtext/ui/tests/editor/contentassist/services/Bug348427TestLanguageGrammarAccess.java/#L1308-L1308;1;"		@Override public ParserRule getRule() { return rule; }"
14944;20;6257015;data class;major;2019-09-12 09:56:32.100584;class;org.eclipse.hawkbit.HawkbitServerProperties.Build;git@github.com:eclipse/hawkbit.git;51be28147f6f575b6c1ab4a5ef84ffd9174f1209;/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java;75;90;https://github.com/eclipse/hawkbit/blob/51be28147f6f575b6c1ab4a5ef84ffd9174f1209/hawkbit-core/src/main/java/org/eclipse/hawkbit/HawkbitServerProperties.java/#L75-L90;1;"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }"
7679;3;9158392;blob;major;2019-07-12 23:50:33.671159;class;org.eclipse.birt.report.designer.internal.lib.providers.LibraryBreadcrumbNodeProvider;git@github.com:eclipse/birt.git;f89264810347de98702db45386a822aabc0fadbf;/UI/org.eclipse.birt.report.designer.ui.lib/src/org/eclipse/birt/report/designer/internal/lib/providers/LibraryBreadcrumbNodeProvider.java;31;127;https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/UI/org.eclipse.birt.report.designer.ui.lib/src/org/eclipse/birt/report/designer/internal/lib/providers/LibraryBreadcrumbNodeProvider.java/#L31-L127;1;"public class LibraryBreadcrumbNodeProvider extends
		DesignerBreadcrumbNodeProvider
{

	public boolean validate( Object element )
	{
		if ( getEditPart( element ) == null
		// || getEditPart( element ) instanceof EmptyEditPart
		)
			return false;
		return true;
	}

	public EditPart getEditPart( Object element )
	{
		// EditPart editPart = super.getEditPart( element );
		// if ( editPart == null || editPart instanceof EmptyEditPart )
		// return null;
		return super.getEditPart( element );
	}

	@Override
	public Object[] getChildren( Object element )
	{
		if ( getRealModel( element ) instanceof LibraryHandle )
		{
			return ( (LibraryHandle) getRealModel( element ) ).getComponents( )
					.getContents( )
					.toArray( );
		}
		List children = new ArrayList( );
		children.addAll( Arrays.asList( super.getChildren( element ) ) );
		for ( int i = 0; i < children.size( ); i++ )
		{
			if ( children.get( i ) instanceof EmptyEditPart )
			{
				children.remove( i );
				i--;
			}
		}
		return children.toArray( );
	}

	@Override
	public String getText( Object element )
	{
		Object object = getRealModel( element );
		if ( getEditPart( object ) == null )
		{
			if ( object instanceof DesignElementHandle
					&& ( (DesignElementHandle) object ).getContainer( ) instanceof LibraryHandle )
			{
				INodeProvider provider = ProviderFactory.createProvider( object );
				if ( provider == null )
					return object.toString( );
				return provider.getNodeDisplayName( object );
			}
		}
		return super.getText( element );
	}

	@Override
	public Image getImage( Object element )
	{
		Object object = getRealModel( element );
		if ( getEditPart( object ) == null )
		{
			if ( object instanceof DesignElementHandle
					&& ( (DesignElementHandle) object ).getContainer( ) instanceof LibraryHandle )
			{
				INodeProvider provider = ProviderFactory.createProvider( object );
				if ( provider == null )
					return null;
				return provider.getNodeIcon( object );
			}
		}
		return super.getImage( element );
	}

	@Override
	public String getTooltipText( Object element )
	{
		Object object = getRealModel( element );
		if ( getEditPart( object ) == null )
		{
			if ( object instanceof DesignElementHandle
					&& ( (DesignElementHandle) object ).getContainer( ) instanceof LibraryHandle )
			{
				INodeProvider provider = ProviderFactory.createProvider( object );
				if ( provider == null )
					return object.toString( );
				return provider.getNodeTooltip( object );
			}
		}
		return super.getTooltipText( element );
	}
}"
1883;5;8432331;data class;none;2019-03-29 14:30:56.997339;class;org.apache.camel.component.sql.stored.WrapperExecuteCallback;git@github.com:apache/camel.git;8a85a70643c4d6eec2d3abddeea44ecb06c2f486;/components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/WrapperExecuteCallback.java;23;26;https://github.com/apache/camel/blob/8a85a70643c4d6eec2d3abddeea44ecb06c2f486/components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/WrapperExecuteCallback.java/#L23-L26;1;"public interface WrapperExecuteCallback {

    void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException;
}"
1435;11;7484156;blob;none;2019-03-29 13:50:36.037196;class;example.service.Customer758Service;git@github.com:spring-projects/spring-data-examples.git;ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4;/jpa/deferred/src/main/java/example/service/Customer758Service.java;7;11;https://github.com/spring-projects/spring-data-examples/blob/ccae97890f85a3eaf8f4e05a1a07696e2b1e78a4/jpa/deferred/src/main/java/example/service/Customer758Service.java/#L7-L11;0;"@Service
public class Customer758Service {
	public Customer758Service(Customer758Repository repo) {
	}
}"
3459;20;7643849;blob;none;2019-04-05 13:03:50.933850;class;org.springframework.security.web.session.SessionInformationExpiredStrategy;git@github.com:spring-projects/spring-security.git;8dd2864dea3de5ea98637a1629debc89c29e76c0;/web/src/main/java/org/springframework/security/web/session/SessionInformationExpiredStrategy.java;30;34;https://github.com/spring-projects/spring-security/blob/8dd2864dea3de5ea98637a1629debc89c29e76c0/web/src/main/java/org/springframework/security/web/session/SessionInformationExpiredStrategy.java/#L30-L34;1;"public interface SessionInformationExpiredStrategy {

	void onExpiredSessionDetected(SessionInformationExpiredEvent event)
			throws IOException, ServletException;
}"
2738;20;4092105;long method;critical;2019-04-05 12:08:06.763831;function;org.apache.asterix.transaction.management.service.logging.LogManager#getOrderedLogFileIds;git@github.com:apache/asterixdb.git;223d13a06c4a4a58408aeac19674ac1f36f5ff35;/asterixdb/asterix-transactions/src/main/java/org/apache/asterix/transaction/management/service/logging/LogManager.java;440;466;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-transactions/src/main/java/org/apache/asterix/transaction/management/service/logging/LogManager.java/#L440-L466;1;"    public List<Long> getOrderedLogFileIds() {
        File fileLogDir = new File(logDir);
        String[] logFileNames = null;
        List<Long> logFileIds = null;
        if (!fileLogDir.exists()) {
            LOGGER.log(Level.INFO, ""log dir "" + logDir + "" doesn't exist.  returning empty list"");
            return Collections.emptyList();
        }
        if (!fileLogDir.isDirectory()) {
            throw new IllegalStateException(""log dir "" + logDir + "" exists but it is not a directory"");
        }
        logFileNames = fileLogDir.list((dir, name) -> name.startsWith(logFilePrefix));
        if (logFileNames == null) {
            throw new IllegalStateException(""listing of log dir ("" + logDir + "") files returned null. ""
                    + ""Either an IO error occurred or the dir was just deleted by another process/thread"");
        }
        if (logFileNames.length == 0) {
            LOGGER.log(Level.INFO, ""the log dir ("" + logDir + "") is empty. returning empty list"");
            return Collections.emptyList();
        }
        logFileIds = new ArrayList<>();
        for (String fileName : logFileNames) {
            logFileIds.add(Long.parseLong(fileName.substring(logFilePrefix.length() + 1)));
        }
        logFileIds.sort(Long::compareTo);
        return logFileIds;
    }"
10122;3;8494231;long method;major;2019-07-25 12:52:52.844246;function;com.cloud.resource.ResourceManagerImpl#discoverHosts AddHostCmd;git@github.com:apache/cloudstack.git;8d3feb100aab4a45b31a789f444038b892161eec;/server/src/main/java/com/cloud/resource/ResourceManagerImpl.java;573;611;https://github.com/apache/cloudstack/blob/8d3feb100aab4a45b31a789f444038b892161eec/server/src/main/java/com/cloud/resource/ResourceManagerImpl.java/#L573-L611;1;"    @Override
    public List<? extends Host> discoverHosts(final AddHostCmd cmd) throws IllegalArgumentException, DiscoveryException, InvalidParameterValueException {
        Long dcId = cmd.getZoneId();
        final Long podId = cmd.getPodId();
        final Long clusterId = cmd.getClusterId();
        String clusterName = cmd.getClusterName();
        final String url = cmd.getUrl();
        final String username = cmd.getUsername();
        final String password = cmd.getPassword();
        final List<String> hostTags = cmd.getHostTags();

        dcId = _accountMgr.checkAccessAndSpecifyAuthority(CallContext.current().getCallingAccount(), dcId);

        // this is for standalone option
        if (clusterName == null && clusterId == null) {
            clusterName = ""Standalone-"" + url;
        }

        if (clusterId != null) {
            final ClusterVO cluster = _clusterDao.findById(clusterId);
            if (cluster == null) {
                final InvalidParameterValueException ex = new InvalidParameterValueException(""can not find cluster for specified clusterId"");
                ex.addProxyObject(clusterId.toString(), ""clusterId"");
                throw ex;
            } else {
                if (cluster.getGuid() == null) {
                    final List<HostVO> hosts = listAllHostsInCluster(clusterId);
                    if (!hosts.isEmpty()) {
                        final CloudRuntimeException ex =
                                new CloudRuntimeException(""Guid is not updated for cluster with specified cluster id; need to wait for hosts in this cluster to come up"");
                        ex.addProxyObject(cluster.getUuid(), ""clusterId"");
                        throw ex;
                    }
                }
            }
        }

        return discoverHostsFull(dcId, podId, clusterId, clusterName, url, username, password, cmd.getHypervisor(), hostTags, cmd.getFullUrlParams(), false);
    }"
4437;5;8987975;blob;major;2019-04-12 12:33:26.315634;class;org.apache.lucene.index.DocumentsWriterDeleteQueue;git@github.com:apache/lucene-solr.git;bca22d58e2d126ec6d349d375d3ea028892104e1;/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java;71;495;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java/#L71-L495;1;"final class DocumentsWriterDeleteQueue implements Accountable {

  // the current end (latest delete operation) in the delete queue:
  private volatile Node<?> tail;

  /** Used to record deletes against all prior (already written to disk) segments.  Whenever any segment flushes, we bundle up this set of
   *  deletes and insert into the buffered updates stream before the newly flushed segment(s). */
  private final DeleteSlice globalSlice;
  private final BufferedUpdates globalBufferedUpdates;
  
  // only acquired to update the global deletes, pkg-private for access by tests:
  final ReentrantLock globalBufferLock = new ReentrantLock();

  final long generation;

  /** Generates the sequence number that IW returns to callers changing the index, showing the effective serialization of all operations. */
  private final AtomicLong nextSeqNo;

  private final InfoStream infoStream;

  // for asserts
  long maxSeqNo = Long.MAX_VALUE;
  
  DocumentsWriterDeleteQueue(InfoStream infoStream) {
    // seqNo must start at 1 because some APIs negate this to also return a boolean
    this(infoStream, 0, 1);
  }
  
  DocumentsWriterDeleteQueue(InfoStream infoStream, long generation, long startSeqNo) {
    this(infoStream, new BufferedUpdates(""global""), generation, startSeqNo);
  }

  DocumentsWriterDeleteQueue(InfoStream infoStream, BufferedUpdates globalBufferedUpdates, long generation, long startSeqNo) {
    this.infoStream = infoStream;
    this.globalBufferedUpdates = globalBufferedUpdates;
    this.generation = generation;
    this.nextSeqNo = new AtomicLong(startSeqNo);
    /*
     * we use a sentinel instance as our initial tail. No slice will ever try to
     * apply this tail since the head is always omitted.
     */
    tail = new Node<>(null); // sentinel
    globalSlice = new DeleteSlice(tail);
  }

  long addDelete(Query... queries) {
    long seqNo = add(new QueryArrayNode(queries));
    tryApplyGlobalSlice();
    return seqNo;
  }

  long addDelete(Term... terms) {
    long seqNo = add(new TermArrayNode(terms));
    tryApplyGlobalSlice();
    return seqNo;
  }

  long addDocValuesUpdates(DocValuesUpdate... updates) {
    long seqNo = add(new DocValuesUpdatesNode(updates));
    tryApplyGlobalSlice();
    return seqNo;
  }

  static Node<Term> newNode(Term term) {
    return new TermNode(term);
  }

  static Node<DocValuesUpdate[]> newNode(DocValuesUpdate... updates) {
    return new DocValuesUpdatesNode(updates);
  }

  /**
   * invariant for document update
   */
  long add(Node<?> deleteNode, DeleteSlice slice) {
    long seqNo = add(deleteNode);
    /*
     * this is an update request where the term is the updated documents
     * delTerm. in that case we need to guarantee that this insert is atomic
     * with regards to the given delete slice. This means if two threads try to
     * update the same document with in turn the same delTerm one of them must
     * win. By taking the node we have created for our del term as the new tail
     * it is guaranteed that if another thread adds the same right after us we
     * will apply this delete next time we update our slice and one of the two
     * competing updates wins!
     */
    slice.sliceTail = deleteNode;
    assert slice.sliceHead != slice.sliceTail : ""slice head and tail must differ after add"";
    tryApplyGlobalSlice(); // TODO doing this each time is not necessary maybe
    // we can do it just every n times or so?

    return seqNo;
  }

  synchronized long add(Node<?> newNode) {
    tail.next = newNode;
    this.tail = newNode;
    return getNextSequenceNumber();
  }

  boolean anyChanges() {
    globalBufferLock.lock();
    try {
      /*
       * check if all items in the global slice were applied 
       * and if the global slice is up-to-date
       * and if globalBufferedUpdates has changes
       */
      return globalBufferedUpdates.any() || !globalSlice.isEmpty() || globalSlice.sliceTail != tail || tail.next != null;
    } finally {
      globalBufferLock.unlock();
    }
  }

  void tryApplyGlobalSlice() {
    if (globalBufferLock.tryLock()) {
      /*
       * The global buffer must be locked but we don't need to update them if
       * there is an update going on right now. It is sufficient to apply the
       * deletes that have been added after the current in-flight global slices
       * tail the next time we can get the lock!
       */
      try {
        if (updateSliceNoSeqNo(globalSlice)) {
          globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
        }
      } finally {
        globalBufferLock.unlock();
      }
    }
  }

  FrozenBufferedUpdates freezeGlobalBuffer(DeleteSlice callerSlice) throws IOException {
    globalBufferLock.lock();
    /*
     * Here we freeze the global buffer so we need to lock it, apply all
     * deletes in the queue and reset the global slice to let the GC prune the
     * queue.
     */
    final Node<?> currentTail = tail; // take the current tail make this local any
    // Changes after this call are applied later
    // and not relevant here
    if (callerSlice != null) {
      // Update the callers slices so we are on the same page
      callerSlice.sliceTail = currentTail;
    }
    try {
      if (globalSlice.sliceTail != currentTail) {
        globalSlice.sliceTail = currentTail;
        globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
      }

      if (globalBufferedUpdates.any()) {
        final FrozenBufferedUpdates packet = new FrozenBufferedUpdates(infoStream, globalBufferedUpdates, null);
        globalBufferedUpdates.clear();
        return packet;
      } else {
        return null;
      }
    } finally {
      globalBufferLock.unlock();
    }
  }

  DeleteSlice newSlice() {
    return new DeleteSlice(tail);
  }

  /** Negative result means there were new deletes since we last applied */
  synchronized long updateSlice(DeleteSlice slice) {
    long seqNo = getNextSequenceNumber();
    if (slice.sliceTail != tail) {
      // new deletes arrived since we last checked
      slice.sliceTail = tail;
      seqNo = -seqNo;
    }
    return seqNo;
  }

  /** Just like updateSlice, but does not assign a sequence number */
  boolean updateSliceNoSeqNo(DeleteSlice slice) {
    if (slice.sliceTail != tail) {
      // new deletes arrived since we last checked
      slice.sliceTail = tail;
      return true;
    }
    return false;
  }

  static class DeleteSlice {
    // No need to be volatile, slices are thread captive (only accessed by one thread)!
    Node<?> sliceHead; // we don't apply this one
    Node<?> sliceTail;

    DeleteSlice(Node<?> currentTail) {
      assert currentTail != null;
      /*
       * Initially this is a 0 length slice pointing to the 'current' tail of
       * the queue. Once we update the slice we only need to assign the tail and
       * have a new slice
       */
      sliceHead = sliceTail = currentTail;
    }

    void apply(BufferedUpdates del, int docIDUpto) {
      if (sliceHead == sliceTail) {
        // 0 length slice
        return;
      }
      /*
       * When we apply a slice we take the head and get its next as our first
       * item to apply and continue until we applied the tail. If the head and
       * tail in this slice are not equal then there will be at least one more
       * non-null node in the slice!
       */
      Node<?> current = sliceHead;
      do {
        current = current.next;
        assert current != null : ""slice property violated between the head on the tail must not be a null node"";
        current.apply(del, docIDUpto);
      } while (current != sliceTail);
      reset();
    }

    void reset() {
      // Reset to a 0 length slice
      sliceHead = sliceTail;
    }

    /**
     * Returns <code>true</code> iff the given node is identical to the the slices tail,
     * otherwise <code>false</code>.
     */
    boolean isTail(Node<?> node) {
      return sliceTail == node;
    }

    /**
     * Returns <code>true</code> iff the given item is identical to the item
     * hold by the slices tail, otherwise <code>false</code>.
     */
    boolean isTailItem(Object object) {
      return sliceTail.item == object;
    }

    boolean isEmpty() {
      return sliceHead == sliceTail;
    }
  }

  public int numGlobalTermDeletes() {
    return globalBufferedUpdates.numTermDeletes.get();
  }

  void clear() {
    globalBufferLock.lock();
    try {
      final Node<?> currentTail = tail;
      globalSlice.sliceHead = globalSlice.sliceTail = currentTail;
      globalBufferedUpdates.clear();
    } finally {
      globalBufferLock.unlock();
    }
  }

  static class Node<T> {
    volatile Node<?> next;
    final T item;

    Node(T item) {
      this.item = item;
    }

    void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {
      throw new IllegalStateException(""sentinel item must never be applied"");
    }

    boolean isDelete() {
      return true;
    }
  }

  private static final class TermNode extends Node<Term> {

    TermNode(Term term) {
      super(term);
    }

    @Override
    void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {
      bufferedDeletes.addTerm(item, docIDUpto);
    }

    @Override
    public String toString() {
      return ""del="" + item;
    }

  }

  private static final class QueryArrayNode extends Node<Query[]> {
    QueryArrayNode(Query[] query) {
      super(query);
    }

    @Override
    void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
      for (Query query : item) {
        bufferedUpdates.addQuery(query, docIDUpto);  
      }
    }
  }
  
  private static final class TermArrayNode extends Node<Term[]> {
    TermArrayNode(Term[] term) {
      super(term);
    }

    @Override
    void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
      for (Term term : item) {
        bufferedUpdates.addTerm(term, docIDUpto);  
      }
    }

    @Override
    public String toString() {
      return ""dels="" + Arrays.toString(item);
    }

  }

  private static final class DocValuesUpdatesNode extends Node<DocValuesUpdate[]> {

    DocValuesUpdatesNode(DocValuesUpdate... updates) {
      super(updates);
    }

    @Override
    void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
      for (DocValuesUpdate update : item) {
        switch (update.type) {
          case NUMERIC:
            bufferedUpdates.addNumericUpdate((NumericDocValuesUpdate) update, docIDUpto);
            break;
          case BINARY:
            bufferedUpdates.addBinaryUpdate((BinaryDocValuesUpdate) update, docIDUpto);
            break;
          default:
            throw new IllegalArgumentException(update.type + "" DocValues updates not supported yet!"");
        }
      }
    }


    @Override
    boolean isDelete() {
      return false;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder();
      sb.append(""docValuesUpdates: "");
      if (item.length > 0) {
        sb.append(""term="").append(item[0].term).append(""; updates: ["");
        for (DocValuesUpdate update : item) {
          sb.append(update.field).append(':').append(update.valueToString()).append(',');
        }
        sb.setCharAt(sb.length()-1, ']');
      }
      return sb.toString();
    }
  }
  
  private boolean forceApplyGlobalSlice() {
    globalBufferLock.lock();
    final Node<?> currentTail = tail;
    try {
      if (globalSlice.sliceTail != currentTail) {
        globalSlice.sliceTail = currentTail;
        globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
      }
      return globalBufferedUpdates.any();
    } finally {
      globalBufferLock.unlock();
    }
  }

  public int getBufferedUpdatesTermsSize() {
    globalBufferLock.lock();
    try {
      forceApplyGlobalSlice();
      return globalBufferedUpdates.deleteTerms.size();
    } finally {
      globalBufferLock.unlock();
    }
  }

  @Override
  public long ramBytesUsed() {
    return globalBufferedUpdates.ramBytesUsed();
  }

  @Override
  public String toString() {
    return ""DWDQ: [ generation: "" + generation + "" ]"";
  }

  public long getNextSequenceNumber() {
    long seqNo = nextSeqNo.getAndIncrement();
    assert seqNo < maxSeqNo: ""seqNo="" + seqNo + "" vs maxSeqNo="" + maxSeqNo;
    return seqNo;
  }  

  public long getLastSequenceNumber() {
    return nextSeqNo.get()-1;
  }  

  /** Inserts a gap in the sequence numbers.  This is used by IW during flush or commit to ensure any in-flight threads get sequence numbers
   *  inside the gap */
  public void skipSequenceNumbers(long jump) {
    nextSeqNo.addAndGet(jump);
  }  
}"
1010;5;6921162;long method;none;2019-03-29 13:26:11.900964;function;com.google.gdata.data.spreadsheet.Field#hasIndex;git@github.com:google/gdata-java-client.git;c6202a55f5f29afb37ffcf876674dca372f3fb4c;/java/src/com/google/gdata/data/spreadsheet/Field.java;101;103;https://github.com/google/gdata-java-client/blob/c6202a55f5f29afb37ffcf876674dca372f3fb4c/java/src/com/google/gdata/data/spreadsheet/Field.java/#L101-L103;0,5;"  public boolean hasIndex() {
    return getIndex() != null;
  }"
14843;21;6019048;data class;major;2019-09-12 09:06:02.187195;class;org.cloudfoundry.identity.uaa.account.ChangeEmailController.ValidEmail;git@github.com:cloudfoundry/uaa.git;f3b66dd2a250c1309a86cade560ac9a9cfeafec7;/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java;147;158;https://github.com/cloudfoundry/uaa/blob/f3b66dd2a250c1309a86cade560ac9a9cfeafec7/server/src/main/java/org/cloudfoundry/identity/uaa/account/ChangeEmailController.java/#L147-L158;1;"    public static class ValidEmail {
        @Email
        String newEmail;

        public String getNewEmail() {
            return newEmail;
        }

        public void setNewEmail(String email) {
            this.newEmail = email;
        }
    }"
934;5;6623499;long method;none;2019-03-29 13:21:58.298424;function;net.lightbody.bmp.core.har.HarPostData#getParams;git@github.com:epam/Wilma.git;af271176f7847d06512b62ed8f1a4a0e7fd8b10a;/browsermob-proxy/src/main/java/net/lightbody/bmp/core/har/HarPostData.java;21;23;https://github.com/epam/Wilma/blob/af271176f7847d06512b62ed8f1a4a0e7fd8b10a/browsermob-proxy/src/main/java/net/lightbody/bmp/core/har/HarPostData.java/#L21-L23;1;"    public List<HarPostDataParam> getParams() {
        return params;
    }"
5666;6;9127614;feature envy;major;2019-04-16 18:36:27.180695;function;org.eclipse.birt.core.fs.LocalFile#mkdirs;git@github.com:eclipse/birt.git;f89264810347de98702db45386a822aabc0fadbf;/core/org.eclipse.birt.core/src/org/eclipse/birt/core/fs/LocalFile.java;80;84;https://github.com/eclipse/birt/blob/f89264810347de98702db45386a822aabc0fadbf/core/org.eclipse.birt.core/src/org/eclipse/birt/core/fs/LocalFile.java/#L80-L84;1;"	@Override
	public boolean mkdirs( )
	{
		return file.mkdirs( );
	}"
2087;3;8602083;data class;none;2019-04-01 13:10:15.183234;class;org.apache.hadoop.hbase.thrift2.generated.TAppend.TAppendStandardSchemeFactory;git@github.com:apache/hbase.git;44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f;/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAppend.java;771;775;https://github.com/apache/hbase/blob/44f8abd5c65c59e9d09f6ad14b3c825f145d8e4f/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/generated/TAppend.java/#L771-L775;1;"  private static class TAppendStandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
    public TAppendStandardScheme getScheme() {
      return new TAppendStandardScheme();
    }
  }"
12705;3;7992491;long method;major;2019-08-06 20:33:21.011064;function;org.eclipse.xtext.xbase.validation.XbaseValidator#checkNoForwardReferences XExpression;git@github.com:eclipse/xtext-extras.git;5634c291880cd46fe2f8e9a47e48ef88b85e8bda;/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/validation/XbaseValidator.java;1028;1063;https://github.com/eclipse/xtext-extras/blob/5634c291880cd46fe2f8e9a47e48ef88b85e8bda/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/validation/XbaseValidator.java/#L1028-L1063;0;"	@Check
	public void checkNoForwardReferences(XExpression fieldInitializer) {
		JvmIdentifiableElement container = logicalContainerProvider.getLogicalContainer(fieldInitializer);
		if (container instanceof JvmField) {
			JvmField field = (JvmField) container;
			boolean staticField = field.isStatic();
			JvmDeclaredType declaredType = field.getDeclaringType();
			if (declaredType == null) {
				return;
			}
			Collection<JvmField> illegalFields = Sets.newHashSet();
			for(int i = declaredType.getMembers().size() - 1; i>=0; i--) {
				JvmMember member = declaredType.getMembers().get(i);
				if (member instanceof JvmField) {
					if (((JvmField) member).isStatic() == staticField) {
						illegalFields.add((JvmField) member);
					}
				}
				if (member == field)
					break;
			}
			TreeIterator<EObject> iterator = EcoreUtil2.eAll(fieldInitializer);
			while(iterator.hasNext()) {
				EObject object = iterator.next();
				if (object instanceof XFeatureCall) {
					JvmIdentifiableElement feature = ((XFeatureCall) object).getFeature();
					if (illegalFields.contains(((XFeatureCall) object).getFeature())) {
						error(""Cannot reference the field '"" + feature.getSimpleName() + ""' before it is defined"", 
								object, null, INSIGNIFICANT_INDEX, ILLEGAL_FORWARD_REFERENCE);
					}
				} else if (isLocalClassSemantics(object)) {
					iterator.prune();
				}
			}
		}
	}"
638;6;6009570;long method;none;2019-03-27 10:58:16.977414;function;com.baidu.pbrpc.register.redis.JedisPool.JedisPool GenericObjectPoolConfig|String|int;git@github.com:baidu/Jprotobuf-rpc-socket.git;4422e24c725eaf1f76646f674718bcc8750a4e1d;/jprotobuf-rpc-registry-redis/src/main/java/com/baidu/pbrpc/register/redis/JedisPool.java;53;55;https://github.com/baidu/Jprotobuf-rpc-socket/blob/4422e24c725eaf1f76646f674718bcc8750a4e1d/jprotobuf-rpc-registry-redis/src/main/java/com/baidu/pbrpc/register/redis/JedisPool.java/#L53-L55;1;"    public JedisPool(final GenericObjectPoolConfig poolConfig, final String host, final int port) {
        this(poolConfig, host, port, Protocol.DEFAULT_TIMEOUT, null);
    }"
12529;3;5394068;blob;major;2019-08-06 16:49:10.854075;class;org.apache.phoenix.hbase.index.metrics.MetricsIndexerSource;git@github.com:apache/phoenix.git;69e5bb0b304a53967cef40b2a4cfc66e69ecaa51;/phoenix-core/src/main/java/org/apache/phoenix/hbase/index/metrics/MetricsIndexerSource.java;25;150;https://github.com/apache/phoenix/blob/69e5bb0b304a53967cef40b2a4cfc66e69ecaa51/phoenix-core/src/main/java/org/apache/phoenix/hbase/index/metrics/MetricsIndexerSource.java/#L25-L150;1;"public interface MetricsIndexerSource extends BaseSource {
  // Metrics2 and JMX constants
  String METRICS_NAME = ""PhoenixIndexer"";
  String METRICS_CONTEXT = ""phoenix"";
  String METRICS_DESCRIPTION = ""Metrics about the Phoenix Indexer"";
  String METRICS_JMX_CONTEXT = ""RegionServer,sub="" + METRICS_NAME;

  String INDEX_PREPARE_TIME = ""indexPrepareTime"";
  String INDEX_PREPARE_TIME_DESC = ""Histogram for the time in milliseconds for preparing an index write"";
  String SLOW_INDEX_PREPARE = ""slowIndexPrepareCalls"";
  String SLOW_INDEX_PREPARE_DESC = ""The number of index preparations slower than the configured threshold"";

  String INDEX_WRITE_TIME = ""indexWriteTime"";
  String INDEX_WRITE_TIME_DESC = ""Histogram for the time in milliseconds for writing an index update"";
  String SLOW_INDEX_WRITE = ""slowIndexWriteCalls"";
  String SLOW_INDEX_WRITE_DESC = ""The number of index writes slower than the configured threshold"";

  String DUPLICATE_KEY_TIME = ""duplicateKeyCheckTime"";
  String DUPLICATE_KEY_TIME_DESC = ""Histogram for the time in milliseconds to handle ON DUPLICATE keywords"";
  String SLOW_DUPLICATE_KEY = ""slowDuplicateKeyCheckCalls"";
  String SLOW_DUPLICATE_KEY_DESC = ""The number of on duplicate key checks slower than the configured threshold"";

  String PRE_WAL_RESTORE_TIME = ""preWALRestoreTime"";
  String PRE_WAL_RESTORE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's preWALRestore"";
  String SLOW_PRE_WAL_RESTORE = ""slowPreWALRestoreCalls"";
  String SLOW_PRE_WAL_RESTORE_DESC = ""The number of preWALRestore calls slower than the configured threshold"";

  String POST_PUT_TIME = ""postPutTime"";
  String POST_PUT_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postPut"";
  String SLOW_POST_PUT = ""slowPostPutCalls"";
  String SLOW_POST_PUT_DESC = ""The number of postPut calls slower than the configured threshold"";

  String POST_DELETE_TIME = ""postDeleteTime"";
  String POST_DELETE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postDelete"";
  String SLOW_POST_DELETE = ""slowPostDeleteCalls"";
  String SLOW_POST_DELETE_DESC = ""The number of postDelete calls slower than the configured threshold"";

  String POST_OPEN_TIME = ""postOpenTime"";
  String POST_OPEN_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postOpen"";
  String SLOW_POST_OPEN = ""slowPostOpenCalls"";
  String SLOW_POST_OPEN_DESC = ""The number of postOpen calls slower than the configured threshold"";

  /**
   * Updates the index preparation time histogram (preBatchMutate).
   *
   * @param t time taken in milliseconds
   */
  void updateIndexPrepareTime(long t);

  /**
   * Increments the number of slow calls prepare an index write.
   */
  void incrementNumSlowIndexPrepareCalls();

  /**
   * Updates the index write time histogram (postBatchMutate).
   *
   * @param t time taken in milliseconds
   */
  void updateIndexWriteTime(long t);

  /**
   * Increments the number of slow calls to write to the index.
   */
  void incrementNumSlowIndexWriteCalls();

  /**
   * Updates the preWALRestore time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePreWALRestoreTime(long t);

  /**
   * Increments the number of slow preWALRestore calls.
   */
  void incrementNumSlowPreWALRestoreCalls();

  /**
   * Updates the postPut time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostPutTime(long t);

  /**
   * Increments the number of slow postPut calls.
   */
  void incrementNumSlowPostPutCalls();

  /**
   * Updates the postDelete time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostDeleteTime(long t);

  /**
   * Increments the number of slow postDelete calls.
   */
  void incrementNumSlowPostDeleteCalls();

  /**
   * Updates the postOpen time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostOpenTime(long t);

  /**
   * Increments the number of slow postOpen calls.
   */
  void incrementNumSlowPostOpenCalls();

  /**
   * Updates the preIncrementAfterRowLock time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updateDuplicateKeyCheckTime(long t);

  /**
   * Increments the number of slow preIncrementAfteRowLock calls.
   */
  void incrementSlowDuplicateKeyCheckCalls();
}"
10683;13;7554762;feature envy;critical;2019-07-26 13:17:55.687689;function;org.springframework.integration.ws.config.WebServiceOutboundGatewayParser#getGatewayClassName Element;git@github.com:spring-projects/spring-integration.git;872302de6e98c1fd34e3192d8e4de244008ca857;/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParser.java;47;51;https://github.com/spring-projects/spring-integration/blob/872302de6e98c1fd34e3192d8e4de244008ca857/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParser.java/#L47-L51;1;"	@Override
	protected String getGatewayClassName(Element element) {
		return ((StringUtils.hasText(element.getAttribute(""marshaller""))) ?
				MarshallingWebServiceOutboundGateway.class : SimpleWebServiceOutboundGateway.class).getName();
	}"
3958;13;7396410;data class;none;2019-04-05 14:42:45.187829;class;org.graalvm.compiler.truffle.runtime.TruffleRuntimeOptions.Lazy;git@github.com:oracle/graal.git;4deb681aaaa79c248115037fc8e399c9876619fd;/compiler/src/org.graalvm.compiler.truffle.runtime/src/org/graalvm/compiler/truffle/runtime/TruffleRuntimeOptions.java;53;55;https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/compiler/src/org.graalvm.compiler.truffle.runtime/src/org/graalvm/compiler/truffle/runtime/TruffleRuntimeOptions.java/#L53-L55;1;"    static class Lazy {
        static final ThreadLocal<TruffleRuntimeOptionsOverrideScope> overrideScope = new ThreadLocal<>();
    }"
5564;6;4402431;feature envy;major;2019-04-16 18:22:43.929686;function;org.apache.cxf.rs.security.jose.jwk.JwkUtils.fromRSAPrivateKey RSAPrivateKey|String|String;git@github.com:apache/cxf.git;6bf89e9c8804c8845ec4d38583dd33eea8256439;/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java;448;469;https://github.com/apache/cxf/blob/6bf89e9c8804c8845ec4d38583dd33eea8256439/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java/#L448-L469;1;"    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);
        if (pk instanceof RSAPrivateCrtKey) {
            RSAPrivateCrtKey pkCrt = (RSAPrivateCrtKey)pk;
            jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP,
                            Base64UrlUtility.encode(pkCrt.getPublicExponent().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT,
                            Base64UrlUtility.encode(pkCrt.getCrtCoefficient().toByteArray()));
        }
        // ""oth"" can be populated too if needed
        return jwk;
    }"
